{"version":3,"file":"datadog-rum.js","mappings":"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","sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils/polyfills.ts","webpack:///../core/src/tools/getGlobalObject.ts","webpack:///../core/src/tools/utils/byteUtils.ts","webpack:///../core/src/tools/getZoneJsOriginalValue.ts","webpack:///../core/src/tools/timer.ts","webpack:///../core/src/tools/utils/functionUtils.ts","webpack:///../core/src/tools/utils/typeUtils.ts","webpack:///../core/src/tools/mergeInto.ts","webpack:///../core/src/tools/serialisation/jsonStringify.ts","webpack:///../core/src/tools/serialisation/sanitize.ts","webpack:///../core/src/tools/serialisation/heavyCustomerDataWarning.ts","webpack:///../core/src/tools/serialisation/contextManager.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/tools/utils/numberUtils.ts","webpack:///../core/src/tools/utils/timeUtils.ts","webpack:///../core/src/tools/utils/stringUtils.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/domain/tracekit/computeStackTrace.ts","webpack:///../core/src/domain/error/error.ts","webpack:///../core/src/tools/experimentalFeatures.ts","webpack:///../core/src/domain/user/user.ts","webpack:///../core/src/tools/utils/objectUtils.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/domain/session/storeStrategies/sessionStoreStrategy.ts","webpack:///../core/src/domain/session/sessionState.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInCookie.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInLocalStorage.ts","webpack:///../core/src/domain/session/sessionStoreOperations.ts","webpack:///../core/src/tools/utils/browserDetection.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/tools/utils/urlPolyfill.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/tools/matchOption.ts","webpack:///../rum-core/src/domain/tracing/tracer.ts","webpack:///../rum-core/src/domain/configuration.ts","webpack:///../rum-core/src/domain/contexts/commonContext.ts","webpack:///../core/src/tools/sendToExtension.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../core/src/browser/addEventListener.ts","webpack:///../core/src/browser/pageExitObservable.ts","webpack:///../rum-core/src/browser/domMutationObservable.ts","webpack:///../core/src/browser/runOnReadyState.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/resourceUtils.ts","webpack:///../rum-core/src/browser/htmlDomUtils.ts","webpack:///../rum-core/src/domain/tracing/getDocumentTraceId.ts","webpack:///../rum-core/src/browser/performanceCollection.ts","webpack:///../core/src/domain/error/error.types.ts","webpack:///../rum-core/src/browser/viewportObservable.ts","webpack:///../rum-core/src/domain/contexts/displayContext.ts","webpack:///../core/src/domain/eventRateLimiter/createEventRateLimiter.ts","webpack:///../rum-core/src/domain/contexts/syntheticsContext.ts","webpack:///../rum-core/src/domain/limitModification.ts","webpack:///../rum-core/src/domain/assembly.ts","webpack:///../rum-core/src/domain/contexts/ciTestContext.ts","webpack:///../core/src/tools/abstractLifeCycle.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../rum-core/src/domain/lifeCycle.ts","webpack:///../core/src/tools/valueHistory.ts","webpack:///../rum-core/src/domain/contexts/viewContexts.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///../rum-core/src/domain/requestCollection.ts","webpack:///../core/src/tools/utils/responseUtils.ts","webpack:///../core/src/tools/readBytesFromStream.ts","webpack:///../rum-core/src/domain/trackEventCounts.ts","webpack:///../rum-core/src/domain/waitPageActivityEnd.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/clickChain.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/getActionNameFromElement.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/getSelectorFromElement.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/listenActionEvents.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/computeFrustration.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/trackClickActions.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/actionCollection.ts","webpack:///../core/src/domain/tracekit/tracekit.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackFirstHidden.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/errorCollection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/trackConsoleError.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/trackReportError.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/matchRequestTiming.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/resourceCollection.ts","webpack:///../rum-core/src/domain/contexts/foregroundContexts.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackInitialViewTimings.ts","webpack:///../rum-core/src/browser/scroll.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViewMetrics.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViewEventCounts.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViews.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/viewCollection.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///../rum-core/src/domain/rumSessionManager.ts","webpack:///../core/src/transport/flushController.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../rum-core/src/transport/startRumBatch.ts","webpack:///../rum-core/src/domain/contexts/urlContexts.ts","webpack:///../rum-core/src/browser/locationChangeObservable.ts","webpack:///../rum-core/src/domain/contexts/featureFlagContext.ts","webpack:///../rum-core/src/domain/startCustomerDataTelemetry.ts","webpack:///../rum-core/src/domain/contexts/pageStateHistory.ts","webpack:///../rum-core/src/domain/getSessionReplayUrl.ts","webpack:///./src/types/sessionReplayConstants.ts","webpack:///./src/domain/record/assembly.ts","webpack:///./src/constants.ts","webpack:///./src/domain/record/privacy.ts","webpack:///./src/domain/record/serialization/serializationUtils.ts","webpack:///./src/domain/record/serialization/serializeStyleSheets.ts","webpack:///./src/domain/record/serialization/serializeAttribute.ts","webpack:///./src/domain/record/serialization/serializeAttributes.ts","webpack:///./src/domain/record/serialization/serializeNode.ts","webpack:///./src/domain/record/serialization/serializeDocument.ts","webpack:///./src/domain/record/eventsUtils.ts","webpack:///./src/domain/record/viewports.ts","webpack:///./src/domain/record/observers/moveObserver.ts","webpack:///./src/domain/record/observers/scrollObserver.ts","webpack:///./src/domain/record/observers/mouseInteractionObserver.ts","webpack:///./src/domain/record/observers/inputObserver.ts","webpack:///./src/domain/record/observers/styleSheetObserver.ts","webpack:///./src/domain/record/observers/viewportResizeObserver.ts","webpack:///./src/domain/record/mutationBatch.ts","webpack:///./src/domain/record/observers/mutationObserver.ts","webpack:///./src/domain/record/observers/observers.ts","webpack:///./src/domain/record/observers/mediaInteractionObserver.ts","webpack:///./src/domain/record/observers/focusObserver.ts","webpack:///./src/domain/record/observers/recordIds.ts","webpack:///./src/domain/record/observers/frustrationObserver.ts","webpack:///./src/domain/record/shadowRootsController.ts","webpack:///./src/domain/record/record.ts","webpack:///./src/domain/record/elementsScrollPositions.ts","webpack:///./src/domain/replayStats.ts","webpack:///./src/domain/segmentCollection/segment.ts","webpack:///./src/domain/segmentCollection/segmentCollection.ts","webpack:///./src/domain/segmentCollection/buildReplayPayload.ts","webpack:///../worker/esm/entries/string.js","webpack:///./src/domain/segmentCollection/startDeflateWorker.ts","webpack:///./src/boot/isBrowserSupported.ts","webpack:///./src/domain/getSessionReplayLink.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///./src/boot/recorderApi.ts","webpack:///./src/boot/startRecording.ts","webpack:///../rum-core/src/boot/rumPublicApi.ts","webpack:///../rum-core/src/boot/startRum.ts","webpack:///../rum-core/src/transport/startRumEventBridge.ts","webpack:///../rum-core/src/domain/rumEventsCollection/longTask/longTaskCollection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/startWebVitalTelemetryDebug.ts","webpack:///../rum-core/src/domain/contexts/internalContext.ts"],"sourcesContent":["/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = (typeof ConsoleApiName)[keyof typeof ConsoleApiName]\n\ninterface Display {\n  (api: ConsoleApiName, ...args: any[]): void\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\nexport const display: Display = (api, ...args) => {\n  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {\n    api = ConsoleApiName.log\n  }\n  display[api](...args)\n}\n\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console\n\ndisplay.debug = globalConsole.debug.bind(globalConsole)\ndisplay.log = globalConsole.log.bind(globalConsole)\ndisplay.info = globalConsole.info.bind(globalConsole)\ndisplay.warn = globalConsole.warn.bind(globalConsole)\ndisplay.error = globalConsole.error.bind(globalConsole)\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { ConsoleApiName, display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(ConsoleApiName.error, e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(ConsoleApiName.error, e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(api: ConsoleApiName, ...args: any[]) {\n  if (debugMode) {\n    display(api, '[MONITOR]', ...args)\n  }\n}\n","export function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(\n  array: ArrayLike<unknown>,\n  predicate: (item: unknown, index: number) => boolean\n): unknown | undefined {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function forEach<List extends { [index: number]: any }>(\n  list: List,\n  callback: (value: List[number], index: number, parent: List) => void\n) {\n  Array.prototype.forEach.call(list, callback as any)\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectEntries<T = unknown>(object: { [key: string]: T }): Array<[string, T]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\n// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\n\nexport function getGlobalObject<T = typeof globalThis>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n","export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]) {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n","import { getGlobalObject } from './getGlobalObject'\n\nexport interface BrowserWindowWithZoneJs extends Window {\n  Zone?: {\n    // All Zone.js versions expose the __symbol__ method, but we observed that some website have a\n    // 'Zone' global variable unrelated to Zone.js, so let's consider this method optional\n    // nonetheless.\n    __symbol__?: (name: string) => string\n  }\n}\n\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue<Target, Name extends keyof Target & string>(\n  target: Target,\n  name: Name\n): Target[Name] {\n  const browserWindow = getGlobalObject<BrowserWindowWithZoneJs>()\n  let original: Target[Name] | undefined\n  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n    original = (target as any)[browserWindow.Zone.__symbol__(name)]\n  }\n  if (!original) {\n    original = target[name]\n  }\n  return original\n}\n","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue'\nimport { monitor } from './monitor'\nimport { getGlobalObject } from './getGlobalObject'\n\nexport type TimeoutId = ReturnType<typeof globalThis.setTimeout>\n\nexport function setTimeout(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay)\n}\n\nexport function clearTimeout(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId)\n}\n\nexport function setInterval(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay)\n}\n\nexport function clearInterval(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId)\n}\n","import type { TimeoutId } from '../timer'\nimport { setTimeout, clearTimeout } from '../timer'\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\nexport type ListenerHandler = () => void\n","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n","import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n    TDestination extends undefined\n    ? TSource\n    : // case 3 - source is an array - see if it merges or overwrites\n    TSource extends any[]\n    ? TDestination extends any[]\n      ? TDestination & TSource\n      : TSource\n    : // case 4 - source is an object - see if it merges or overwrites\n    TSource extends object\n    ? TDestination extends object\n      ? TDestination extends any[]\n        ? TSource\n        : TDestination & TSource\n      : TSource\n    : // case 5 - cannot merge - return source\n      TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n","import { noop } from '../utils/functionUtils'\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(\n  value: unknown,\n  replacer?: Array<string | number>,\n  space?: string | number\n): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, replacer, space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\nexport interface ObjectWithToJsonMethod {\n  toJSON?: () => unknown\n}\n\nexport function detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n","import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  let accumulatedCharacterCount = JSON.stringify(sanitizedData)?.length || 0\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value: object) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted,\n      }\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n","import { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport { display } from '../display'\n\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE\n\nexport const enum CustomerDataType {\n  FeatureFlag = 'feature flag evaluation',\n  User = 'user',\n  GlobalContext = 'global context',\n  LoggerContext = 'logger context',\n}\n\nexport function warnIfCustomerDataLimitReached(bytesCount: number, customerDataType: CustomerDataType): boolean {\n  if (bytesCount > CUSTOMER_DATA_BYTES_LIMIT) {\n    display.warn(\n      `The ${customerDataType} data exceeds the recommended ${\n        CUSTOMER_DATA_BYTES_LIMIT / ONE_KIBI_BYTE\n      }KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-3kib-warning`\n    )\n    return true\n  }\n  return false\n}\n","import { computeBytesCount } from '../utils/byteUtils'\nimport { throttle } from '../utils/functionUtils'\nimport { deepClone } from '../mergeInto'\nimport { getType } from '../utils/typeUtils'\nimport { jsonStringify } from './jsonStringify'\nimport { sanitize } from './sanitize'\nimport { warnIfCustomerDataLimitReached } from './heavyCustomerDataWarning'\nimport type { CustomerDataType } from './heavyCustomerDataWarning'\nimport type { Context, ContextValue } from './context'\n\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type ContextManager = ReturnType<typeof createContextManager>\n\nexport function createContextManager(customerDataType: CustomerDataType, computeBytesCountImpl = computeBytesCount) {\n  let context: Context = {}\n  let bytesCountCache: number\n  let alreadyWarned = false\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCountImpl(jsonStringify(context)!)\n    if (!alreadyWarned) {\n      alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, customerDataType)\n    }\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  const contextManager = {\n    getBytesCount: () => bytesCountCache,\n    /** @deprecated use getContext instead */\n    get: () => context,\n\n    /** @deprecated use setContextProperty instead */\n    add: (key: string, value: any) => {\n      context[key] = value as ContextValue\n      computeBytesCountThrottled(context)\n    },\n\n    /** @deprecated renamed to removeContextProperty */\n    remove: (key: string) => {\n      delete context[key]\n      computeBytesCountThrottled(context)\n    },\n\n    /** @deprecated use setContext instead */\n    set: (newContext: object) => {\n      context = newContext as Context\n      computeBytesCountThrottled(context)\n    },\n\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      if (getType(newContext) === 'object') {\n        context = sanitize(newContext)\n        computeBytesCountThrottled(context)\n      } else {\n        contextManager.clearContext()\n      }\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = sanitize(property)\n      computeBytesCountThrottled(context)\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n      computeBytesCountThrottled(context)\n    },\n\n    clearContext: () => {\n      context = {}\n      bytesCountCache = 0\n    },\n  }\n  return contextManager\n}\n","const BUFFER_LIMIT = 500\n\nexport class BoundedBuffer {\n  private buffer: Array<() => void> = []\n\n  add(callback: () => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  drain() {\n    this.buffer.forEach((callback) => callback())\n    this.buffer.length = 0\n  }\n}\n","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n","import { isNumber, round } from './numberUtils'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\nexport function findCommaSeparatedValue(rawString: string, name: string) {\n  const regex = new RegExp(`(?:^|;)\\\\s*${name}\\\\s*=\\\\s*([^;]+)`)\n  const matches = regex.exec(rawString)\n  return matches ? matches[1] : undefined\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) {\n    return candidate\n  }\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n","import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  domain?: string\n}\n\nconst cookieMap = new Map<string, string>()\n\nexport function setCookie(name: string, value: string, _expireDelay: number, _options?: CookieOptions) {\n  cookieMap.set(name, value)\n}\n\nexport function getCookie(name: string) {\n  return cookieMap.get(name)\n}\n\nexport function deleteCookie(name: string, _options?: CookieOptions) {\n  cookieMap.delete(name)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","import { getCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","import { endsWith } from '../tools/utils/polyfills'\nimport { getGlobalObject } from '../tools/getGlobalObject'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E) {\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event }))\n    },\n  }\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","import { startsWith } from '../../tools/utils/polyfills'\nimport type { StackTrace, StackFrame } from './types'\n\nconst UNKNOWN_FUNCTION = '?'\n\n/**\n * Computes a stack trace for an exception.\n */\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n","import type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\nimport { noop } from '../../tools/utils/functionUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { ErrorSource, ErrorHandling, RawError, RawErrorCause, ErrorWithCause, NonErrorPrefix } from './error.types'\n\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error'\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: NonErrorPrefix\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  const isErrorInstance = originalError instanceof Error\n\n  const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError)\n  const stack = hasUsableStack(isErrorInstance, stackTrace)\n    ? toStackTraceString(stackTrace)\n    : NO_ERROR_STACK_PRESENT_MESSAGE\n  const causes = isErrorInstance ? flattenErrorCauses(originalError as ErrorWithCause, source) : undefined\n  const type = stackTrace?.name\n  const fingerprint = tryToGetFingerprint(originalError)\n\n  return {\n    startClocks,\n    source,\n    handling,\n    handlingStack,\n    originalError,\n    type,\n    message,\n    stack,\n    causes,\n    fingerprint,\n  }\n}\n\nfunction computeMessage(\n  stackTrace: StackTrace | undefined,\n  isErrorInstance: boolean,\n  nonErrorPrefix: NonErrorPrefix,\n  originalError: unknown\n) {\n  // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n  // TODO rework tracekit integration to avoid scattering error building logic\n  return stackTrace?.message && stackTrace?.name\n    ? stackTrace.message\n    : !isErrorInstance\n    ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))!}`\n    : 'Empty message'\n}\n\nfunction hasUsableStack(isErrorInstance: boolean, stackTrace?: StackTrace): stackTrace is StackTrace {\n  if (stackTrace === undefined) {\n    return false\n  }\n  if (isErrorInstance) {\n    return true\n  }\n  // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n  // TODO rework tracekit integration to avoid generating those unusable stack\n  return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined)\n}\n\nexport function tryToGetFingerprint(originalError: unknown) {\n  return originalError instanceof Error && 'dd_fingerprint' in originalError\n    ? String(originalError.dd_fingerprint)\n    : undefined\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\n// eslint-disable-next-line no-restricted-syntax\nexport enum ExperimentalFeature {\n  PAGEHIDE = 'pagehide',\n  FEATURE_FLAGS = 'feature_flags',\n  RESOURCE_PAGE_STATES = 'resource_page_states',\n  PAGE_STATES = 'page_states',\n  COLLECT_FLUSH_REASON = 'collect_flush_reason',\n  NO_RESOURCE_DURATION_FROZEN_STATE = 'no_resource_duration_frozen_state',\n  SCROLLMAP = 'scrollmap',\n  DISABLE_REPLAY_INLINE_CSS = 'disable_replay_inline_css',\n}\n\nconst enabledExperimentalFeatures: Set<ExperimentalFeature> = new Set()\n\nexport function addExperimentalFeatures(enabledFeatures: ExperimentalFeature[]): void {\n  enabledFeatures.forEach((flag) => {\n    enabledExperimentalFeatures.add(flag)\n  })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: ExperimentalFeature): boolean {\n  return enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures.clear()\n}\n\nexport function getExperimentalFeatures(): Set<ExperimentalFeature> {\n  return enabledExperimentalFeatures\n}\n","import type { Context } from '../../tools/serialisation/context'\nimport { display } from '../../tools/display'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { User } from './user.types'\n\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser: Context): Context {\n  // We shallow clone only to prevent mutation of user data.\n  const user = assign({}, newUser)\n  const keys = ['id', 'name', 'email']\n  keys.forEach((key) => {\n    if (key in user) {\n      user[key] = String(user[key])\n    }\n  })\n  return user\n}\n\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser: User): boolean {\n  const isValid = getType(newUser) === 'object'\n  if (!isValid) {\n    display.error('Unsupported user:', newUser)\n  }\n  return isValid\n}\n","import { assign } from './polyfills'\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: () => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  const globalObservable = new Observable<T>(() => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n\n  return globalObservable\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils/timeUtils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import type { CookieOptions } from '../../../browser/cookie'\nimport type { SessionState } from '../sessionState'\n\nexport const SESSION_STORE_KEY = '_dd_s'\n\nexport type SessionStoreStrategyType = { type: 'Cookie'; cookieOptions: CookieOptions } | { type: 'LocalStorage' }\n\nexport interface SessionStoreStrategy {\n  persistSession: (session: SessionState) => void\n  retrieveSession: () => SessionState\n  clearSession: () => void\n}\n","import { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { objectEntries } from '../../tools/utils/polyfills'\nimport { dateNow } from '../../tools/utils/timeUtils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\nexport function isSessionInExpiredState(session: SessionState) {\n  return isEmptyObject(session)\n}\n\nexport function expandSessionState(session: SessionState) {\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n}\n\nexport function toSessionString(session: SessionState) {\n  return objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function toSessionState(sessionString: string | undefined | null) {\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined | null): sessionString is string {\n  return (\n    !!sessionString &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n","import { getCookie } from '../../browser/cookie'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy: SessionStoreStrategy) {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  if (!sessionString) {\n    const oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME)\n    const oldRumType = getCookie(OLD_RUM_COOKIE_NAME)\n    const oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME)\n    const session: SessionState = {}\n\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n\n    if (!isSessionInExpiredState(session)) {\n      expandSessionState(session)\n      cookieStoreStrategy.persistSession(session)\n    }\n  }\n}\n","import type { CookieOptions } from '../../../browser/cookie'\nimport { getCurrentSite, areCookiesAuthorized, deleteCookie, getCookie, setCookie } from '../../../browser/cookie'\nimport type { InitConfiguration } from '../../configuration'\nimport { tryOldCookiesMigration } from '../oldCookiesMigration'\nimport { SESSION_EXPIRATION_DELAY } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nexport function selectCookieStrategy(initConfiguration: InitConfiguration): SessionStoreStrategyType | undefined {\n  const cookieOptions = buildCookieOptions(initConfiguration)\n  return areCookiesAuthorized(cookieOptions) ? { type: 'Cookie', cookieOptions } : undefined\n}\n\nexport function initCookieStrategy(cookieOptions: CookieOptions): SessionStoreStrategy {\n  const cookieStore = {\n    persistSession: persistSessionCookie(cookieOptions),\n    retrieveSession: retrieveSessionCookie,\n    clearSession: deleteSessionCookie(cookieOptions),\n  }\n\n  tryOldCookiesMigration(cookieStore)\n\n  return cookieStore\n}\n\nfunction persistSessionCookie(options: CookieOptions) {\n  return (session: SessionState) => {\n    setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n  }\n}\n\nfunction retrieveSessionCookie(): SessionState {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction deleteSessionCookie(options: CookieOptions) {\n  return () => {\n    deleteCookie(SESSION_STORE_KEY, options)\n  }\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  cookieOptions.secure = !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n","import { generateUUID } from '../../../tools/utils/stringUtils'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_'\n\nexport function selectLocalStorageStrategy(): SessionStoreStrategyType | undefined {\n  try {\n    const id = generateUUID()\n    const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`\n    localStorage.setItem(testKey, id)\n    const retrievedId = localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n    return id === retrievedId ? { type: 'LocalStorage' } : undefined\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function initLocalStorageStrategy(): SessionStoreStrategy {\n  return {\n    persistSession: persistInLocalStorage,\n    retrieveSession: retrieveSessionFromLocalStorage,\n    clearSession: clearSessionFromLocalStorage,\n  }\n}\n\nfunction persistInLocalStorage(sessionState: SessionState) {\n  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState))\n}\n\nfunction retrieveSessionFromLocalStorage(): SessionState {\n  const sessionString = localStorage.getItem(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction clearSessionFromLocalStorage() {\n  localStorage.removeItem(SESSION_STORE_KEY)\n}\n","import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { isChromium } from '../../tools/utils/browserDetection'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { retrieveSession, persistSession, clearSession } = sessionStoreStrategy\n  const lockEnabled = isLockEnabled()\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (lockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (lockEnabled) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = generateUUID()\n    currentSession.lock = currentLock\n    persistSession(currentSession)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (lockEnabled) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      clearSession()\n    } else {\n      expandSessionState(processedSession)\n      persistSession(processedSession)\n    }\n  }\n  if (lockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      persistSession(currentSession)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next(sessionStoreStrategy)\n}\n\n/**\n * Lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n */\nexport const isLockEnabled = () => isChromium()\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n","export function isIE() {\n  return Boolean((document as any).documentMode)\n}\n\nexport function isChromium() {\n  return !!(window as any).chrome || /HeadlessChrome/.test(window.navigator.userAgent)\n}\n","import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from '../configuration'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n  stop: () => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy()\n  }\n  return sessionStoreStrategyType\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === 'Cookie'\n      ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy()\n  const { clearSession, retrieveSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          const synchronizedSession = synchronizeSession(sessionState)\n          isTracked = expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isTracked && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (!isActiveSession(sessionState) ? {} : undefined),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (!isActiveSession(sessionState)) {\n      sessionState = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(sessionState: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n      (sessionState.expire === undefined || dateNow() < Number(sessionState.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: throttle(expandOrRenewSession, STORAGE_POLL_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    expire: () => {\n      clearSession()\n      synchronizeSession({})\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n","import { jsonStringify } from '../serialisation/jsonStringify'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, getLocationOrigin()).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function getOrigin(url: string) {\n  return getLinkElementOrigin(buildUrl(url))\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function getSearch(url: string) {\n  return buildUrl(url).search\n}\n\nexport function getHash(url: string) {\n  return buildUrl(url).hash\n}\n\nexport function buildUrl(url: string, base?: string) {\n  const supportedURL = getSupportedUrl()\n  if (supportedURL) {\n    try {\n      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url)\n    } catch (error) {\n      throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })!}`)\n    }\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nconst originalURL = URL\nlet isURLSupported: boolean | undefined\nfunction getSupportedUrl(): typeof URL | undefined {\n  if (isURLSupported === undefined) {\n    try {\n      const url = new originalURL('http://test/path')\n      isURLSupported = url.href === 'http://test/path'\n    } catch {\n      isURLSupported = false\n    }\n  }\n  return isURLSupported ? originalURL : undefined\n}\n\nexport function getLocationOrigin() {\n  return getLinkElementOrigin(window.location)\n}\n\n/**\n * Fallback\n * On IE HTMLAnchorElement origin is not supported: https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin\n * On Firefox window.location.origin is \"null\" for file: URIs: https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n */\nexport function getLinkElementOrigin(element: Location | HTMLAnchorElement | URL) {\n  if (element.origin && element.origin !== 'null') {\n    return element.origin\n  }\n  const sanitizedHost = element.host.replace(/(:80|:443)$/, '')\n  return `${element.protocol}//${sanitizedHost}`\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu'\nexport const INTAKE_SITE_AP1 = 'ap1.datadoghq.com'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n","import type { RetryInfo, FlushReason } from '../../transport'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill'\nimport { ExperimentalFeature, isExperimentalFeatureEnabled } from '../../tools/experimentalFeatures'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_AP1, INTAKE_SITE_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport const ENDPOINTS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'session-replay',\n} as const\n\nconst INTAKE_TRACKS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'replay',\n}\n\nexport type EndpointType = keyof typeof ENDPOINTS\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType,\n  configurationTags: string[]\n) {\n  const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, endpointType)\n\n  return {\n    build(api: 'xhr' | 'fetch' | 'beacon', flushReason?: FlushReason, retry?: RetryInfo) {\n      const parameters = buildEndpointParameters(\n        initConfiguration,\n        endpointType,\n        configurationTags,\n        api,\n        flushReason,\n        retry\n      )\n      return buildUrlWithParameters(parameters)\n    },\n    urlPrefix: buildUrlWithParameters(''),\n    endpointType,\n  }\n}\n\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType\n): (parameters: string) => string {\n  const path = `/api/v2/${INTAKE_TRACKS[endpointType]}`\n\n  const { proxy, proxyUrl } = initConfiguration\n  if (proxy) {\n    const normalizedProxyUrl = normalizeUrl(proxy)\n    return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`\n  }\n\n  const host = buildEndpointHost(initConfiguration, endpointType)\n\n  if (proxy === undefined && proxyUrl) {\n    // TODO: remove this in a future major.\n    const normalizedProxyUrl = normalizeUrl(proxyUrl)\n    return (parameters) =>\n      `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`https://${host}${path}?${parameters}`)}`\n  }\n\n  return (parameters) => `https://${host}${path}?${parameters}`\n}\n\nfunction buildEndpointHost(initConfiguration: InitConfiguration, endpointType: EndpointType) {\n  const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration\n\n  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n    return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`\n  }\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  const subdomain = site !== INTAKE_SITE_AP1 ? `${ENDPOINTS[endpointType]}.` : ''\n  return `${subdomain}browser-intake-${domainParts.join('-')}.${extension!}`\n}\n\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(\n  { clientToken, internalAnalyticsSubdomain }: InitConfiguration,\n  endpointType: EndpointType,\n  configurationTags: string[],\n  api: 'xhr' | 'fetch' | 'beacon',\n  flushReason: FlushReason | undefined,\n  retry: RetryInfo | undefined\n) {\n  const tags = [`sdk_version:${__BUILD_ENV__SDK_VERSION__}`, `api:${api}`].concat(configurationTags)\n  if (flushReason && isExperimentalFeatureEnabled(ExperimentalFeature.COLLECT_FLUSH_REASON)) {\n    tags.push(`flush_reason:${flushReason}`)\n  }\n  if (retry) {\n    tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`)\n  }\n  const parameters = [\n    'ddsource=browser',\n    `ddtags=${encodeURIComponent(tags.join(','))}`,\n    `dd-api-key=${clientToken}`,\n    `dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}`,\n    'dd-evp-origin=browser',\n    `dd-request-id=${generateUUID()}`,\n  ]\n\n  if (endpointType === 'rum') {\n    parameters.push(`batch_time=${timeStampNow()}`)\n  }\n  if (internalAnalyticsSubdomain) {\n    parameters.reverse()\n  }\n\n  return parameters.join('&')\n}\n","import { display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(`${key} value doesn't meet tag requirements and will be sanitized`)\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { objectValues, assign } from '../../tools/utils/polyfills'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeUrlPrefixes = objectValues(endpointBuilders).map((builder) => builder.urlPrefix)\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeUrlPrefixes.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site: initConfiguration.site || INTAKE_SITE_US1,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'sessionReplay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeUrlPrefixes: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeUrlPrefixes.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.urlPrefix))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n","import { catchUserErrors } from '../../tools/catchUserErrors'\nimport { display } from '../../tools/display'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport { ExperimentalFeature, addExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Duration } from '../../tools/utils/timeUtils'\nimport { ONE_SECOND } from '../../tools/utils/timeUtils'\nimport { isPercentage } from '../../tools/utils/numberUtils'\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { objectHasValue } from '../../tools/utils/objectUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectSessionStoreStrategyType } from '../session/sessionStore'\nimport type { SessionStoreStrategyType } from '../session/storeStrategies/sessionStoreStrategy'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = (typeof DefaultPrivacyLevel)[keyof typeof DefaultPrivacyLevel]\n\nexport interface InitConfiguration {\n  // global options\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  /**\n   * @deprecated use sessionSampleRate instead\n   */\n  sampleRate?: number | undefined\n  sessionSampleRate?: number | undefined\n  telemetrySampleRate?: number | undefined\n  silentMultipleInit?: boolean | undefined\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n\n  // transport options\n  proxy?: string | undefined\n  /**\n   * @deprecated use `proxy` instead\n   */\n  proxyUrl?: string | undefined\n  site?: string | undefined\n\n  // tag and context options\n  service?: string | undefined\n  env?: string | undefined\n  version?: string | undefined\n\n  // cookie options\n  useCrossSiteSessionCookie?: boolean | undefined\n  useSecureSessionCookie?: boolean | undefined\n  trackSessionAcrossSubdomains?: boolean | undefined\n\n  // alternate storage option\n  allowFallbackToLocalStorage?: boolean | undefined\n\n  // internal options\n  enableExperimentalFeatures?: string[] | undefined\n  replica?: ReplicaUserConfiguration | undefined\n  datacenter?: string\n  internalAnalyticsSubdomain?: string\n\n  telemetryConfigurationSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  sessionStoreStrategyType: SessionStoreStrategyType | undefined\n  sessionSampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: Duration\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  const sessionSampleRate = initConfiguration.sessionSampleRate ?? initConfiguration.sampleRate\n  if (sessionSampleRate !== undefined && !isPercentage(sessionSampleRate)) {\n    display.error('Session Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // Set the experimental feature flags as early as possible, so we can use them in most places\n  if (Array.isArray(initConfiguration.enableExperimentalFeatures)) {\n    addExperimentalFeatures(\n      initConfiguration.enableExperimentalFeatures.filter((flag): flag is ExperimentalFeature =>\n        objectHasValue(ExperimentalFeature, flag)\n      )\n    )\n  }\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n      sessionSampleRate: sessionSampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      service: initConfiguration.service,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: (30 * ONE_SECOND) as Duration,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function serializeConfiguration(initConfiguration: InitConfiguration): Partial<RawTelemetryConfiguration> {\n  const proxy = initConfiguration.proxy ?? initConfiguration.proxyUrl\n  return {\n    session_sample_rate: initConfiguration.sessionSampleRate ?? initConfiguration.sampleRate,\n    telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n    use_before_send: !!initConfiguration.beforeSend,\n    use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,\n    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n    use_proxy: proxy !== undefined ? !!proxy : undefined,\n    silent_multiple_init: initConfiguration.silentMultipleInit,\n    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n    track_resources: initConfiguration.trackResources,\n    track_long_task: initConfiguration.trackLongTasks,\n    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n  }\n}\n","import { startsWith } from './utils/polyfills'\nimport { display } from './display'\nimport { getType } from './utils/typeUtils'\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\n\nexport function isMatchOption(item: unknown): item is MatchOption {\n  const itemType = getType(item)\n  return itemType === 'string' || itemType === 'function' || item instanceof RegExp\n}\n\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list: MatchOption[], value: string, useStartsWith = false): boolean {\n  return list.some((item) => {\n    try {\n      if (typeof item === 'function') {\n        return item(value)\n      } else if (item instanceof RegExp) {\n        return item.test(value)\n      } else if (typeof item === 'string') {\n        return useStartsWith ? startsWith(value, item) : item === value\n      }\n    } catch (e) {\n      display.error(e)\n    }\n    return false\n  })\n}\n","import {\n  objectEntries,\n  shallowClone,\n  performDraw,\n  isNumber,\n  assign,\n  find,\n  getType,\n  isMatchOption,\n  matchList,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchResolveContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { PropagatorType, TracingOption } from './tracer.types'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchResolveContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\nexport function isTracingOption(item: unknown): item is TracingOption {\n  const expectedItem = item as TracingOption\n  return (\n    getType(expectedItem) === 'object' &&\n    isMatchOption(expectedItem.match) &&\n    Array.isArray(expectedItem.propagatorTypes)\n  )\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchResolveContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(configuration: RumConfiguration, sessionManager: RumSessionManager): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        if (context.input instanceof Request && !context.init?.headers) {\n          context.input = new Request(context.input)\n          Object.keys(tracingHeaders).forEach((key) => {\n            ;(context.input as Request).headers.append(key, tracingHeaders[key])\n          })\n        } else {\n          context.init = shallowClone(context.init)\n          const headers: Array<[string, string]> = []\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach((value, key) => {\n              headers.push([key, value])\n            })\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach((header) => {\n              headers.push(header)\n            })\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach((key) => {\n              headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n            })\n          }\n          context.init.headers = headers.concat(objectEntries(tracingHeaders))\n        }\n      }),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        Object.keys(tracingHeaders).forEach((name) => {\n          xhr.setRequestHeader(name, tracingHeaders[name])\n        })\n      }),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  if (!isTracingSupported() || !sessionManager.findTrackedSession()) {\n    return\n  }\n\n  const tracingOption = find(configuration.allowedTracingUrls, (tracingOption: TracingOption) =>\n    matchList([tracingOption.match], context.url!, true)\n  )\n  if (!tracingOption) {\n    return\n  }\n\n  context.traceId = new TraceIdentifier()\n  context.spanId = new TraceIdentifier()\n  context.traceSampled = !isNumber(configuration.traceSampleRate) || performDraw(configuration.traceSampleRate)\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes))\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined\n}\n\nfunction getCrypto() {\n  return window.crypto || (window as any).msCrypto\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(\n  traceId: TraceIdentifier,\n  spanId: TraceIdentifier,\n  traceSampled: boolean,\n  propagatorTypes: PropagatorType[]\n): TracingHeaders {\n  const tracingHeaders: TracingHeaders = {}\n\n  propagatorTypes.forEach((propagatorType) => {\n    switch (propagatorType) {\n      case 'datadog': {\n        assign(tracingHeaders, {\n          'x-datadog-origin': 'rum',\n          'x-datadog-parent-id': spanId.toDecimalString(),\n          'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n          'x-datadog-trace-id': traceId.toDecimalString(),\n        })\n        break\n      }\n      // https://www.w3.org/TR/trace-context/\n      case 'tracecontext': {\n        assign(tracingHeaders, {\n          traceparent: `00-0000000000000000${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-0${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      // https://github.com/openzipkin/b3-propagation\n      case 'b3': {\n        assign(tracingHeaders, {\n          b3: `${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      case 'b3multi': {\n        assign(tracingHeaders, {\n          'X-B3-TraceId': traceId.toPaddedHexadecimalString(),\n          'X-B3-SpanId': spanId.toPaddedHexadecimalString(),\n          'X-B3-Sampled': traceSampled ? '1' : '0',\n        })\n        break\n      }\n    }\n  })\n  return tracingHeaders\n}\n\n/* eslint-disable no-bitwise */\nexport class TraceIdentifier {\n  private buffer: Uint8Array = new Uint8Array(8)\n\n  constructor() {\n    getCrypto().getRandomValues(this.buffer)\n    this.buffer[0] = this.buffer[0] & 0x7f // force 63-bit\n  }\n\n  toString(radix: number) {\n    let high = this.readInt32(0)\n    let low = this.readInt32(4)\n    let str = ''\n\n    do {\n      const mod = (high % radix) * 4294967296 + low\n      high = Math.floor(high / radix)\n      low = Math.floor(mod / radix)\n      str = (mod % radix).toString(radix) + str\n    } while (high || low)\n\n    return str\n  }\n\n  /**\n   * Format used everywhere except the trace intake\n   */\n  toDecimalString() {\n    return this.toString(10)\n  }\n\n  /**\n   * Format used by OTel headers\n   */\n  toPaddedHexadecimalString() {\n    const traceId = this.toString(16)\n    return Array(17 - traceId.length).join('0') + traceId\n  }\n\n  private readInt32(offset: number) {\n    return (\n      this.buffer[offset] * 16777216 +\n      (this.buffer[offset + 1] << 16) +\n      (this.buffer[offset + 2] << 8) +\n      this.buffer[offset + 3]\n    )\n  }\n}\n/* eslint-enable no-bitwise */\n","import type { Configuration, InitConfiguration, MatchOption, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  getType,\n  arrayFrom,\n  getOrigin,\n  isMatchOption,\n  serializeConfiguration,\n  assign,\n  DefaultPrivacyLevel,\n  display,\n  isPercentage,\n  objectHasValue,\n  validateAndBuildConfiguration,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { isTracingOption } from './tracing/tracer'\nimport type { PropagatorType, TracingOption } from './tracing/tracer.types'\n\nexport interface RumInitConfiguration extends InitConfiguration {\n  // global options\n  applicationId: string\n  beforeSend?: ((event: RumEvent, context: RumEventDomainContext) => void | boolean) | undefined\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  premiumSampleRate?: number | undefined\n  excludedActivityUrls?: MatchOption[] | undefined\n  workerUrl?: string\n\n  // tracing options\n  /**\n   * @deprecated use allowedTracingUrls instead\n   */\n  allowedTracingOrigins?: MatchOption[] | undefined\n  allowedTracingUrls?: Array<MatchOption | TracingOption> | undefined\n  /**\n   * @deprecated use traceSampleRate instead\n   */\n  tracingSampleRate?: number | undefined\n  traceSampleRate?: number | undefined\n\n  // replay options\n  defaultPrivacyLevel?: DefaultPrivacyLevel | undefined\n  subdomain?: string\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  replaySampleRate?: number | undefined\n  sessionReplaySampleRate?: number | undefined\n\n  // action options\n  /**\n   * @deprecated use trackUserInteractions instead\n   */\n  trackInteractions?: boolean | undefined\n  trackUserInteractions?: boolean | undefined\n  trackFrustrations?: boolean | undefined\n  actionNameAttribute?: string | undefined\n\n  // view options\n  trackViewsManually?: boolean | undefined\n\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n}\n\nexport type HybridInitConfiguration = Omit<RumInitConfiguration, 'applicationId' | 'clientToken'>\n\nexport interface RumConfiguration extends Configuration {\n  // Built from init configuration\n  actionNameAttribute: string | undefined\n  traceSampleRate: number | undefined\n  allowedTracingUrls: TracingOption[]\n  excludedActivityUrls: MatchOption[]\n  workerUrl: string | undefined\n  applicationId: string\n  defaultPrivacyLevel: DefaultPrivacyLevel\n  oldPlansBehavior: boolean\n  sessionReplaySampleRate: number\n  trackUserInteractions: boolean\n  trackFrustrations: boolean\n  trackViewsManually: boolean\n  trackResources: boolean | undefined\n  trackLongTasks: boolean | undefined\n  version?: string\n  subdomain?: string\n  customerDataTelemetrySampleRate: number\n}\n\nexport function validateAndBuildRumConfiguration(\n  initConfiguration: RumInitConfiguration\n): RumConfiguration | undefined {\n  if (!initConfiguration.applicationId) {\n    display.error('Application ID is not configured, no RUM data will be collected.')\n    return\n  }\n\n  if (\n    initConfiguration.sessionReplaySampleRate !== undefined &&\n    !isPercentage(initConfiguration.sessionReplaySampleRate)\n  ) {\n    display.error('Session Replay Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // TODO remove fallback in next major\n  let premiumSampleRate = initConfiguration.premiumSampleRate ?? initConfiguration.replaySampleRate\n  if (premiumSampleRate !== undefined && initConfiguration.sessionReplaySampleRate !== undefined) {\n    display.warn('Ignoring Premium Sample Rate because Session Replay Sample Rate is set')\n    premiumSampleRate = undefined\n  }\n\n  if (premiumSampleRate !== undefined && !isPercentage(premiumSampleRate)) {\n    display.error('Premium Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  const traceSampleRate = initConfiguration.traceSampleRate ?? initConfiguration.tracingSampleRate\n  if (traceSampleRate !== undefined && !isPercentage(traceSampleRate)) {\n    display.error('Trace Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n    display.error('Excluded Activity Urls should be an array')\n    return\n  }\n\n  const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration)\n  if (!allowedTracingUrls) {\n    return\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n  if (!baseConfiguration) {\n    return\n  }\n\n  const trackUserInteractions = !!(initConfiguration.trackUserInteractions ?? initConfiguration.trackInteractions)\n  const trackFrustrations = !!initConfiguration.trackFrustrations\n\n  return assign(\n    {\n      applicationId: initConfiguration.applicationId,\n      version: initConfiguration.version,\n      actionNameAttribute: initConfiguration.actionNameAttribute,\n      sessionReplaySampleRate: initConfiguration.sessionReplaySampleRate ?? premiumSampleRate ?? 100,\n      oldPlansBehavior: initConfiguration.sessionReplaySampleRate === undefined,\n      traceSampleRate,\n      allowedTracingUrls,\n      excludedActivityUrls: initConfiguration.excludedActivityUrls ?? [],\n      workerUrl: initConfiguration.workerUrl,\n      trackUserInteractions: trackUserInteractions || trackFrustrations,\n      trackFrustrations,\n      trackViewsManually: !!initConfiguration.trackViewsManually,\n      trackResources: initConfiguration.trackResources,\n      trackLongTasks: initConfiguration.trackLongTasks,\n      subdomain: initConfiguration.subdomain,\n      defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n        ? initConfiguration.defaultPrivacyLevel\n        : DefaultPrivacyLevel.MASK_USER_INPUT,\n      customerDataTelemetrySampleRate: 1,\n    },\n    baseConfiguration\n  )\n}\n\n/**\n * Handles allowedTracingUrls and processes legacy allowedTracingOrigins\n */\nfunction validateAndBuildTracingOptions(initConfiguration: RumInitConfiguration): TracingOption[] | undefined {\n  // Advise about parameters precedence.\n  if (initConfiguration.allowedTracingUrls !== undefined && initConfiguration.allowedTracingOrigins !== undefined) {\n    display.warn(\n      'Both allowedTracingUrls and allowedTracingOrigins (deprecated) have been defined. The parameter allowedTracingUrls will override allowedTracingOrigins.'\n    )\n  }\n  // Handle allowedTracingUrls first\n  if (initConfiguration.allowedTracingUrls !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {\n      display.error('Allowed Tracing URLs should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service needs to be configured when tracing is enabled')\n      return\n    }\n    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties\n    const tracingOptions: TracingOption[] = []\n    initConfiguration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        tracingOptions.push({ match: option, propagatorTypes: ['datadog'] })\n      } else if (isTracingOption(option)) {\n        tracingOptions.push(option)\n      } else {\n        display.warn(\n          'Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter',\n          option\n        )\n      }\n    })\n\n    return tracingOptions\n  }\n\n  // Handle conversion of allowedTracingOrigins to allowedTracingUrls\n  if (initConfiguration.allowedTracingOrigins !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingOrigins)) {\n      display.error('Allowed Tracing Origins should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingOrigins.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service needs to be configured when tracing is enabled')\n      return\n    }\n\n    const tracingOptions: TracingOption[] = []\n    initConfiguration.allowedTracingOrigins.forEach((legacyMatchOption) => {\n      const tracingOption = convertLegacyMatchOptionToTracingOption(legacyMatchOption)\n      if (tracingOption) {\n        tracingOptions.push(tracingOption)\n      }\n    })\n    return tracingOptions\n  }\n\n  return []\n}\n\n/**\n * Converts parameters from the deprecated allowedTracingOrigins\n * to allowedTracingUrls. Handles the change from origin to full URLs.\n */\nfunction convertLegacyMatchOptionToTracingOption(item: MatchOption): TracingOption | undefined {\n  let match: MatchOption | undefined\n  if (typeof item === 'string') {\n    match = item\n  } else if (item instanceof RegExp) {\n    match = (url) => item.test(getOrigin(url))\n  } else if (typeof item === 'function') {\n    match = (url) => item(getOrigin(url))\n  }\n\n  if (match === undefined) {\n    display.warn('Allowed Tracing Origins parameters should be a string, RegExp or function. Ignoring parameter', item)\n    return undefined\n  }\n\n  return { match, propagatorTypes: ['datadog'] }\n}\n\n/**\n * Combines the selected tracing propagators from the different options in allowedTracingUrls,\n * and assumes 'datadog' has been selected when using allowedTracingOrigins\n */\nfunction getSelectedTracingPropagators(configuration: RumInitConfiguration): PropagatorType[] {\n  const usedTracingPropagators = new Set<PropagatorType>()\n\n  if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {\n    configuration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        usedTracingPropagators.add('datadog')\n      } else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {\n        // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)\n        option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType))\n      }\n    })\n  }\n\n  if (Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0) {\n    usedTracingPropagators.add('datadog')\n  }\n\n  return arrayFrom(usedTracingPropagators)\n}\n\nexport function serializeRumConfiguration(configuration: RumInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      premium_sample_rate: configuration.premiumSampleRate,\n      replay_sample_rate: configuration.replaySampleRate,\n      session_replay_sample_rate: configuration.sessionReplaySampleRate,\n      trace_sample_rate: configuration.traceSampleRate ?? configuration.tracingSampleRate,\n      action_name_attribute: configuration.actionNameAttribute,\n      use_allowed_tracing_origins:\n        Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,\n      use_allowed_tracing_urls:\n        Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,\n      selected_tracing_propagators: getSelectedTracingPropagators(configuration),\n      default_privacy_level: configuration.defaultPrivacyLevel,\n      use_excluded_activity_urls:\n        Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,\n      use_worker_url: !!configuration.workerUrl,\n      track_frustrations: configuration.trackFrustrations,\n      track_views_manually: configuration.trackViewsManually,\n      track_user_interactions: configuration.trackUserInteractions ?? configuration.trackInteractions,\n    },\n    baseSerializedConfiguration\n  )\n}\n","import type { Context, ContextManager, User } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../boot/rumPublicApi'\n\nexport interface CommonContext {\n  user: User\n  context: Context\n  hasReplay: true | undefined\n}\n\nexport function buildCommonContext(\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  recorderApi: RecorderApi\n): CommonContext {\n  return {\n    context: globalContextManager.getContext(),\n    user: userContextManager.getContext(),\n    hasReplay: recorderApi.isRecording() ? true : undefined,\n  }\n}\n","interface BrowserWindow {\n  __ddBrowserSdkExtensionCallback?: (message: unknown) => void\n}\n\ntype ExtensionMessageType = 'logs' | 'record' | 'rum' | 'telemetry'\n\nexport function sendToExtension(type: ExtensionMessageType, payload: unknown) {\n  const callback = (window as BrowserWindow).__ddBrowserSdkExtensionCallback\n  if (callback) {\n    callback({ type, payload })\n  }\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\n","import type { Context } from '../../tools/serialisation/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { toStackTraceString, NO_ERROR_STACK_PRESENT_MESSAGE } from '../error/error'\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Configuration } from '../configuration'\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport { sendToExtension } from '../../tools/sendToExtension'\nimport { startsWith, arrayFrom, includes, assign } from '../../tools/utils/polyfills'\nimport { performDraw } from '../../tools/utils/numberUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { combine } from '../../tools/mergeInto'\nimport { NonErrorPrefix } from '../error/error.types'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type { RawTelemetryConfiguration, RawTelemetryEvent } from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'https://d3uc069fcn7uxw.cloudfront.net',\n  'https://d20xtzwzcl0ceb.cloudfront.net',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n  enabled: boolean\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\nconst telemetryConfiguration: {\n  maxEventsPerPage: number\n  sentEventCount: number\n  telemetryEnabled: boolean\n  telemetryConfigurationEnabled: boolean\n} = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false }\n\nlet onRawTelemetryEventCollected: ((event: RawTelemetryEvent) => void) | undefined\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  telemetryConfiguration.telemetryEnabled =\n    !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate)\n  telemetryConfiguration.telemetryConfigurationEnabled =\n    telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate)\n\n  onRawTelemetryEventCollected = (rawEvent: RawTelemetryEvent) => {\n    if (telemetryConfiguration.telemetryEnabled) {\n      const event = toTelemetryEvent(telemetryService, rawEvent)\n      observable.notify(event)\n      sendToExtension('telemetry', event)\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,\n    sentEventCount: 0,\n  })\n\n  function toTelemetryEvent(telemetryService: TelemetryService, event: RawTelemetryEvent): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: event as any, // https://github.com/microsoft/TypeScript/issues/48457\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    )\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n    enabled: telemetryConfiguration.telemetryEnabled,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: Infinity,\n    sentEventCount: 0,\n  })\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  onRawTelemetryEventCollected = undefined\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown, context?: Context) {\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e),\n      context\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  if (telemetryConfiguration.telemetryConfigurationEnabled) {\n    addTelemetry({\n      type: TelemetryType.configuration,\n      configuration,\n    })\n  }\n}\n\nfunction addTelemetry(event: RawTelemetryEvent) {\n  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {\n    telemetryConfiguration.sentEventCount += 1\n    onRawTelemetryEventCollected(event)\n  }\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n    },\n    message: `${NonErrorPrefix.UNCAUGHT} ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { Configuration } from '../domain/configuration'\nimport type { VisualViewport, VisualViewportEventMap } from './types'\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n  ? DocumentEventMap\n  : T extends HTMLElement\n  ? HTMLElementEventMap\n  : T extends VisualViewport\n  ? VisualViewportEventMap\n  : T extends ShadowRoot\n  ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n    // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n    // through the ShadowRoot like \"change\" or \"input\"\n    GlobalEventHandlersEventMap\n  : T extends XMLHttpRequest\n  ? XMLHttpRequestEventMap\n  : T extends Performance\n  ? PerformanceEventMap\n  : T extends Worker\n  ? WorkerEventMap\n  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: Configuration,\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName]) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  _: Configuration,\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName]) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const wrappedListener = monitor(\n    once\n      ? (event: Event) => {\n          stop()\n          listener(event as EventMapFor<Target>[EventName])\n        }\n      : (listener as (event: Event) => void)\n  )\n\n  const options = passive ? { capture, passive } : capture\n\n  const add = getZoneJsOriginalValue(eventTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, wrappedListener, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, wrappedListener, options))\n  }\n\n  return {\n    stop,\n  }\n}\n","import { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures'\nimport { Observable } from '../tools/observable'\nimport { objectValues, includes } from '../tools/utils/polyfills'\nimport { noop } from '../tools/utils/functionUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageExitObservable(configuration: Configuration): Observable<PageExitEvent> {\n  const observable = new Observable<PageExitEvent>(() => {\n    const pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE)\n    const { stop: stopListeners } = addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE, DOM_EVENT.PAGE_HIDE],\n      (event) => {\n        if (event.type === DOM_EVENT.PAGE_HIDE && pagehideEnabled) {\n          /**\n           * Only event that detect page unload events while being compatible with the back/forward cache (bfcache)\n           */\n          observable.notify({ reason: PageExitReason.PAGEHIDE })\n        } else if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    let stopBeforeUnloadListener = noop\n    if (!pagehideEnabled) {\n      stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, () => {\n        observable.notify({ reason: PageExitReason.UNLOADING })\n      }).stop\n    }\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n\n  return observable\n}\n\nexport function isPageExitReason(reason: string | undefined): reason is PageExitReason {\n  return includes(objectValues(PageExitReason), reason)\n}\n","import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core'\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  const observable: Observable<void> = new Observable<void>(() => {\n    if (!MutationObserver) {\n      return\n    }\n    const observer = new MutationObserver(monitor(() => observable.notify()))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n\n  return observable\n}\n\ntype MutationObserverConstructor = new (callback: MutationCallback) => MutationObserver\n\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: unknown\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow: BrowserWindow = window\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver')\n\n    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as {\n        originalInstance?: { constructor: MutationObserverConstructor }\n      }\n\n      const originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance')\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n","import type { Configuration } from '../domain/configuration'\nimport { DOM_EVENT, addEventListener } from './addEventListener'\n\nexport function runOnReadyState(\n  configuration: Configuration,\n  expectedReadyState: 'complete' | 'interactive',\n  callback: () => void\n) {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n  } else {\n    const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n    addEventListener(configuration, window, eventName, callback, { once: true })\n  }\n}\n","import type { RelativeTime, ServerDuration } from '@datadog/browser-core'\nimport {\n  assign,\n  addTelemetryDebug,\n  elapsed,\n  getPathName,\n  includes,\n  isValidUrl,\n  ResourceType,\n  toServerDuration,\n} from '@datadog/browser-core'\n\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\n\nimport type { PerformanceResourceDetailsElement } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\n\nexport interface PerformanceResourceDetails {\n  redirect?: PerformanceResourceDetailsElement\n  dns?: PerformanceResourceDetailsElement\n  connect?: PerformanceResourceDetailsElement\n  ssl?: PerformanceResourceDetailsElement\n  first_byte: PerformanceResourceDetailsElement\n  download: PerformanceResourceDetailsElement\n}\n\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document'\n\nconst RESOURCE_TYPES: Array<[ResourceType, (initiatorType: string, path: string) => boolean]> = [\n  [ResourceType.DOCUMENT, (initiatorType: string) => FAKE_INITIAL_DOCUMENT === initiatorType],\n  [ResourceType.XHR, (initiatorType: string) => 'xmlhttprequest' === initiatorType],\n  [ResourceType.FETCH, (initiatorType: string) => 'fetch' === initiatorType],\n  [ResourceType.BEACON, (initiatorType: string) => 'beacon' === initiatorType],\n  [ResourceType.CSS, (_: string, path: string) => /\\.css$/i.test(path)],\n  [ResourceType.JS, (_: string, path: string) => /\\.js$/i.test(path)],\n  [\n    ResourceType.IMAGE,\n    (initiatorType: string, path: string) =>\n      includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n  ],\n  [ResourceType.FONT, (_: string, path: string) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n  [\n    ResourceType.MEDIA,\n    (initiatorType: string, path: string) =>\n      includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n  ],\n]\n\nexport function computeResourceKind(timing: RumPerformanceResourceTiming) {\n  const url = timing.name\n  if (!isValidUrl(url)) {\n    addTelemetryDebug(`Failed to construct URL for \"${timing.name}\"`)\n    return ResourceType.OTHER\n  }\n  const path = getPathName(url)\n  for (const [type, isType] of RESOURCE_TYPES) {\n    if (isType(timing.initiatorType, path)) {\n      return type\n    }\n  }\n  return ResourceType.OTHER\n}\n\nfunction areInOrder(...numbers: number[]) {\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isRequestKind(timing: RumPerformanceResourceTiming) {\n  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch'\n}\n\nexport function computePerformanceResourceDuration(entry: RumPerformanceResourceTiming): ServerDuration {\n  const { duration, startTime, responseEnd } = entry\n\n  // Safari duration is always 0 on timings blocked by cross origin policies.\n  if (duration === 0 && startTime < responseEnd) {\n    return toServerDuration(elapsed(startTime, responseEnd))\n  }\n\n  return toServerDuration(duration)\n}\n\nexport function computePerformanceResourceDetails(\n  entry: RumPerformanceResourceTiming\n): PerformanceResourceDetails | undefined {\n  const validEntry = toValidEntry(entry)\n\n  if (!validEntry) {\n    return undefined\n  }\n  const {\n    startTime,\n    fetchStart,\n    redirectStart,\n    redirectEnd,\n    domainLookupStart,\n    domainLookupEnd,\n    connectStart,\n    secureConnectionStart,\n    connectEnd,\n    requestStart,\n    responseStart,\n    responseEnd,\n  } = validEntry\n\n  const details: PerformanceResourceDetails = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart),\n  }\n\n  // Make sure a connection occurred\n  if (connectEnd !== fetchStart) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd)\n\n    // Make sure a secure connection occurred\n    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd)\n    }\n  }\n\n  // Make sure a domain lookup occurred\n  if (domainLookupEnd !== fetchStart) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd)\n  }\n\n  if (hasRedirection(entry)) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd)\n  }\n\n  return details\n}\n\nexport function toValidEntry(entry: RumPerformanceResourceTiming) {\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  if (\n    !areInOrder(\n      entry.startTime,\n      entry.fetchStart,\n      entry.domainLookupStart,\n      entry.domainLookupEnd,\n      entry.connectStart,\n      entry.connectEnd,\n      entry.requestStart,\n      entry.responseStart,\n      entry.responseEnd\n    )\n  ) {\n    return undefined\n  }\n\n  if (!hasRedirection(entry)) {\n    return entry\n  }\n\n  let { redirectStart, redirectEnd } = entry\n  // Firefox doesn't provide redirect timings on cross origin requests.\n  // Provide a default for those.\n  if (redirectStart < entry.startTime) {\n    redirectStart = entry.startTime\n  }\n  if (redirectEnd < entry.startTime) {\n    redirectEnd = entry.fetchStart\n  }\n\n  // Make sure redirect timings are in order\n  if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {\n    return undefined\n  }\n\n  return assign({}, entry, {\n    redirectEnd,\n    redirectStart,\n  })\n}\n\nfunction hasRedirection(entry: RumPerformanceResourceTiming) {\n  // The only time fetchStart is different than startTime is if a redirection occurred.\n  return entry.fetchStart !== entry.startTime\n}\n\nfunction formatTiming(origin: RelativeTime, start: RelativeTime, end: RelativeTime) {\n  return {\n    duration: toServerDuration(elapsed(start, end)),\n    start: toServerDuration(elapsed(origin, start)),\n  }\n}\n\nexport function computeSize(entry: RumPerformanceResourceTiming) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    return entry.decodedBodySize\n  }\n  return undefined\n}\n\nexport function isAllowedRequestUrl(configuration: RumConfiguration, url: string) {\n  return url && !configuration.isIntakeUrl(url)\n}\n","export function isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE\n}\n\nexport function isCommentNode(node: Node): node is Comment {\n  return node.nodeType === Node.COMMENT_NODE\n}\n\nexport function isElementNode(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE\n}\n\nexport function isNodeShadowHost(node: Node): node is Element & { shadowRoot: ShadowRoot } {\n  return isElementNode(node) && Boolean(node.shadowRoot)\n}\n\nexport function isNodeShadowRoot(node: Node): node is ShadowRoot {\n  const shadowRoot = node as ShadowRoot\n  return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host)\n}\n\nexport function getChildNodes(node: Node) {\n  return isNodeShadowHost(node) ? node.shadowRoot.childNodes : node.childNodes\n}\n\n/**\n * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`\n */\nexport function getParentNode(node: Node): Node | null {\n  return isNodeShadowRoot(node) ? node.host : node.parentNode\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n","import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  dateNow,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  getRelativeTime,\n  isNumber,\n  monitor,\n  setTimeout,\n  relativeNow,\n  runOnReadyState,\n  addEventListener,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/rumEventsCollection/resource/resourceUtils'\n\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId'\nimport type { PerformanceEntryRepresentation } from '../domainContext.types'\n\nexport interface RumPerformanceResourceTiming {\n  entryType: 'resource'\n  initiatorType: string\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  traceId?: string\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  entryType: 'longtask'\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): PerformanceEntryRepresentation\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: 'paint'\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n}\n\nexport interface RumPerformanceNavigationTiming {\n  entryType: 'navigation'\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n  responseStart: RelativeTime\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: 'largest-contentful-paint'\n  startTime: RelativeTime\n  size: number\n  element?: Element\n}\n\nexport interface RumFirstInputTiming {\n  entryType: 'first-input'\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  target?: Node\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: 'layout-shift'\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n  sources?: Array<{\n    node?: Node\n  }>\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumLayoutShiftTiming\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: string) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nexport function startPerformanceCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  retrieveInitialDocumentResourceTiming(configuration, (timing) => {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n  })\n\n  if (supportPerformanceObject()) {\n    const performanceEntries = performance.getEntries()\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(() => handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries))\n  }\n\n  if (window.PerformanceObserver) {\n    const handlePerformanceEntryList = monitor((entries: PerformanceObserverEntryList) =>\n      handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries())\n    )\n    const mainEntries = ['resource', 'navigation', 'longtask', 'paint']\n    const experimentalEntries = ['largest-contentful-paint', 'first-input', 'layout-shift']\n\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach((type) => {\n        const observer = new PerformanceObserver(handlePerformanceEntryList)\n        observer.observe({ type, buffered: true })\n      })\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push(...experimentalEntries)\n    }\n\n    const mainObserver = new PerformanceObserver(handlePerformanceEntryList)\n    mainObserver.observe({ entryTypes: mainEntries })\n\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      addEventListener(configuration, performance, 'resourcetimingbufferfull', () => {\n        performance.clearResourceTimings()\n      })\n    }\n  }\n  if (!supportPerformanceTimingEvent('navigation')) {\n    retrieveNavigationTiming(configuration, (timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n  if (!supportPerformanceTimingEvent('first-input')) {\n    retrieveFirstInputTiming(configuration, (timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n}\n\nexport function retrieveInitialDocumentResourceTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceResourceTiming) => void\n) {\n  runOnReadyState(configuration, 'interactive', () => {\n    let timing: RumPerformanceResourceTiming\n\n    const forcedAttributes = {\n      entryType: 'resource' as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n    }\n    if (supportPerformanceTimingEvent('navigation') && performance.getEntriesByType('navigation').length > 0) {\n      const navigationEntry = performance.getEntriesByType('navigation')[0]\n      timing = assign(navigationEntry.toJSON(), forcedAttributes)\n    } else {\n      const relativePerformanceTiming = computeRelativePerformanceTiming()\n      timing = assign(\n        relativePerformanceTiming,\n        {\n          decodedBodySize: 0,\n          duration: relativePerformanceTiming.responseEnd,\n          name: window.location.href,\n          startTime: 0 as RelativeTime,\n        },\n        forcedAttributes\n      )\n    }\n    callback(timing)\n  })\n}\n\nfunction retrieveNavigationTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceNavigationTiming) => void\n) {\n  function sendFakeTiming() {\n    callback(\n      assign(computeRelativePerformanceTiming(), {\n        entryType: 'navigation' as const,\n      })\n    )\n  }\n\n  runOnReadyState(configuration, 'complete', () => {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(sendFakeTiming)\n  })\n}\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(configuration: RumConfiguration, callback: (timing: RumFirstInputTiming) => void) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: RumFirstInputTiming = {\n        entryType: 'first-input',\n        processingStart: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(configuration, timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(configuration: RumConfiguration, timing: RumFirstInputTiming) {\n    addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: RumFirstInputTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n\nexport type RelativePerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nfunction computeRelativePerformanceTiming() {\n  const result: Partial<RelativePerformanceTiming> = {}\n  const timing = performance.timing\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof RelativePerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as RelativePerformanceTiming\n}\n\nfunction handleRumPerformanceEntries(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  entries: Array<PerformanceEntry | RumPerformanceEntry>\n) {\n  const rumPerformanceEntries = entries.filter(\n    (entry) =>\n      entry.entryType === 'resource' ||\n      entry.entryType === 'navigation' ||\n      entry.entryType === 'paint' ||\n      entry.entryType === 'longtask' ||\n      entry.entryType === 'largest-contentful-paint' ||\n      entry.entryType === 'first-input' ||\n      entry.entryType === 'layout-shift'\n  ) as RumPerformanceEntry[]\n\n  const rumAllowedPerformanceEntries = rumPerformanceEntries.filter(\n    (entry) => !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry)\n  )\n\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, rumAllowedPerformanceEntries)\n  }\n}\n\nfunction isIncompleteNavigation(entry: RumPerformanceEntry) {\n  return entry.entryType === 'navigation' && entry.loadEventEnd <= 0\n}\n\nfunction isForbiddenResource(configuration: RumConfiguration, entry: RumPerformanceEntry) {\n  return entry.entryType === 'resource' && !isAllowedRequestUrl(configuration, entry.name)\n}\n","import type { ClocksState } from '../../tools/utils/timeUtils'\n\nexport interface ErrorWithCause extends Error {\n  cause?: Error\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n  fingerprint?: string\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum NonErrorPrefix {\n  UNCAUGHT = 'Uncaught',\n  PROVIDED = 'Provided',\n}\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = (typeof ErrorSource)[keyof typeof ErrorSource]\n","import { Observable, throttle, addEventListener, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\nexport interface ViewportDimension {\n  height: number\n  width: number\n}\n\nlet viewportObservable: Observable<ViewportDimension> | undefined\n\nexport function initViewportObservable(configuration: RumConfiguration) {\n  if (!viewportObservable) {\n    viewportObservable = createViewportObservable(configuration)\n  }\n  return viewportObservable\n}\n\nexport function createViewportObservable(configuration: RumConfiguration) {\n  const observable = new Observable<ViewportDimension>(() => {\n    const { throttled: updateDimension } = throttle(() => {\n      observable.notify(getViewportDimension())\n    }, 200)\n\n    return addEventListener(configuration, window, DOM_EVENT.RESIZE, updateDimension, { capture: true, passive: true })\n      .stop\n  })\n\n  return observable\n}\n\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension(): ViewportDimension {\n  const visual = window.visualViewport\n  if (visual) {\n    return {\n      width: Number(visual.width * visual.scale),\n      height: Number(visual.height * visual.scale),\n    }\n  }\n\n  return {\n    width: Number(window.innerWidth || 0),\n    height: Number(window.innerHeight || 0),\n  }\n}\n","import type { RumConfiguration } from '../configuration'\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable'\n\nlet viewport: { width: number; height: number } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function getDisplayContext(configuration: RumConfiguration) {\n  if (!viewport) {\n    viewport = getViewportDimension()\n    stopListeners = initViewportObservable(configuration).subscribe((viewportDimension) => {\n      viewport = viewportDimension\n    }).unsubscribe\n  }\n\n  return {\n    viewport,\n  }\n}\n\nexport function resetDisplayContext() {\n  if (stopListeners) {\n    stopListeners()\n  }\n  viewport = undefined\n}\n","import { setTimeout } from '../../tools/timer'\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport type { RawError } from '../error/error.types'\nimport { ErrorSource } from '../error/error.types'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core'\n\nexport function getSyntheticsContext() {\n  const testId = getSyntheticsTestId()\n  const resultId = getSyntheticsResultId()\n\n  if (testId && resultId) {\n    return {\n      test_id: testId,\n      result_id: resultId,\n      injected: willSyntheticsInjectRum(),\n    }\n  }\n}\n","import { sanitize, deepClone, getType, objectEntries } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\n\nexport type ModifiableFieldPaths = Record<string, 'string' | 'object'>\n\n/**\n * Current limitation:\n * - field path do not support array, 'a.b.c' only\n */\nexport function limitModification<T extends Context, Result>(\n  object: T,\n  modifiableFieldPaths: ModifiableFieldPaths,\n  modifier: (object: T) => Result\n): Result | undefined {\n  const clone = deepClone(object)\n  const result = modifier(clone)\n  objectEntries(modifiableFieldPaths).forEach(([fieldPath, fieldType]) => {\n    const newValue = get(clone, fieldPath)\n    const newType = getType(newValue)\n    if (newType === fieldType) {\n      set(object, fieldPath, sanitize(newValue))\n    } else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {\n      set(object, fieldPath, {})\n    }\n  })\n  return result\n}\n\nfunction get(object: unknown, path: string) {\n  let current = object\n  for (const field of path.split('.')) {\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    current = current[field]\n  }\n  return current\n}\n\nfunction set(object: unknown, path: string, value: unknown) {\n  let current = object\n  const fields = path.split('.')\n  for (let i = 0; i < fields.length; i += 1) {\n    const field = fields[i]\n    if (!isValidObject(current)) {\n      return\n    }\n    if (i !== fields.length - 1) {\n      current = current[field]\n    } else {\n      current[field] = value\n    }\n  }\n}\n\nfunction isValidObject(object: unknown): object is Record<string, unknown> {\n  return getType(object) === 'object'\n}\n\nfunction isValidObjectContaining(object: unknown, field: string): object is Record<string, unknown> {\n  return isValidObject(object) && Object.prototype.hasOwnProperty.call(object, field)\n}\n","import type { Context, RawError, EventRateLimiter, User } from '@datadog/browser-core'\nimport {\n  combine,\n  isEmptyObject,\n  timeStampNow,\n  currentDrift,\n  display,\n  createEventRateLimiter,\n  canUseEventBridge,\n  assign,\n  round,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type {\n  RawRumErrorEvent,\n  RawRumEvent,\n  RawRumLongTaskEvent,\n  RawRumResourceEvent,\n  RumContext,\n} from '../rawRumEvent.types'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { getSyntheticsContext } from './contexts/syntheticsContext'\nimport { getCiTestContext } from './contexts/ciTestContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { ViewContexts } from './contexts/viewContexts'\nimport type { RumSessionManager } from './rumSessionManager'\nimport type { UrlContexts } from './contexts/urlContexts'\nimport type { RumConfiguration } from './configuration'\nimport type { ActionContexts } from './rumEventsCollection/action/actionCollection'\nimport { getDisplayContext } from './contexts/displayContext'\nimport type { CommonContext } from './contexts/commonContext'\nimport type { ModifiableFieldPaths } from './limitModification'\nimport { limitModification } from './limitModification'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst enum SessionType {\n  SYNTHETICS = 'synthetics',\n  USER = 'user',\n  CI_TEST = 'ci_test',\n}\n\nconst VIEW_MODIFIABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  'view.url': 'string',\n  'view.referrer': 'string',\n}\n\nconst USER_CUSTOMIZABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  context: 'object',\n}\n\nlet modifiableFieldPathsByEvent: { [key in RumEventType]: ModifiableFieldPaths }\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport function startRumAssembly(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  urlContexts: UrlContexts,\n  actionContexts: ActionContexts,\n  buildCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  modifiableFieldPathsByEvent = {\n    [RumEventType.VIEW]: VIEW_MODIFIABLE_FIELD_PATHS,\n    [RumEventType.ERROR]: assign(\n      {\n        'error.message': 'string',\n        'error.stack': 'string',\n        'error.resource.url': 'string',\n        'error.fingerprint': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.RESOURCE]: assign(\n      {\n        'resource.url': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.ACTION]: assign(\n      {\n        'action.target.name': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.LONG_TASK]: assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n  }\n  const eventRateLimiters = {\n    [RumEventType.ERROR]: createEventRateLimiter(\n      RumEventType.ERROR,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.ACTION]: createEventRateLimiter(\n      RumEventType.ACTION,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n  }\n\n  const syntheticsContext = getSyntheticsContext()\n  const ciTestContext = getCiTestContext()\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    ({ startTime, rawRumEvent, domainContext, savedCommonContext, customerContext }) => {\n      const viewContext = viewContexts.findView(startTime)\n      const urlContext = urlContexts.findUrl(startTime)\n      const session = sessionManager.findTrackedSession(startTime)\n      if (session && viewContext && urlContext) {\n        const commonContext = savedCommonContext || buildCommonContext()\n        const actionId = actionContexts.findActionId(startTime)\n\n        const rumContext: RumContext = {\n          _dd: {\n            format_version: 2,\n            drift: currentDrift(),\n            session: {\n              plan: session.plan,\n            },\n            configuration: {\n              session_sample_rate: round(configuration.sessionSampleRate, 3),\n              session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3),\n            },\n            browser_sdk_version: canUseEventBridge() ? __BUILD_ENV__SDK_VERSION__ : undefined,\n          },\n          application: {\n            id: configuration.applicationId,\n          },\n          date: timeStampNow(),\n          service: viewContext.service || configuration.service,\n          version: viewContext.version || configuration.version,\n          source: 'browser',\n          session: {\n            id: session.id,\n            type: syntheticsContext ? SessionType.SYNTHETICS : ciTestContext ? SessionType.CI_TEST : SessionType.USER,\n          },\n          view: {\n            id: viewContext.id,\n            name: viewContext.name,\n            url: urlContext.url,\n            referrer: urlContext.referrer,\n          },\n          action: needToAssembleWithAction(rawRumEvent) && actionId ? { id: actionId } : undefined,\n          synthetics: syntheticsContext,\n          ci_test: ciTestContext,\n          display: getDisplayContext(configuration),\n        }\n\n        const serverRumEvent = combine(rumContext as RumContext & Context, rawRumEvent) as RumEvent & Context\n        serverRumEvent.context = combine(commonContext.context, customerContext)\n\n        if (!('has_replay' in serverRumEvent.session)) {\n          ;(serverRumEvent.session as Mutable<RumEvent['session']>).has_replay = commonContext.hasReplay\n        }\n\n        if (!isEmptyObject(commonContext.user)) {\n          ;(serverRumEvent.usr as Mutable<RumEvent['usr']>) = commonContext.user as User & Context\n        }\n\n        if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n          if (isEmptyObject(serverRumEvent.context)) {\n            delete serverRumEvent.context\n          }\n          lifeCycle.notify(LifeCycleEventType.RUM_EVENT_COLLECTED, serverRumEvent)\n        }\n      }\n    }\n  )\n}\n\nfunction shouldSend(\n  event: RumEvent & Context,\n  beforeSend: RumConfiguration['beforeSend'],\n  domainContext: RumEventDomainContext,\n  eventRateLimiters: { [key in RumEventType]?: EventRateLimiter }\n) {\n  if (beforeSend) {\n    const result = limitModification(event, modifiableFieldPathsByEvent[event.type], (event) =>\n      beforeSend(event, domainContext)\n    )\n    if (result === false && event.type !== RumEventType.VIEW) {\n      return false\n    }\n    if (result === false) {\n      display.warn(\"Can't dismiss view events using beforeSend!\")\n    }\n  }\n\n  const rateLimitReached = eventRateLimiters[event.type]?.isLimitReached()\n  return !rateLimitReached\n}\n\nfunction needToAssembleWithAction(\n  event: RawRumEvent\n): event is RawRumErrorEvent | RawRumResourceEvent | RawRumLongTaskEvent {\n  return [RumEventType.ERROR, RumEventType.RESOURCE, RumEventType.LONG_TASK].indexOf(event.type) !== -1\n}\n","export interface CiTestWindow extends Window {\n  Cypress?: {\n    env: (key: string) => string | undefined\n  }\n}\n\nexport function getCiTestContext() {\n  const testExecutionId = (window as CiTestWindow).Cypress?.env('traceId')\n\n  if (typeof testExecutionId === 'string') {\n    return {\n      test_execution_id: testExecutionId,\n    }\n  }\n}\n","import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n","import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/utils/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\nimport { shallowClone } from '../tools/utils/objectUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListener } from './addEventListener'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable(configuration: Configuration) {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable(configuration)\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable(configuration: Configuration) {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, configuration, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, configuration: Configuration, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = () => {\n    unsubscribeLoadEndListener()\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  }\n\n  const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, this, 'loadend', onEnd)\n\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import type { Context, PageExitEvent, RawError, RelativeTime } from '@datadog/browser-core'\nimport { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { RumPerformanceEntry } from '../browser/performanceCollection'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RawRumEvent } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { CommonContext } from './contexts/commonContext'\nimport type { RequestCompleteEvent, RequestStartEvent } from './requestCollection'\nimport type { AutoAction } from './rumEventsCollection/action/actionCollection'\nimport type { ViewEvent, ViewCreatedEvent, ViewEndedEvent } from './rumEventsCollection/view/trackViews'\n\nexport const enum LifeCycleEventType {\n  PERFORMANCE_ENTRIES_COLLECTED,\n  AUTO_ACTION_COMPLETED,\n  VIEW_CREATED,\n  VIEW_UPDATED,\n  VIEW_ENDED,\n  REQUEST_STARTED,\n  REQUEST_COMPLETED,\n\n  // The SESSION_EXPIRED lifecycle event has been introduced to represent when a session has expired\n  // and trigger cleanup tasks related to this, prior to renewing the session. Its implementation is\n  // slightly naive: it is not triggered as soon as the session is expired, but rather just before\n  // notifying that the session is renewed. Thus, the session id is already set to the newly renewed\n  // session.\n  //\n  // This implementation is \"good enough\" for our use-cases. Improving this is not trivial,\n  // primarily because multiple instances of the SDK may be managing the same session cookie at\n  // the same time, for example when using Logs and RUM on the same page, or opening multiple tabs\n  // on the same domain.\n  SESSION_EXPIRED,\n\n  SESSION_RENEWED,\n  PAGE_EXITED,\n  RAW_RUM_EVENT_COLLECTED,\n  RUM_EVENT_COLLECTED,\n  RAW_ERROR_COLLECTED,\n}\n\n// This is a workaround for an issue occurring when the Browser SDK is included in a TypeScript\n// project configured with `isolatedModules: true`. Even if the const enum is declared in this\n// module, we cannot use it directly to define the EventMap interface keys (TS error: \"Cannot access\n// ambient const enums when the '--isolatedModules' flag is provided.\").\n//\n// Using a plain enum would fix the issue, but would also add 2KB to the minified bundle. By using\n// this workaround, we can keep using a const enum without impacting the bundle size (since it is a\n// \"declare\" statement, it will only be used during typecheck and completely ignored when building\n// JavaScript).\n//\n// See issues:\n// * https://github.com/DataDog/browser-sdk/issues/2208\n// * https://github.com/microsoft/TypeScript/issues/54152\ndeclare const LifeCycleEventTypeAsConst: {\n  PERFORMANCE_ENTRIES_COLLECTED: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED\n  AUTO_ACTION_COMPLETED: LifeCycleEventType.AUTO_ACTION_COMPLETED\n  VIEW_CREATED: LifeCycleEventType.VIEW_CREATED\n  VIEW_UPDATED: LifeCycleEventType.VIEW_UPDATED\n  VIEW_ENDED: LifeCycleEventType.VIEW_ENDED\n  REQUEST_STARTED: LifeCycleEventType.REQUEST_STARTED\n  REQUEST_COMPLETED: LifeCycleEventType.REQUEST_COMPLETED\n  SESSION_EXPIRED: LifeCycleEventType.SESSION_EXPIRED\n  SESSION_RENEWED: LifeCycleEventType.SESSION_RENEWED\n  PAGE_EXITED: LifeCycleEventType.PAGE_EXITED\n  RAW_RUM_EVENT_COLLECTED: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED\n  RUM_EVENT_COLLECTED: LifeCycleEventType.RUM_EVENT_COLLECTED\n  RAW_ERROR_COLLECTED: LifeCycleEventType.RAW_ERROR_COLLECTED\n}\n\n// Note: this interface needs to be exported even if it is not used outside of this module, else TS\n// fails to build the rum-core package with error TS4058\nexport interface LifeCycleEventMap {\n  [LifeCycleEventTypeAsConst.PERFORMANCE_ENTRIES_COLLECTED]: RumPerformanceEntry[]\n  [LifeCycleEventTypeAsConst.AUTO_ACTION_COMPLETED]: AutoAction\n  [LifeCycleEventTypeAsConst.VIEW_CREATED]: ViewCreatedEvent\n  [LifeCycleEventTypeAsConst.VIEW_UPDATED]: ViewEvent\n  [LifeCycleEventTypeAsConst.VIEW_ENDED]: ViewEndedEvent\n  [LifeCycleEventTypeAsConst.REQUEST_STARTED]: RequestStartEvent\n  [LifeCycleEventTypeAsConst.REQUEST_COMPLETED]: RequestCompleteEvent\n  [LifeCycleEventTypeAsConst.SESSION_EXPIRED]: void\n  [LifeCycleEventTypeAsConst.SESSION_RENEWED]: void\n  [LifeCycleEventTypeAsConst.PAGE_EXITED]: PageExitEvent\n  [LifeCycleEventTypeAsConst.RAW_RUM_EVENT_COLLECTED]: RawRumEventCollectedData\n  [LifeCycleEventTypeAsConst.RUM_EVENT_COLLECTED]: RumEvent & Context\n  [LifeCycleEventTypeAsConst.RAW_ERROR_COLLECTED]: {\n    error: RawError\n    savedCommonContext?: CommonContext\n    customerContext?: Context\n  }\n}\n\nexport interface RawRumEventCollectedData<E extends RawRumEvent = RawRumEvent> {\n  startTime: RelativeTime\n  savedCommonContext?: CommonContext\n  customerContext?: Context\n  rawRumEvent: E\n  domainContext: RumEventDomainContext<E['type']>\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n","import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ValueHistory<Value> {\n  private entries: Array<ValueHistoryEntry<Value>> = []\n  private clearOldValuesInterval: TimeoutId\n\n  constructor(\n    private expireDelay: number,\n    private maxEntries?: number\n  ) {\n    this.clearOldValuesInterval = setInterval(() => this.clearOldValues(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop()\n    }\n\n    this.entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Value | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return this.entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldValuesInterval)\n  }\n\n  private clearOldValues() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import type { RelativeTime, ClocksState } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, ValueHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { ViewCreatedEvent } from '../rumEventsCollection/view/trackViews'\n\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface ViewContext {\n  service?: string\n  version?: string\n  id: string\n  name?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewContexts {\n  findView: (startTime?: RelativeTime) => ViewContext | undefined\n  stop: () => void\n}\n\nexport function startViewContexts(lifeCycle: LifeCycle): ViewContexts {\n  const viewContextHistory = new ValueHistory<ViewContext>(VIEW_CONTEXT_TIME_OUT_DELAY)\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    viewContextHistory.add(buildViewContext(view), view.startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    viewContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    viewContextHistory.reset()\n  })\n\n  function buildViewContext(view: ViewCreatedEvent) {\n    return {\n      service: view.service,\n      version: view.version,\n      id: view.id,\n      name: view.name,\n      startClocks: view.startClocks,\n    }\n  }\n\n  return {\n    findView: (startTime) => viewContextHistory.find(startTime),\n    stop: () => {\n      viewContextHistory.stop()\n    },\n  }\n}\n","import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\n\nexport function instrumentMethod<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  instrumentationFactory: (\n    original: OBJECT[METHOD]\n  ) => (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => ReturnType<OBJECT[METHOD]>\n) {\n  const original = object[method]\n\n  let instrumentation = instrumentationFactory(original)\n\n  const instrumentationWrapper = function (this: OBJECT): ReturnType<OBJECT[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return instrumentation.apply(this, arguments as unknown as Parameters<OBJECT[METHOD]>)\n  }\n  object[method] = instrumentationWrapper as OBJECT[METHOD]\n\n  return {\n    stop: () => {\n      if (object[method] === instrumentationWrapper) {\n        object[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nexport function instrumentMethodAndCallOriginal<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  {\n    before,\n    after,\n  }: {\n    before?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n    after?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n  }\n) {\n  return instrumentMethod(\n    object,\n    method,\n    (original) =>\n      function () {\n        const args = arguments as unknown as Parameters<OBJECT[METHOD]>\n        let result\n\n        if (before) {\n          callMonitored(before, this, args)\n        }\n\n        if (typeof original === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          result = original.apply(this, args)\n        }\n\n        if (after) {\n          callMonitored(after, this, args)\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result\n      }\n  )\n}\n\nexport function instrumentSetter<OBJECT extends { [key: string]: any }, PROPERTY extends keyof OBJECT>(\n  object: OBJECT,\n  property: PROPERTY,\n  after: (thisObject: OBJECT, value: OBJECT[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(object, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  let instrumentation = (thisObject: OBJECT, value: OBJECT[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      after(thisObject, value)\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: OBJECT, value: OBJECT[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(object, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(object, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(object, property, originalDescriptor)\n      } else {\n        instrumentation = noop\n      }\n    },\n  }\n}\n","import { instrumentMethod } from '../tools/instrumentMethod'\nimport { callMonitored, monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { ClocksState } from '../tools/utils/timeUtils'\nimport { clocksNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: unknown\n  init?: RequestInit\n  url: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchResolveContext extends FetchContextBase {\n  state: 'resolve'\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchResolveContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  const observable = new Observable<FetchContext>(() => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(\n      window,\n      'fetch',\n      (originalFetch) =>\n        function (input, init) {\n          let responsePromise: Promise<Response>\n\n          const context = callMonitored(beforeSend, null, [observable, input, init])\n          if (context) {\n            responsePromise = originalFetch.call(this, context.input as RequestInfo, context.init)\n            callMonitored(afterSend, null, [observable, responsePromise, context])\n          } else {\n            responsePromise = originalFetch.call(this, input, init)\n          }\n\n          return responsePromise\n        }\n    )\n\n    return stop\n  })\n\n  return observable\n}\n\nfunction beforeSend(observable: Observable<FetchContext>, input: unknown, init?: RequestInit) {\n  const method = (init && init.method) || (input instanceof Request && input.method) || 'GET'\n  const url = input instanceof Request ? input.url : normalizeUrl(String(input))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n  }\n\n  observable.notify(context)\n\n  return context\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchResolveContext\n    context.state = 'resolve'\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n    }\n    observable.notify(context)\n  }\n\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchResolveContext,\n} from '@datadog/browser-core'\nimport {\n  RequestType,\n  initFetchObservable,\n  initXhrObservable,\n  readBytesFromStream,\n  elapsed,\n  timeStampNow,\n  tryToClone,\n} from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './rumEventsCollection/resource/resourceUtils'\nimport type { TraceIdentifier, Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchResolveContext extends FetchResolveContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: unknown\n  init?: RequestInit\n  error?: Error\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  const tracer = startTracer(configuration, sessionManager)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, configuration, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable(configuration).subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchResolveContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'resolve':\n        waitForResponseToComplete(context, (duration: Duration) => {\n          tracer.clearTracingIfNeeded(context)\n          lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n            duration,\n            method: context.method,\n            requestIndex: context.requestIndex,\n            responseType: context.responseType,\n            spanId: context.spanId,\n            startClocks: context.startClocks,\n            status: context.status,\n            traceId: context.traceId,\n            traceSampled: context.traceSampled,\n            type: RequestType.FETCH,\n            url: context.url,\n            response: context.response,\n            init: context.init,\n            input: context.input,\n          })\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n\nfunction waitForResponseToComplete(context: RumFetchResolveContext, callback: (duration: Duration) => void) {\n  const clonedResponse = context.response && tryToClone(context.response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // do not try to wait for the response if the clone failed, fetch error or null body\n    callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n  } else {\n    readBytesFromStream(\n      clonedResponse.body,\n      () => {\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n      },\n      {\n        bytesLimit: Number.POSITIVE_INFINITY,\n        collectStreamBody: false,\n      }\n    )\n  }\n}\n","export function isServerError(status: number) {\n  return status >= 500\n}\n\nexport function tryToClone(response: Response): Response | undefined {\n  try {\n    return response.clone()\n  } catch (e) {\n    // clone can throw if the response has already been used by another instrumentation or is disturbed\n    return\n  }\n}\n","import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n","import { noop } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumActionEvent, RumErrorEvent, RumLongTaskEvent, RumResourceEvent } from '../rumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport interface EventCounts {\n  errorCount: number\n  actionCount: number\n  longTaskCount: number\n  resourceCount: number\n  frustrationCount: number\n}\n\nexport function trackEventCounts({\n  lifeCycle,\n  isChildEvent,\n  onChange: callback = noop,\n}: {\n  lifeCycle: LifeCycle\n  isChildEvent: (event: RumActionEvent | RumErrorEvent | RumLongTaskEvent | RumResourceEvent) => boolean\n  onChange?: () => void\n}) {\n  const eventCounts: EventCounts = {\n    errorCount: 0,\n    longTaskCount: 0,\n    resourceCount: 0,\n    actionCount: 0,\n    frustrationCount: 0,\n  }\n\n  const subscription = lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event): void => {\n    if (event.type === 'view' || !isChildEvent(event)) {\n      return\n    }\n    switch (event.type) {\n      case RumEventType.ERROR:\n        eventCounts.errorCount += 1\n        callback()\n        break\n      case RumEventType.ACTION:\n        eventCounts.actionCount += 1\n        if (event.action.frustration) {\n          eventCounts.frustrationCount += event.action.frustration.type.length\n        }\n        callback()\n        break\n      case RumEventType.LONG_TASK:\n        eventCounts.longTaskCount += 1\n        callback()\n        break\n      case RumEventType.RESOURCE:\n        eventCounts.resourceCount += 1\n        callback()\n        break\n    }\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n    eventCounts,\n  }\n}\n","import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport {\n  instrumentMethodAndCallOriginal,\n  matchList,\n  monitor,\n  Observable,\n  timeStampNow,\n  setTimeout,\n  clearTimeout,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration !== undefined\n      ? setTimeout(\n          monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n          maxDuration\n        )\n      : undefined\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  const observable = new Observable<PageActivityEvent>(() => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (entries.some((entry) => entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name))) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n\n  return observable\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethodAndCallOriginal(window, 'open', { before: callback })\n}\n","import type { TimeoutId } from '@datadog/browser-core'\nimport { ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { Click } from './trackClickActions'\n\nexport interface ClickChain {\n  tryAppend: (click: Click) => boolean\n  stop: () => void\n}\n\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100\n\nconst enum ClickChainStatus {\n  WaitingForMoreClicks,\n  WaitingForClicksToStop,\n  Finalized,\n}\n\nexport function createClickChain(firstClick: Click, onFinalize: (clicks: Click[]) => void): ClickChain {\n  const bufferedClicks: Click[] = []\n  let status = ClickChainStatus.WaitingForMoreClicks\n  let maxDurationBetweenClicksTimeoutId: TimeoutId | undefined\n  appendClick(firstClick)\n\n  function appendClick(click: Click) {\n    click.stopObservable.subscribe(tryFinalize)\n    bufferedClicks.push(click)\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS)\n  }\n\n  function tryFinalize() {\n    if (status === ClickChainStatus.WaitingForClicksToStop && bufferedClicks.every((click) => click.isStopped())) {\n      status = ClickChainStatus.Finalized\n      onFinalize(bufferedClicks)\n    }\n  }\n\n  function dontAcceptMoreClick() {\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    if (status === ClickChainStatus.WaitingForMoreClicks) {\n      status = ClickChainStatus.WaitingForClicksToStop\n      tryFinalize()\n    }\n  }\n\n  return {\n    tryAppend: (click) => {\n      if (status !== ClickChainStatus.WaitingForMoreClicks) {\n        return false\n      }\n\n      if (\n        bufferedClicks.length > 0 &&\n        !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)\n      ) {\n        dontAcceptMoreClick()\n        return false\n      }\n\n      appendClick(click)\n      return true\n    },\n    stop: () => {\n      dontAcceptMoreClick()\n    },\n  }\n}\n\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first: MouseEvent, second: MouseEvent) {\n  return (\n    first.target === second.target &&\n    mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n    first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS\n  )\n}\n\nfunction mouseEventDistance(origin: MouseEvent, other: MouseEvent) {\n  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2))\n}\n","import { safeTruncate, isIE, find } from '@datadog/browser-core'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\n\nexport function getActionNameFromElement(element: Element, userProgrammaticAttribute?: string): string {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return (\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute)) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) ||\n    ''\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  let elementWithAttribute\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n  } else {\n    let element: Element | null = targetElement\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element\n        break\n      }\n      element = element.parentElement\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined\n) => string | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute) => {\n    // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n    // instead\n    if (supportsLabelProperty()) {\n      if ('labels' in element && element.labels && element.labels.length > 0) {\n        return getTextualContent(element.labels[0], userProgrammaticAttribute)\n      }\n    } else if (element.id) {\n      const label =\n        element.ownerDocument &&\n        find(element.ownerDocument.querySelectorAll('label'), (label) => label.htmlFor === element.id)\n      return label && getTextualContent(label, userProgrammaticAttribute)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return input.value\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getTextualContent(element, userProgrammaticAttribute)\n    }\n  },\n  (element) => element.getAttribute('aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return labelledByAttribute\n        .split(/\\s+/)\n        .map((id) => getElementById(element, id))\n        .filter((label): label is HTMLElement => Boolean(label))\n        .map((element) => getTextualContent(element, userProgrammaticAttribute))\n        .join(' ')\n    }\n  },\n  (element) => element.getAttribute('alt'),\n  (element) => element.getAttribute('name'),\n  (element) => element.getAttribute('title'),\n  (element) => element.getAttribute('placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute) => getTextualContent(element, userProgrammaticAttribute),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[]\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const name = strategy(element, userProgrammaticAttribute)\n      if (typeof name === 'string') {\n        const trimmedName = name.trim()\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName))\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = element.parentElement\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getTextualContent(element: Element | HTMLElement, userProgrammaticAttribute: string | undefined) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style')\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE()\n}\n\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsLabelPropertyResult: boolean | undefined\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype\n  }\n  return supportsLabelPropertyResult\n}\n\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsElementClosestResult: boolean | undefined\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype\n  }\n  return supportsElementClosestResult\n}\n","import { cssEscape } from '@datadog/browser-core'\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\ntype SelectorGetter = (element: Element, actionNameAttribute: string | undefined) => string | undefined\n\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nconst GLOBALLY_UNIQUE_SELECTOR_GETTERS: SelectorGetter[] = [getStableAttributeSelector, getIDSelector]\n\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nconst UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS: SelectorGetter[] = [\n  getStableAttributeSelector,\n  getClassSelector,\n  getTagNameSelector,\n]\n\nexport function getSelectorFromElement(targetElement: Element, actionNameAttribute: string | undefined) {\n  let targetElementSelector = ''\n  let element: Element | null = targetElement\n\n  while (element && element.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      element,\n      GLOBALLY_UNIQUE_SELECTOR_GETTERS,\n      isSelectorUniqueGlobally,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    if (globallyUniqueSelector) {\n      return globallyUniqueSelector\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      element,\n      UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS,\n      isSelectorUniqueAmongSiblings,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    targetElementSelector =\n      uniqueSelectorAmongChildren || combineSelector(getPositionSelector(element), targetElementSelector)\n\n    element = element.parentElement\n  }\n\n  return targetElementSelector\n}\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time. We might want to allow customers to\n  // provide their own `isGeneratedValue` at some point.\n  return /[0-9]/.test(value)\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${cssEscape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  if (element.classList.length > 0) {\n    for (let i = 0; i < element.classList.length; i += 1) {\n      const className = element.classList[i]\n      if (isGeneratedValue(className)) {\n        continue\n      }\n\n      return `${cssEscape(element.tagName)}.${cssEscape(className)}`\n    }\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return cssEscape(element.tagName)\n}\n\nfunction getStableAttributeSelector(element: Element, actionNameAttribute: string | undefined): string | undefined {\n  if (actionNameAttribute) {\n    const selector = getAttributeSelector(actionNameAttribute)\n    if (selector) {\n      return selector\n    }\n  }\n\n  for (const attributeName of STABLE_ATTRIBUTES) {\n    const selector = getAttributeSelector(attributeName)\n    if (selector) {\n      return selector\n    }\n  }\n\n  function getAttributeSelector(attributeName: string) {\n    if (element.hasAttribute(attributeName)) {\n      return `${cssEscape(element.tagName)}[${attributeName}=\"${cssEscape(element.getAttribute(attributeName)!)}\"]`\n    }\n  }\n}\n\nfunction getPositionSelector(element: Element): string {\n  let sibling = element.parentElement!.firstElementChild\n  let elementIndex = 1\n\n  while (sibling && sibling !== element) {\n    if (sibling.tagName === element.tagName) {\n      elementIndex += 1\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return `${cssEscape(element.tagName)}:nth-of-type(${elementIndex})`\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: SelectorGetter[],\n  predicate: (element: Element, selector: string) => boolean,\n  actionNameAttribute: string | undefined,\n  childSelector?: string\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element, actionNameAttribute)\n    if (!elementSelector) {\n      continue\n    }\n    const fullSelector = combineSelector(elementSelector, childSelector)\n    if (predicate(element, fullSelector)) {\n      return fullSelector\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element: Element, selector: string): boolean {\n  return element.ownerDocument.querySelectorAll(selector).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > SELECTOR\" returns a single element.\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT SELECTOR\" returns a single element), regardless of whether the selector is a\n * direct descendent of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n */\nfunction isSelectorUniqueAmongSiblings(element: Element, selector: string): boolean {\n  return (\n    element.parentElement!.querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector)\n      .length === 1\n  )\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n\nlet supportScopeSelectorCache: boolean | undefined\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope')\n      supportScopeSelectorCache = true\n    } catch {\n      supportScopeSelectorCache = false\n    }\n  }\n  return supportScopeSelectorCache\n}\n","import { addEventListener, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\n\nexport type MouseEventOnElement = PointerEvent & { target: Element }\n\nexport interface UserActivity {\n  selection: boolean\n  input: boolean\n}\nexport interface ActionEventsHooks<ClickContext> {\n  onPointerDown: (event: MouseEventOnElement) => ClickContext | undefined\n  onPointerUp: (context: ClickContext, event: MouseEventOnElement, getUserActivity: () => UserActivity) => void\n}\n\nexport function listenActionEvents<ClickContext>(\n  configuration: RumConfiguration,\n  { onPointerDown, onPointerUp }: ActionEventsHooks<ClickContext>\n) {\n  let selectionEmptyAtPointerDown: boolean\n  let userActivity: UserActivity = {\n    selection: false,\n    input: false,\n  }\n  let clickContext: ClickContext | undefined\n\n  const listeners = [\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.POINTER_DOWN,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event)) {\n          selectionEmptyAtPointerDown = isSelectionEmpty()\n          userActivity = {\n            selection: false,\n            input: false,\n          }\n          clickContext = onPointerDown(event)\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.SELECTION_CHANGE,\n      () => {\n        if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n          userActivity.selection = true\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.POINTER_UP,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event) && clickContext) {\n          // Use a scoped variable to make sure the value is not changed by other clicks\n          const localUserActivity = userActivity\n          onPointerUp(clickContext, event, () => localUserActivity)\n          clickContext = undefined\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.INPUT,\n      () => {\n        userActivity.input = true\n      },\n      { capture: true }\n    ),\n  ]\n\n  return {\n    stop: () => {\n      listeners.forEach((listener) => listener.stop())\n    },\n  }\n}\n\nfunction isSelectionEmpty(): boolean {\n  const selection = window.getSelection()\n  return !selection || selection.isCollapsed\n}\n\nfunction isValidPointerEvent(event: PointerEvent): event is MouseEventOnElement {\n  return (\n    event.target instanceof Element &&\n    // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in\n    // the future.\n    event.isPrimary !== false\n  )\n}\n","import { elementMatches, ONE_SECOND } from '@datadog/browser-core'\nimport { FrustrationType } from '../../../rawRumEvent.types'\nimport type { Click } from './trackClickActions'\n\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3\n\nexport function computeFrustration(clicks: Click[], rageClick: Click) {\n  if (isRage(clicks)) {\n    rageClick.addFrustration(FrustrationType.RAGE_CLICK)\n    if (clicks.some(isDead)) {\n      rageClick.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n    if (rageClick.hasError) {\n      rageClick.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    return { isRage: true }\n  }\n\n  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection)\n  clicks.forEach((click) => {\n    if (click.hasError) {\n      click.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    if (\n      isDead(click) &&\n      // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n      !hasSelectionChanged\n    ) {\n      click.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n  })\n  return { isRage: false }\n}\n\nexport function isRage(clicks: Click[]) {\n  if (clicks.some((click) => click.getUserActivity().selection)) {\n    return false\n  }\n  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n    if (\n      clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n      ONE_SECOND\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst DEAD_CLICK_EXCLUDE_SELECTOR =\n  // inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n  // inputs (using a negative selector is shorter here)\n  'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n  'textarea,' +\n  'select,' +\n  // contenteditable and their descendants don't always trigger meaningful changes when manipulated\n  '[contenteditable],' +\n  '[contenteditable] *,' +\n  // canvas, as there is no good way to detect activity occurring on them\n  'canvas,' +\n  // links that are interactive (have an href attribute) or any of their descendants, as they can\n  // open a new tab or navigate to a hash without triggering a meaningful event\n  'a[href],' +\n  'a[href] *'\n\nexport function isDead(click: Click) {\n  if (click.hasPageActivity || click.getUserActivity().input) {\n    return false\n  }\n  return !elementMatches(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR)\n}\n","import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  includes,\n  timeStampNow,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ValueHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../../rawRumEvent.types'\nimport { ActionType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport { getSelectorFromElement } from './getSelectorFromElement'\nimport type { MouseEventOnElement, UserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string\n    selector_with_stable_attributes?: string\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ValueHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ValueHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<{\n    clickActionBase: ClickActionBase\n    hadActivityOnPointerDown: () => boolean\n  }>(configuration, {\n    onPointerDown: (pointerDownEvent) =>\n      processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent),\n    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) =>\n      startClickAction(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        startEvent,\n        getUserActivity,\n        hadActivityOnPointerDown\n      ),\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) =>\n      configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  pointerDownEvent: MouseEventOnElement\n) {\n  if (!configuration.trackFrustrations && history.find()) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new\n    // action if another one is already occurring.\n    return\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute)\n  if (!configuration.trackFrustrations && !clickActionBase.name) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action\n    // with a blank name\n    return\n  }\n\n  let hadActivityOnPointerDown = false\n\n  waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity\n    },\n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n\n  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown }\n}\n\nfunction startClickAction(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement,\n  getUserActivity: () => UserActivity,\n  hadActivityOnPointerDown: () => boolean\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent)\n\n  if (configuration.trackFrustrations) {\n    appendClickToClickChain(click)\n  }\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        if (pageActivityEndEvent.hadActivity) {\n          click.stop(pageActivityEndEvent.end)\n        } else if (hadActivityOnPointerDown()) {\n          click.stop(\n            // using the click start as activity end, so the click will have some activity but its\n            // duration will be 0 (as the activity started before the click start)\n            click.startClocks.timeStamp\n          )\n        } else {\n          click.stop()\n        }\n\n        // Validate or discard the click only if we don't track frustrations. It'll be done when\n        // the click chain is finalized.\n        if (!configuration.trackFrustrations) {\n          if (!pageActivityEndEvent.hadActivity) {\n            // If we are not tracking frustrations, we should discard the click to keep backward\n            // compatibility.\n            click.discard()\n          } else {\n            click.validate()\n          }\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(event: MouseEventOnElement, actionNameAttribute?: string): ClickActionBase {\n  const rect = event.target.getBoundingClientRect()\n  return {\n    type: ActionType.CLICK,\n    target: {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, actionNameAttribute),\n    },\n    position: {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    },\n    name: getActionNameFromElement(event.target, actionNameAttribute),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: () => UserActivity,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) =>\n      event.action !== undefined &&\n      (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id),\n  })\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: startEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [startEvent],\n          event: startEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n","import type { ClocksState, Context, Observable } from '@datadog/browser-core'\nimport { noop, assign, combine, toServerDuration, generateUUID } from '@datadog/browser-core'\n\nimport type { RawRumActionEvent } from '../../../rawRumEvent.types'\nimport { ActionType, RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumConfiguration } from '../../configuration'\nimport type { CommonContext } from '../../contexts/commonContext'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport type { ActionContexts, ClickAction } from './trackClickActions'\nimport { trackClickActions } from './trackClickActions'\n\nexport type { ActionContexts }\n\nexport interface CustomAction {\n  type: ActionType.CUSTOM\n  name: string\n  startClocks: ClocksState\n  context?: Context\n}\n\nexport type AutoAction = ClickAction\n\nexport function startActionCollection(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory\n) {\n  lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, (action) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action, pageStateHistory))\n  )\n\n  let actionContexts: ActionContexts = { findActionId: noop as () => undefined }\n  if (configuration.trackUserInteractions) {\n    actionContexts = trackClickActions(lifeCycle, domMutationObservable, configuration).actionContexts\n  }\n\n  return {\n    addAction: (action: CustomAction, savedCommonContext?: CommonContext) => {\n      lifeCycle.notify(\n        LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n        assign(\n          {\n            savedCommonContext,\n          },\n          processAction(action, pageStateHistory)\n        )\n      )\n    },\n    actionContexts,\n  }\n}\n\nfunction processAction(\n  action: AutoAction | CustomAction,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumActionEvent> {\n  const autoActionProperties = isAutoAction(action)\n    ? {\n        action: {\n          id: action.id,\n          loading_time: toServerDuration(action.duration),\n          frustration: {\n            type: action.frustrationTypes,\n          },\n          error: {\n            count: action.counts.errorCount,\n          },\n          long_task: {\n            count: action.counts.longTaskCount,\n          },\n          resource: {\n            count: action.counts.resourceCount,\n          },\n        },\n        _dd: {\n          action: {\n            target: action.target,\n            position: action.position,\n          },\n        },\n      }\n    : undefined\n  const customerContext = !isAutoAction(action) ? action.context : undefined\n  const actionEvent: RawRumActionEvent = combine(\n    {\n      action: {\n        id: generateUUID(),\n        target: {\n          name: action.name,\n        },\n        type: action.type,\n      },\n      date: action.startClocks.timeStamp,\n      type: RumEventType.ACTION as const,\n      view: { in_foreground: pageStateHistory.isInActivePageStateAt(action.startClocks.relative) },\n    },\n    autoActionProperties\n  )\n\n  return {\n    customerContext,\n    rawRumEvent: actionEvent,\n    startTime: action.startClocks.relative,\n    domainContext: isAutoAction(action) ? { event: action.event, events: action.events } : {},\n  }\n}\n\nfunction isAutoAction(action: AutoAction | CustomAction): action is AutoAction {\n  return action.type !== ActionType.CUSTOM\n}\n","import { instrumentMethodAndCallOriginal } from '../../tools/instrumentMethod'\nimport { computeStackTrace } from './computeStackTrace'\nimport type { UnhandledErrorCallback, StackTrace } from './types'\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/\n\n/**\n * Cross-browser collection of unhandled errors\n *\n * Supports:\n * - Firefox: full stack trace with line numbers, plus column number\n * on top frame; column number is not guaranteed\n * - Opera: full stack trace with line and column numbers\n * - Chrome: full stack trace with line and column numbers\n * - Safari: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n * - IE: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n * - IE5.5+ (only 8.0 tested)\n * - Firefox 0.9+ (only 3.5+ tested)\n * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n * Exceptions Have Stacktrace to be enabled in opera:config)\n * - Safari 3+ (only 4+ tested)\n * - Chrome 1+ (only 5+ tested)\n * - Konqueror 3.5+ (untested)\n *\n * Tries to catch all unhandled errors and report them to the\n * callback.\n *\n * Callbacks receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport function startUnhandledErrorCollection(callback: UnhandledErrorCallback) {\n  const { stop: stopInstrumentingOnError } = instrumentOnError(callback)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(callback)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\n/**\n * Install a global onerror handler\n */\nfunction instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onerror', {\n    before(this: any, messageObj: unknown, url?: string, line?: number, column?: number, errorObj?: unknown) {\n      let stackTrace: StackTrace\n      if (errorObj instanceof Error) {\n        stackTrace = computeStackTrace(errorObj)\n      } else {\n        const stack = [{ url, column, line }]\n        const { name, message } = tryToParseMessage(messageObj)\n        stackTrace = {\n          name,\n          message,\n          stack,\n        }\n      }\n      callback(stackTrace, errorObj ?? messageObj)\n    },\n  })\n}\n\nfunction tryToParseMessage(messageObj: unknown) {\n  let name\n  let message\n  if ({}.toString.call(messageObj) === '[object String]') {\n    ;[, name, message] = ERROR_TYPES_RE.exec(messageObj as string)!\n  }\n  return { name, message }\n}\n\n/**\n * Install a global onunhandledrejection handler\n */\nfunction instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onunhandledrejection', {\n    before(e: PromiseRejectionEvent) {\n      const reason = e.reason || 'Empty reason'\n      const stack = computeStackTrace(reason)\n      callback(stack, reason)\n    },\n  })\n}\n","import { computeStackTrace } from '../tracekit'\nimport { createHandlingStack, formatErrorMessage, toStackTraceString, tryToGetFingerprint } from '../error/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { ConsoleApiName, globalConsole } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport { find } from '../../tools/utils/polyfills'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack?: string\n  fingerprint?: string\n}\n\nlet consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]!\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\nexport function resetConsoleObservable() {\n  consoleObservablesByApi = {}\n}\n\nfunction createConsoleObservable(api: ConsoleApiName) {\n  const observable = new Observable<ConsoleLog>(() => {\n    const originalConsoleApi = globalConsole[api]\n\n    globalConsole[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      globalConsole[api] = originalConsoleApi\n    }\n  })\n\n  return observable\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  // Todo: remove console error prefix in the next major version\n  let message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n  let fingerprint\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    fingerprint = tryToGetFingerprint(firstErrorParam)\n    message = `console error: ${message}`\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n    fingerprint,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return sanitize(param)\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(sanitize(param), undefined, 2)\n}\n","import { toStackTraceString } from '../error/error'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport { includes } from '../../tools/utils/polyfills'\nimport { safeTruncate } from '../../tools/utils/stringUtils'\nimport type { Configuration } from '../configuration'\nimport type { ReportType, InterventionReport, DeprecationReport } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = (typeof RawReportType)[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  stack?: string\n}\n\nexport function initReportObservable(configuration: Configuration, apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable(configuration))\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  const observable = new Observable<RawReport>(() => {\n    if (!window.ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Array<DeprecationReport | InterventionReport>, _: ReportingObserver) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    ) as ReportingObserverCallback\n\n    const observer = new window.ReportingObserver(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n\n  return observable\n}\n\nfunction createCspViolationReportObservable(configuration: Configuration) {\n  const observable = new Observable<RawReport>(() => {\n    const { stop } = addEventListener(configuration, document, DOM_EVENT.SECURITY_POLICY_VIOLATION, (event) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    return stop\n  })\n  return observable\n}\n\nfunction buildRawReportFromReport({ type, body }: DeprecationReport | InterventionReport): RawReport {\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | null,\n  lineNumber: number | null,\n  columnNumber: number | null\n): string | undefined {\n  return sourceFile\n    ? toStackTraceString({\n        name,\n        message,\n        stack: [\n          {\n            func: '?',\n            url: sourceFile,\n            line: lineNumber ?? undefined,\n            column: columnNumber ?? undefined,\n          },\n        ],\n      })\n    : undefined\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\n\nlet trackFirstHiddenSingleton: { timeStamp: RelativeTime } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function trackFirstHidden(configuration: RumConfiguration, eventTarget: Window = window) {\n  if (!trackFirstHiddenSingleton) {\n    if (document.visibilityState === 'hidden') {\n      trackFirstHiddenSingleton = {\n        timeStamp: 0 as RelativeTime,\n      }\n    } else {\n      trackFirstHiddenSingleton = {\n        timeStamp: Infinity as RelativeTime,\n      }\n      ;({ stop: stopListeners } = addEventListeners(\n        configuration,\n        eventTarget,\n        [DOM_EVENT.PAGE_HIDE, DOM_EVENT.VISIBILITY_CHANGE],\n        (event) => {\n          if (event.type === 'pagehide' || document.visibilityState === 'hidden') {\n            trackFirstHiddenSingleton!.timeStamp = event.timeStamp as RelativeTime\n            stopListeners!()\n          }\n        },\n        { capture: true }\n      ))\n    }\n  }\n\n  return trackFirstHiddenSingleton\n}\n\nexport function resetFirstHidden() {\n  if (stopListeners) {\n    stopListeners()\n  }\n  trackFirstHiddenSingleton = undefined\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport {\n  isEmptyObject,\n  assign,\n  ErrorSource,\n  generateUUID,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  Observable,\n  trackRuntimeError,\n  NonErrorPrefix,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport type { RawRumErrorEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { FeatureFlagContexts } from '../../contexts/featureFlagContext'\nimport type { CommonContext } from '../../contexts/commonContext'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport { trackConsoleError } from './trackConsoleError'\nimport { trackReportError } from './trackReportError'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startErrorCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n) {\n  const errorObservable = new Observable<RawError>()\n\n  trackConsoleError(errorObservable)\n  trackRuntimeError(errorObservable)\n  trackReportError(configuration, errorObservable)\n\n  errorObservable.subscribe((error) => lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error }))\n\n  return doStartErrorCollection(lifeCycle, pageStateHistory, featureFlagContexts)\n}\n\nexport function doStartErrorCollection(\n  lifeCycle: LifeCycle,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n) {\n  lifeCycle.subscribe(LifeCycleEventType.RAW_ERROR_COLLECTED, ({ error, customerContext, savedCommonContext }) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      assign(\n        {\n          customerContext,\n          savedCommonContext,\n        },\n        processError(error, pageStateHistory, featureFlagContexts)\n      )\n    )\n  })\n\n  return {\n    addError: (\n      { error, handlingStack, startClocks, context: customerContext }: ProvidedError,\n      savedCommonContext?: CommonContext\n    ) => {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        handlingStack,\n        startClocks,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n      })\n\n      lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, {\n        customerContext,\n        savedCommonContext,\n        error: rawError,\n      })\n    },\n  }\n}\n\nfunction processError(\n  error: RawError,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n): RawRumEventCollectedData<RawRumErrorEvent> {\n  const rawRumEvent: RawRumErrorEvent = {\n    date: error.startClocks.timeStamp,\n    error: {\n      id: generateUUID(),\n      message: error.message,\n      source: error.source,\n      stack: error.stack,\n      handling_stack: error.handlingStack,\n      type: error.type,\n      handling: error.handling,\n      causes: error.causes,\n      source_type: 'browser',\n      fingerprint: error.fingerprint,\n    },\n    type: RumEventType.ERROR as const,\n    view: { in_foreground: pageStateHistory.isInActivePageStateAt(error.startClocks.relative) },\n  }\n\n  const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(error.startClocks.relative)\n  if (featureFlagContext && !isEmptyObject(featureFlagContext)) {\n    rawRumEvent.feature_flags = featureFlagContext\n  }\n\n  return {\n    rawRumEvent,\n    startTime: error.startClocks.relative,\n    domainContext: {\n      error: error.originalError,\n    },\n  }\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, initConsoleObservable, ErrorSource, ConsoleApiName } from '@datadog/browser-core'\n\nexport function trackConsoleError(errorObservable: Observable<RawError>) {\n  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleError) =>\n    errorObservable.notify({\n      startClocks: clocksNow(),\n      message: consoleError.message,\n      stack: consoleError.stack,\n      fingerprint: consoleError.fingerprint,\n      source: ErrorSource.CONSOLE,\n      handling: ErrorHandling.HANDLED,\n      handlingStack: consoleError.handlingStack,\n    })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport { startUnhandledErrorCollection } from '../tracekit'\nimport { computeRawError } from './error'\nimport type { RawError } from './error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from './error.types'\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  return startUnhandledErrorCollection((stackTrace, originalError) => {\n    errorObservable.notify(\n      computeRawError({\n        stackTrace,\n        originalError,\n        startClocks: clocksNow(),\n        nonErrorPrefix: NonErrorPrefix.UNCAUGHT,\n        source: ErrorSource.SOURCE,\n        handling: ErrorHandling.UNHANDLED,\n      })\n    )\n  })\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, ErrorSource, initReportObservable, RawReportType } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\n\nexport function trackReportError(configuration: RumConfiguration, errorObservable: Observable<RawError>) {\n  const subscription = initReportObservable(configuration, [\n    RawReportType.cspViolation,\n    RawReportType.intervention,\n  ]).subscribe((reportError) =>\n    errorObservable.notify({\n      startClocks: clocksNow(),\n      message: reportError.message,\n      stack: reportError.stack,\n      type: reportError.subtype,\n      source: ErrorSource.REPORT,\n      handling: ErrorHandling.UNHANDLED,\n    })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport { toValidEntry } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource')\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .map((entry) => entry.toJSON() as RumPerformanceResourceTiming)\n    .filter(toValidEntry)\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    return candidates[0]\n  }\n\n  return\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n","import {\n  combine,\n  generateUUID,\n  RequestType,\n  ResourceType,\n  toServerDuration,\n  relativeToClocks,\n  assign,\n  isNumber,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n} from '@datadog/browser-core'\nimport type { ClocksState, Duration } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport type { RumPerformanceEntry, RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type {\n  PerformanceEntryRepresentation,\n  RumXhrResourceEventDomainContext,\n  RumFetchResourceEventDomainContext,\n} from '../../../domainContext.types'\nimport type { RawRumResourceEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport type { RumSessionManager } from '../../rumSessionManager'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport { PageState } from '../../contexts/pageStateHistory'\nimport { matchRequestTiming } from './matchRequestTiming'\nimport {\n  computePerformanceResourceDetails,\n  computePerformanceResourceDuration,\n  computeResourceKind,\n  computeSize,\n  isRequestKind,\n} from './resourceUtils'\n\nexport function startResourceCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  pageStateHistory: PageStateHistory\n) {\n  lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request: RequestCompleteEvent) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processRequest(request, configuration, sessionManager, pageStateHistory)\n    )\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'resource' && !isRequestKind(entry)) {\n        lifeCycle.notify(\n          LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n          processResourceEntry(entry, configuration, sessionManager, pageStateHistory)\n        )\n      }\n    }\n  })\n}\n\nfunction processRequest(\n  request: RequestCompleteEvent,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = request.type === RequestType.XHR ? ResourceType.XHR : ResourceType.FETCH\n\n  const matchingTiming = matchRequestTiming(request)\n  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks\n  const correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined\n\n  const tracingInfo = computeRequestTracingInfo(request, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n\n  const duration = computeRequestDuration(pageStateHistory, startClocks, request.duration)\n  const pageStateInfo = computePageStateInfo(\n    pageStateHistory,\n    startClocks,\n    matchingTiming?.duration ?? request.duration\n  )\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration,\n        method: request.method,\n        status_code: request.status,\n        url: request.url,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    correspondingTimingOverrides,\n    indexingInfo,\n    pageStateInfo\n  )\n\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: matchingTiming && toPerformanceEntryRepresentation(matchingTiming),\n      xhr: request.xhr,\n      response: request.response,\n      requestInput: request.input,\n      requestInit: request.init,\n      error: request.error,\n    } as RumFetchResourceEventDomainContext | RumXhrResourceEventDomainContext,\n  }\n}\n\nfunction processResourceEntry(\n  entry: RumPerformanceResourceTiming,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = computeResourceKind(entry)\n  const entryMetrics = computePerformanceEntryMetrics(entry)\n  const startClocks = relativeToClocks(entry.startTime)\n\n  const tracingInfo = computeEntryTracingInfo(entry, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n  const pageStateInfo = computePageStateInfo(pageStateHistory, startClocks, entry.duration)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        url: entry.name,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    entryMetrics,\n    indexingInfo,\n    pageStateInfo\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: toPerformanceEntryRepresentation(entry),\n    },\n  }\n}\n\nfunction computePerformanceEntryMetrics(timing: RumPerformanceResourceTiming) {\n  return {\n    resource: assign(\n      {\n        duration: computePerformanceResourceDuration(timing),\n        size: computeSize(timing),\n      },\n      computePerformanceResourceDetails(timing)\n    ),\n  }\n}\n\nfunction computeRequestTracingInfo(request: RequestCompleteEvent, configuration: RumConfiguration) {\n  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      span_id: request.spanId!.toDecimalString(),\n      trace_id: request.traceId!.toDecimalString(),\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\nfunction computeEntryTracingInfo(entry: RumPerformanceResourceTiming, configuration: RumConfiguration) {\n  const hasBeenTraced = entry.traceId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      trace_id: entry.traceId,\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\n// TODO next major: use directly PerformanceEntry type in domain context\nfunction toPerformanceEntryRepresentation(entry: RumPerformanceEntry): PerformanceEntryRepresentation {\n  return entry as PerformanceEntryRepresentation\n}\n\n/**\n * @returns number between 0 and 1 which represents trace sample rate\n */\nfunction getRulePsr(configuration: RumConfiguration) {\n  return isNumber(configuration.traceSampleRate) ? configuration.traceSampleRate / 100 : undefined\n}\n\nfunction computeIndexingInfo(sessionManager: RumSessionManager, resourceStart: ClocksState) {\n  const session = sessionManager.findTrackedSession(resourceStart.relative)\n  return {\n    _dd: {\n      discarded: !session || !session.resourceAllowed,\n    },\n  }\n}\n\nfunction computePageStateInfo(pageStateHistory: PageStateHistory, startClocks: ClocksState, duration: Duration) {\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.RESOURCE_PAGE_STATES)) {\n    return\n  }\n\n  return {\n    _dd: {\n      page_states: pageStateHistory.findAll(startClocks.relative, duration),\n      page_was_discarded: String((document as any).wasDiscarded),\n    },\n  }\n}\n\nfunction computeRequestDuration(pageStateHistory: PageStateHistory, startClocks: ClocksState, duration: Duration) {\n  // TODO remove FF in next major\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.NO_RESOURCE_DURATION_FROZEN_STATE)) {\n    return toServerDuration(duration)\n  }\n\n  const requestCrossedFrozenState = pageStateHistory\n    .findAll(startClocks.relative, duration)\n    ?.some((pageState) => pageState.state === PageState.FROZEN)\n\n  return !requestCrossedFrozenState ? toServerDuration(duration) : undefined\n}\n","import type { RelativeTime, Duration, ServerDuration } from '@datadog/browser-core'\nimport { toServerDuration } from '@datadog/browser-core'\nimport type { InForegroundPeriod, PageStateServerEntry } from '../../rawRumEvent.types'\nimport { PageState } from './pageStateHistory'\n\nexport interface ForegroundPeriod {\n  start: RelativeTime\n  end?: RelativeTime\n}\n\n// Todo: Remove in the next major release\nexport function mapToForegroundPeriods(\n  pageStateServerEntries: PageStateServerEntry[],\n  duration: Duration\n): InForegroundPeriod[] {\n  const foregroundPeriods: InForegroundPeriod[] = []\n  for (let i = 0; i < pageStateServerEntries.length; i++) {\n    const current = pageStateServerEntries[i]\n    const next = pageStateServerEntries[i + 1]\n\n    if (current.state === PageState.ACTIVE) {\n      const start = current.start >= 0 ? current.start : (0 as ServerDuration)\n      const end = next ? next.start : toServerDuration(duration)\n      foregroundPeriods.push({\n        start,\n        duration: (end - start) as ServerDuration,\n      })\n    }\n  }\n\n  return foregroundPeriods\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  setTimeout,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  elapsed,\n  ONE_MINUTE,\n  find,\n  findLast,\n  relativeNow,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type {\n  RumFirstInputTiming,\n  RumLargestContentfulPaintTiming,\n  RumPerformancePaintTiming,\n} from '../../../browser/performanceCollection'\nimport { trackFirstHidden } from './trackFirstHidden'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\n/**\n * The initial view can finish quickly, before some metrics can be produced (ex: before the page load\n * event, or the first input). Also, we don't want to trigger a view update indefinitely, to avoid\n * updates on views that ended a long time ago. Keep watching for metrics after the view ends for a\n * limited amount of time.\n */\nexport const KEEP_TRACKING_TIMINGS_AFTER_VIEW_DELAY = 5 * ONE_MINUTE\n\nexport interface Timings {\n  firstContentfulPaint?: Duration\n  firstByte?: Duration\n  domInteractive?: Duration\n  domContentLoaded?: Duration\n  domComplete?: Duration\n  loadEvent?: Duration\n  largestContentfulPaint?: Duration\n  firstInputDelay?: Duration\n  firstInputTime?: Duration\n}\n\nexport function trackInitialViewTimings(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  setLoadEvent: (loadEnd: Duration) => void,\n  scheduleViewUpdate: () => void\n) {\n  const timings: Timings = {}\n\n  function setTimings(newTimings: Partial<Timings>) {\n    assign(timings, newTimings)\n    scheduleViewUpdate()\n  }\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(lifeCycle, (newTimings) => {\n    setLoadEvent(newTimings.loadEvent)\n    setTimings(newTimings)\n  })\n  const { stop: stopFCPTracking } = trackFirstContentfulPaintTiming(lifeCycle, configuration, (firstContentfulPaint) =>\n    setTimings({ firstContentfulPaint })\n  )\n  const { stop: stopLCPTracking } = trackLargestContentfulPaintTiming(\n    lifeCycle,\n    configuration,\n    window,\n    (largestContentfulPaint, lcpElement) => {\n      webVitalTelemetryDebug.addWebVitalTelemetryDebug('LCP', lcpElement, largestContentfulPaint)\n\n      setTimings({\n        largestContentfulPaint,\n      })\n    }\n  )\n\n  const { stop: stopFIDTracking } = trackFirstInputTimings(\n    lifeCycle,\n    configuration,\n    ({ firstInputDelay, firstInputTime, firstInputTarget }) => {\n      webVitalTelemetryDebug.addWebVitalTelemetryDebug('FID', firstInputTarget, firstInputTime)\n\n      setTimings({\n        firstInputDelay,\n        firstInputTime,\n      })\n    }\n  )\n\n  function stop() {\n    stopNavigationTracking()\n    stopFCPTracking()\n    stopLCPTracking()\n    stopFIDTracking()\n  }\n\n  return {\n    stop,\n    timings,\n    scheduleStop: () => {\n      setTimeout(stop, KEEP_TRACKING_TIMINGS_AFTER_VIEW_DELAY)\n    },\n  }\n}\n\ninterface NavigationTimings {\n  domComplete: Duration\n  domContentLoaded: Duration\n  domInteractive: Duration\n  loadEvent: Duration\n  firstByte: Duration | undefined\n}\n\nexport function trackNavigationTimings(lifeCycle: LifeCycle, callback: (timings: NavigationTimings) => void) {\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'navigation') {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n        })\n      }\n    }\n  })\n\n  return { stop }\n}\n\nexport function trackFirstContentfulPaintTiming(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  callback: (fcpTiming: RelativeTime) => void\n) {\n  const firstHidden = trackFirstHidden(configuration)\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const fcpEntry = find(\n      entries,\n      (entry): entry is RumPerformancePaintTiming =>\n        entry.entryType === 'paint' &&\n        entry.name === 'first-contentful-paint' &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < TIMING_MAXIMUM_DELAY\n    )\n    if (fcpEntry) {\n      callback(fcpEntry.startTime)\n    }\n  })\n  return { stop }\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  eventTarget: Window,\n  callback: (lcpTiming: RelativeTime, lcpElement?: Element) => void\n) {\n  const firstHidden = trackFirstHidden(configuration)\n\n  // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    configuration,\n    eventTarget,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === 'largest-contentful-paint' &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < TIMING_MAXIMUM_DELAY\n      )\n      if (lcpEntry) {\n        callback(lcpEntry.startTime, lcpEntry.element)\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  callback: ({\n    firstInputDelay,\n    firstInputTime,\n    firstInputTarget,\n  }: {\n    firstInputDelay: Duration\n    firstInputTime: RelativeTime\n    firstInputTarget: Node | undefined\n  }) => void\n) {\n  const firstHidden = trackFirstHidden(configuration)\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const firstInputEntry = find(\n      entries,\n      (entry): entry is RumFirstInputTiming =>\n        entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp\n    )\n    if (firstInputEntry) {\n      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n        firstInputTime: firstInputEntry.startTime,\n        firstInputTarget: firstInputEntry.target,\n      })\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n","export function getScrollX() {\n  let scrollX\n  const visual = window.visualViewport\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX\n  } else {\n    scrollX = window.pageXOffset || 0\n  }\n  return Math.round(scrollX)\n}\n\nexport function getScrollY() {\n  let scrollY\n  const visual = window.visualViewport\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY\n  } else {\n    scrollY = window.pageYOffset || 0\n  }\n  return Math.round(scrollY)\n}\n","import type { ClocksState, Duration, Observable, RelativeTime } from '@datadog/browser-core'\nimport {\n  DOM_EVENT,\n  ONE_SECOND,\n  addEventListener,\n  elapsed,\n  noop,\n  relativeNow,\n  round,\n  throttle,\n  find,\n} from '@datadog/browser-core'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\n\nimport { getScrollY } from '../../../browser/scroll'\nimport { getViewportDimension } from '../../../browser/viewportObservable'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\nexport interface ScrollMetrics {\n  maxDepth: number\n  maxDepthScrollHeight: number\n  maxDepthScrollTop: number\n  maxDepthTime: Duration\n}\n\n/** Arbitrary scroll throttle duration */\nexport const THROTTLE_SCROLL_DURATION = ONE_SECOND\n\nexport interface ViewMetrics {\n  loadingTime?: Duration\n  cumulativeLayoutShift?: number\n}\n\nexport function trackViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug\n) {\n  const viewMetrics: ViewMetrics = {}\n\n  let scrollMetrics: ScrollMetrics | undefined\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      viewMetrics.loadingTime = newLoadingTime\n\n      // We compute scroll metrics at loading time to ensure we have scroll data when loading the view initially\n      // This is to ensure that we have the depth data even if the user didn't scroll or if the view is not scrollable.\n      const { scrollHeight, scrollDepth, scrollTop } = computeScrollValues()\n\n      scrollMetrics = {\n        maxDepth: scrollDepth,\n        maxDepthScrollHeight: scrollHeight,\n        maxDepthTime: newLoadingTime,\n        maxDepthScrollTop: scrollTop,\n      }\n      scheduleViewUpdate()\n    }\n  )\n\n  const { stop: stopScrollMetricsTracking } = trackScrollMetrics(\n    configuration,\n    viewStart,\n    (newScrollMetrics) => {\n      scrollMetrics = newScrollMetrics\n    },\n    computeScrollValues\n  )\n\n  let stopCLSTracking: () => void\n  let clsAttributionCollected = false\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0\n    ;({ stop: stopCLSTracking } = trackCumulativeLayoutShift(\n      lifeCycle,\n      (cumulativeLayoutShift, largestLayoutShiftNode, largestLayoutShiftTime) => {\n        viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n\n        if (!clsAttributionCollected) {\n          clsAttributionCollected = true\n          webVitalTelemetryDebug.addWebVitalTelemetryDebug('CLS', largestLayoutShiftNode, largestLayoutShiftTime)\n        }\n        scheduleViewUpdate()\n      }\n    ))\n  } else {\n    stopCLSTracking = noop\n  }\n\n  return {\n    stop: () => {\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n      stopScrollMetricsTracking()\n    },\n    setLoadEvent,\n    viewMetrics,\n    getScrollMetrics: () => scrollMetrics,\n  }\n}\n\nexport function trackScrollMetrics(\n  configuration: RumConfiguration,\n  viewStart: ClocksState,\n  callback: (scrollMetrics: ScrollMetrics) => void,\n  getScrollValues = computeScrollValues\n) {\n  let maxDepth = 0\n  const handleScrollEvent = throttle(\n    () => {\n      const { scrollHeight, scrollDepth, scrollTop } = getScrollValues()\n\n      if (scrollDepth > maxDepth) {\n        const now = relativeNow()\n        const maxDepthTime = elapsed(viewStart.relative, now)\n        maxDepth = scrollDepth\n        callback({\n          maxDepth,\n          maxDepthScrollHeight: scrollHeight,\n          maxDepthTime,\n          maxDepthScrollTop: scrollTop,\n        })\n      }\n    },\n    THROTTLE_SCROLL_DURATION,\n    { leading: false, trailing: true }\n  )\n\n  const { stop } = addEventListener(configuration, window, DOM_EVENT.SCROLL, handleScrollEvent.throttled, {\n    passive: true,\n  })\n\n  return {\n    stop: () => {\n      handleScrollEvent.cancel()\n      stop()\n    },\n  }\n}\n\nfunction computeScrollValues() {\n  const scrollTop = getScrollY()\n\n  const { height } = getViewportDimension()\n\n  const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight)\n  const scrollDepth = Math.round(height + scrollTop)\n\n  return {\n    scrollHeight,\n    scrollDepth,\n    scrollTop,\n  }\n}\n\nfunction trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max(...loadingTimeCandidates) as Duration)\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, (event) => {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n      }\n      invokeCallbackIfAllCandidatesAreReceived()\n    }\n  })\n\n  return {\n    stop,\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(\n  lifeCycle: LifeCycle,\n  callback: (layoutShift: number, largestShiftNode: Node | undefined, largestShiftTime: RelativeTime) => void\n) {\n  let maxClsValue = 0\n\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n        window.update(entry)\n\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value()\n          callback(round(maxClsValue, 4), window.largestLayoutShiftNode(), window.largestLayoutShiftTime())\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction slidingSessionWindow() {\n  let value = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n\n  let largestLayoutShift = 0\n  let largestLayoutShiftNode: Node | undefined\n  let largestLayoutShiftTime: RelativeTime\n\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= ONE_SECOND ||\n        entry.startTime - startTime >= 5 * ONE_SECOND\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        value = entry.value\n        largestLayoutShift = 0\n        largestLayoutShiftNode = undefined\n      } else {\n        value += entry.value\n        endTime = entry.startTime\n      }\n\n      if (entry.value > largestLayoutShift) {\n        largestLayoutShift = entry.value\n        largestLayoutShiftTime = entry.startTime\n\n        if (entry.sources?.length) {\n          const largestLayoutShiftSource = find(entry.sources, (s) => s.node?.nodeType === 1) || entry.sources[0]\n          largestLayoutShiftNode = largestLayoutShiftSource.node\n        } else {\n          largestLayoutShiftNode = undefined\n        }\n      }\n    },\n    value: () => value,\n    largestLayoutShiftNode: () => largestLayoutShiftNode,\n    largestLayoutShiftTime: () => largestLayoutShiftTime,\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift')\n}\n","import { ONE_MINUTE, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\n\n// Some events are not being counted as they transcend views. To reduce the occurrence;\n// an arbitrary delay is added for stopping event counting after the view ends.\n//\n// Ideally, we would not stop and keep counting events until the end of the session.\n// But this might have a small performance impact if there are many many views:\n// we would need to go through each event to see if the related view matches.\n// So let's have a fairly short delay to avoid impacting performances too much.\n//\n// In the future, we could have views stored in a data structure similar to ContextHistory. Whenever\n// a child event is collected, we could look into this history to find the matching view and\n// increase the associated and increase its counter. Having a centralized data structure for it\n// would allow us to look for views more efficiently.\n//\n// For now, having a small cleanup delay will already improve the situation in most cases.\n\nexport const KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY = 5 * ONE_MINUTE\n\nexport function trackViewEventCounts(lifeCycle: LifeCycle, viewId: string, onChange: () => void) {\n  const { stop, eventCounts } = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) => event.view.id === viewId,\n    onChange,\n  })\n\n  return {\n    scheduleStop: () => {\n      setTimeout(stop, KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY)\n    },\n    eventCounts,\n  }\n}\n","import type { Duration, ClocksState, TimeStamp, Observable, Subscription, RelativeTime } from '@datadog/browser-core'\nimport {\n  noop,\n  PageExitReason,\n  shallowClone,\n  assign,\n  elapsed,\n  generateUUID,\n  ONE_MINUTE,\n  throttle,\n  clocksNow,\n  clocksOrigin,\n  timeStampNow,\n  display,\n  looksLikeRelativeTime,\n  setInterval,\n  clearInterval,\n} from '@datadog/browser-core'\n\nimport type { ViewCustomTimings } from '../../../rawRumEvent.types'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { EventCounts } from '../../trackEventCounts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { Timings } from './trackInitialViewTimings'\nimport { trackInitialViewTimings } from './trackInitialViewTimings'\nimport type { ScrollMetrics } from './trackViewMetrics'\nimport { trackViewMetrics } from './trackViewMetrics'\nimport { trackViewEventCounts } from './trackViewEventCounts'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\nexport interface ViewEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  location: Readonly<Location>\n  timings: Timings\n  customTimings: ViewCustomTimings\n  eventCounts: EventCounts\n  documentVersion: number\n  startClocks: ClocksState\n  duration: Duration\n  isActive: boolean\n  sessionIsActive: boolean\n  loadingTime?: Duration\n  loadingType: ViewLoadingType\n  cumulativeLayoutShift?: number\n  scrollMetrics?: ScrollMetrics\n}\n\nexport interface ViewCreatedEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewEndedEvent {\n  endClocks: ClocksState\n}\n\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE\n\nexport interface ViewOptions {\n  name?: string\n  service?: string\n  version?: string\n}\n\nexport function trackViews(\n  location: Location,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  locationChangeObservable: Observable<LocationChange>,\n  areViewsTrackedAutomatically: boolean,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  initialViewOptions?: ViewOptions\n) {\n  let currentView = startNewView(ViewLoadingType.INITIAL_LOAD, clocksOrigin(), initialViewOptions)\n\n  startViewLifeCycle()\n\n  let locationChangeSubscription: Subscription\n  if (areViewsTrackedAutomatically) {\n    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable)\n  }\n\n  function startNewView(loadingType: ViewLoadingType, startClocks?: ClocksState, viewOptions?: ViewOptions) {\n    return newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      loadingType,\n      webVitalTelemetryDebug,\n      startClocks,\n      viewOptions\n    )\n  }\n\n  function startViewLifeCycle() {\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n      // Renew view on session renewal\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, undefined, {\n        name: currentView.name,\n        service: currentView.service,\n        version: currentView.version,\n      })\n    })\n\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n      currentView.end({ sessionIsActive: false })\n    })\n\n    // End the current view on page unload\n    lifeCycle.subscribe(LifeCycleEventType.PAGE_EXITED, (pageExitEvent) => {\n      if (pageExitEvent.reason === PageExitReason.UNLOADING || pageExitEvent.reason === PageExitReason.PAGEHIDE) {\n        currentView.end()\n      }\n    })\n  }\n\n  function renewViewOnLocationChange(locationChangeObservable: Observable<LocationChange>) {\n    return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n      if (areDifferentLocation(oldLocation, newLocation)) {\n        currentView.end()\n        currentView = startNewView(ViewLoadingType.ROUTE_CHANGE)\n      }\n    })\n  }\n\n  return {\n    addTiming: (name: string, time: RelativeTime | TimeStamp = timeStampNow()) => {\n      currentView.addTiming(name, time)\n    },\n    startView: (options?: ViewOptions, startClocks?: ClocksState) => {\n      currentView.end({ endClocks: startClocks })\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, startClocks, options)\n    },\n    stop: () => {\n      locationChangeSubscription?.unsubscribe()\n      currentView.end()\n    },\n  }\n}\n\nfunction newView(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  initialLocation: Location,\n  loadingType: ViewLoadingType,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  startClocks: ClocksState = clocksNow(),\n  viewOptions?: ViewOptions\n) {\n  // Setup initial values\n  const id = generateUUID()\n  const customTimings: ViewCustomTimings = {}\n  let documentVersion = 0\n  let endClocks: ClocksState | undefined\n  const location = shallowClone(initialLocation)\n\n  let sessionIsActive = true\n  let name: string | undefined\n  let service: string | undefined\n  let version: string | undefined\n  if (viewOptions) {\n    name = viewOptions.name\n    service = viewOptions.service\n    version = viewOptions.version\n  }\n\n  lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, {\n    id,\n    name,\n    startClocks,\n    service,\n    version,\n  })\n\n  // Update the view every time the measures are changing\n  const { throttled: scheduleViewUpdate, cancel: cancelScheduleViewUpdate } = throttle(\n    triggerViewUpdate,\n    THROTTLE_VIEW_UPDATE_PERIOD,\n    {\n      leading: false,\n    }\n  )\n\n  const {\n    setLoadEvent,\n    stop: stopViewMetricsTracking,\n    viewMetrics,\n    getScrollMetrics,\n  } = trackViewMetrics(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    scheduleViewUpdate,\n    loadingType,\n    startClocks,\n    webVitalTelemetryDebug\n  )\n\n  const { scheduleStop: scheduleStopInitialViewTimingsTracking, timings } =\n    loadingType === ViewLoadingType.INITIAL_LOAD\n      ? trackInitialViewTimings(lifeCycle, configuration, webVitalTelemetryDebug, setLoadEvent, scheduleViewUpdate)\n      : { scheduleStop: noop, timings: {} as Timings }\n\n  const { scheduleStop: scheduleStopEventCountsTracking, eventCounts } = trackViewEventCounts(\n    lifeCycle,\n    id,\n    scheduleViewUpdate\n  )\n\n  // Session keep alive\n  const keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL)\n\n  // Initial view update\n  triggerViewUpdate()\n\n  function triggerViewUpdate() {\n    cancelScheduleViewUpdate()\n    documentVersion += 1\n    const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp\n\n    lifeCycle.notify(\n      LifeCycleEventType.VIEW_UPDATED,\n      assign(\n        {\n          customTimings,\n          documentVersion,\n          id,\n          name,\n          service,\n          version,\n          loadingType,\n          location,\n          startClocks,\n          timings,\n          duration: elapsed(startClocks.timeStamp, currentEnd),\n          isActive: endClocks === undefined,\n          sessionIsActive,\n          eventCounts,\n          scrollMetrics: getScrollMetrics(),\n        },\n        viewMetrics\n      )\n    )\n  }\n\n  return {\n    name,\n    service,\n    version,\n    end(options: { endClocks?: ClocksState; sessionIsActive?: boolean } = {}) {\n      if (endClocks) {\n        // view already ended\n        return\n      }\n      endClocks = options.endClocks ?? clocksNow()\n      sessionIsActive = options.sessionIsActive ?? true\n\n      lifeCycle.notify(LifeCycleEventType.VIEW_ENDED, { endClocks })\n      clearInterval(keepAliveIntervalId)\n      stopViewMetricsTracking()\n      scheduleStopInitialViewTimingsTracking()\n      scheduleStopEventCountsTracking()\n      triggerViewUpdate()\n    },\n    addTiming(name: string, time: RelativeTime | TimeStamp) {\n      if (endClocks) {\n        return\n      }\n      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time)\n      customTimings[sanitizeTiming(name)] = relativeTime\n      scheduleViewUpdate()\n    },\n  }\n}\n\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name: string) {\n  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_')\n  if (sanitized !== name) {\n    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`)\n  }\n  return sanitized\n}\n\nfunction areDifferentLocation(currentLocation: Location, otherLocation: Location) {\n  return (\n    currentLocation.pathname !== otherLocation.pathname ||\n    (!isHashAnAnchor(otherLocation.hash) &&\n      getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash))\n  )\n}\n\nfunction isHashAnAnchor(hash: string) {\n  const correspondingId = hash.substr(1)\n  return !!document.getElementById(correspondingId)\n}\n\nfunction getPathFromHash(hash: string) {\n  const index = hash.indexOf('?')\n  return index < 0 ? hash : hash.slice(0, index)\n}\n","import type { Duration, ServerDuration, Observable } from '@datadog/browser-core'\nimport {\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n  isEmptyObject,\n  mapValues,\n  toServerDuration,\n  isNumber,\n} from '@datadog/browser-core'\nimport type { RecorderApi } from '../../../boot/rumPublicApi'\nimport type { RawRumViewEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { mapToForegroundPeriods } from '../../contexts/foregroundContexts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { FeatureFlagContexts } from '../../contexts/featureFlagContext'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport type { ViewEvent, ViewOptions } from './trackViews'\nimport { trackViews } from './trackViews'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\nexport function startViewCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  domMutationObservable: Observable<void>,\n  locationChangeObservable: Observable<LocationChange>,\n  featureFlagContexts: FeatureFlagContexts,\n  pageStateHistory: PageStateHistory,\n  recorderApi: RecorderApi,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  initialViewOptions?: ViewOptions\n) {\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, (view) =>\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processViewUpdate(view, configuration, featureFlagContexts, recorderApi, pageStateHistory)\n    )\n  )\n  const trackViewResult = trackViews(\n    location,\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    locationChangeObservable,\n    !configuration.trackViewsManually,\n    webVitalTelemetryDebug,\n    initialViewOptions\n  )\n\n  return trackViewResult\n}\n\nfunction processViewUpdate(\n  view: ViewEvent,\n  configuration: RumConfiguration,\n  featureFlagContexts: FeatureFlagContexts,\n  recorderApi: RecorderApi,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumViewEvent> {\n  const replayStats = recorderApi.getReplayStats(view.id)\n  const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(view.startClocks.relative)\n  const pageStatesEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGE_STATES)\n  const pageStates = pageStateHistory.findAll(view.startClocks.relative, view.duration)\n  const viewEvent: RawRumViewEvent = {\n    _dd: {\n      document_version: view.documentVersion,\n      replay_stats: replayStats,\n      page_states: pageStatesEnabled ? pageStates : undefined,\n    },\n    date: view.startClocks.timeStamp,\n    type: RumEventType.VIEW,\n    view: {\n      action: {\n        count: view.eventCounts.actionCount,\n      },\n      frustration: {\n        count: view.eventCounts.frustrationCount,\n      },\n      cumulative_layout_shift: view.cumulativeLayoutShift,\n      first_byte: toServerDuration(view.timings.firstByte),\n      dom_complete: toServerDuration(view.timings.domComplete),\n      dom_content_loaded: toServerDuration(view.timings.domContentLoaded),\n      dom_interactive: toServerDuration(view.timings.domInteractive),\n      error: {\n        count: view.eventCounts.errorCount,\n      },\n      first_contentful_paint: toServerDuration(view.timings.firstContentfulPaint),\n      first_input_delay: toServerDuration(view.timings.firstInputDelay),\n      first_input_time: toServerDuration(view.timings.firstInputTime),\n      is_active: view.isActive,\n      name: view.name,\n      largest_contentful_paint: toServerDuration(view.timings.largestContentfulPaint),\n      load_event: toServerDuration(view.timings.loadEvent),\n      loading_time: discardNegativeDuration(toServerDuration(view.loadingTime)),\n      loading_type: view.loadingType,\n      long_task: {\n        count: view.eventCounts.longTaskCount,\n      },\n      resource: {\n        count: view.eventCounts.resourceCount,\n      },\n      time_spent: toServerDuration(view.duration),\n      in_foreground_periods:\n        !pageStatesEnabled && pageStates ? mapToForegroundPeriods(pageStates, view.duration) : undefined, // Todo: Remove in the next major release\n    },\n    feature_flags: featureFlagContext && !isEmptyObject(featureFlagContext) ? featureFlagContext : undefined,\n    display: view.scrollMetrics\n      ? {\n          scroll: {\n            max_depth: view.scrollMetrics.maxDepth,\n            max_depth_scroll_height: view.scrollMetrics.maxDepthScrollHeight,\n            max_depth_scroll_top: view.scrollMetrics.maxDepthScrollTop,\n            max_depth_time: toServerDuration(view.scrollMetrics.maxDepthTime),\n          },\n        }\n      : undefined,\n    session: {\n      has_replay: replayStats ? true : undefined,\n      is_active: view.sessionIsActive ? undefined : false,\n    },\n    privacy: {\n      replay_level: configuration.defaultPrivacyLevel,\n    },\n  }\n  if (!isEmptyObject(view.customTimings)) {\n    viewEvent.view.custom_timings = mapValues(\n      view.customTimings,\n      toServerDuration as (duration: Duration) => ServerDuration\n    )\n  }\n  return {\n    rawRumEvent: viewEvent,\n    startTime: view.startClocks.relative,\n    domainContext: {\n      location: view.location,\n    },\n  }\n}\n\nfunction discardNegativeDuration(duration: ServerDuration | undefined): ServerDuration | undefined {\n  return isNumber(duration) && duration < 0 ? undefined : duration\n}\n","import type { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { ValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport type { Configuration } from '../configuration'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  configuration: Configuration,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionManager<TrackingType> {\n  // TODO - Improve configuration type and remove assertion\n  const sessionStore = startSessionStore(configuration.sessionStoreStrategyType!, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ValueHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackActivity(configuration, () => sessionStore.expandOrRenewSession())\n  trackVisibility(configuration, () => sessionStore.expandSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable: sessionStore.renewObservable,\n    expireObservable: sessionStore.expireObservable,\n    expire: sessionStore.expire,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(configuration: Configuration, expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(configuration: Configuration, expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { Observable, noop, performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const RUM_SESSION_KEY = 'rum'\n\nexport interface RumSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => RumSession | undefined\n  expire: () => void\n  expireObservable: Observable<void>\n}\n\nexport type RumSession = {\n  id: string\n  plan: RumSessionPlan\n  sessionReplayAllowed: boolean\n  longTaskAllowed: boolean\n  resourceAllowed: boolean\n}\n\nexport const enum RumSessionPlan {\n  WITHOUT_SESSION_REPLAY = 1,\n  WITH_SESSION_REPLAY = 2,\n}\n\nexport const enum RumTrackingType {\n  NOT_TRACKED = '0',\n  // Note: the \"tracking type\" value (stored in the session cookie) does not match the \"session\n  // plan\" value (sent in RUM events). This is expected, and was done to keep retrocompatibility\n  // with active sessions when upgrading the SDK.\n  TRACKED_WITH_SESSION_REPLAY = '1',\n  TRACKED_WITHOUT_SESSION_REPLAY = '2',\n}\n\nexport function startRumSessionManager(configuration: RumConfiguration, lifeCycle: LifeCycle): RumSessionManager {\n  const sessionManager = startSessionManager(configuration, RUM_SESSION_KEY, (rawTrackingType) =>\n    computeSessionState(configuration, rawTrackingType)\n  )\n\n  sessionManager.expireObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_EXPIRED)\n  })\n\n  sessionManager.renewObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_RENEWED)\n  })\n\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      if (!session || !isTypeTracked(session.trackingType)) {\n        return\n      }\n      const plan =\n        session.trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n          ? RumSessionPlan.WITH_SESSION_REPLAY\n          : RumSessionPlan.WITHOUT_SESSION_REPLAY\n      return {\n        id: session.id,\n        plan,\n        sessionReplayAllowed: plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        longTaskAllowed:\n          configuration.trackLongTasks !== undefined\n            ? configuration.trackLongTasks\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        resourceAllowed:\n          configuration.trackResources !== undefined\n            ? configuration.trackResources\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n      }\n    },\n    expire: sessionManager.expire,\n    expireObservable: sessionManager.expireObservable,\n  }\n}\n\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub(): RumSessionManager {\n  const session: RumSession = {\n    id: '00000000-aaaa-0000-aaaa-000000000000',\n    plan: RumSessionPlan.WITHOUT_SESSION_REPLAY, // plan value should not be taken into account for mobile\n    sessionReplayAllowed: false,\n    longTaskAllowed: true,\n    resourceAllowed: true,\n  }\n  return {\n    findTrackedSession: () => session,\n    expire: noop,\n    expireObservable: new Observable(),\n  }\n}\n\nfunction computeSessionState(configuration: RumConfiguration, rawTrackingType?: string) {\n  let trackingType: RumTrackingType\n  if (hasValidRumSession(rawTrackingType)) {\n    trackingType = rawTrackingType\n  } else if (!performDraw(configuration.sessionSampleRate)) {\n    trackingType = RumTrackingType.NOT_TRACKED\n  } else if (!performDraw(configuration.sessionReplaySampleRate)) {\n    trackingType = RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  } else {\n    trackingType = RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  }\n  return {\n    trackingType,\n    isTracked: isTypeTracked(trackingType),\n  }\n}\n\nfunction hasValidRumSession(trackingType?: string): trackingType is RumTrackingType {\n  return (\n    trackingType === RumTrackingType.NOT_TRACKED ||\n    trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY ||\n    trackingType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  )\n}\n\nfunction isTypeTracked(rumSessionType: RumTrackingType | undefined) {\n  return (\n    rumSessionType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY ||\n    rumSessionType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  )\n}\n","import type { PageExitEvent, PageExitReason } from '../browser/pageExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageExitObservable: Observable<PageExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const flushObservable = new Observable<FlushEvent>()\n\n  pageExitObservable.subscribe((event) => flush(event.reason))\n  sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     */\n    notifyBeforeAddMessage(messageBytesCount: number) {\n      if (currentBytesCount + messageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += messageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     */\n    notifyAfterAddMessage() {\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n","import { display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageExitObservable'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { HttpRequest } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport class Batch {\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n\n  constructor(\n    private request: HttpRequest,\n    private flushController: FlushController,\n    private messageBytesLimit: number\n  ) {\n    this.flushController.flushObservable.subscribe((event) => this.flush(event))\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  private flush(event: FlushEvent) {\n    const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n\n    this.pushOnlyBuffer = []\n    this.upsertBuffer = {}\n\n    const payload = { data: messages.join('\\n'), bytesCount: event.bytesCount, flushReason: event.reason }\n    if (isPageExitReason(event.reason)) {\n      this.request.sendOnExit(payload)\n    } else {\n      this.request.send(payload)\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    // If there are other messages, a '\\n' will be added at serialization\n    const separatorBytesCount = this.flushController.messagesCount > 0 ? 1 : 0\n\n    this.flushController.notifyBeforeAddMessage(messageBytesCount + separatorBytesCount)\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.flushController.notifyAfterAddMessage()\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = computeBytesCount(removedMessage)\n    // If there are other messages, a '\\n' will be added at serialization\n    const separatorBytesCount = this.flushController.messagesCount > 1 ? 1 : 0\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount + separatorBytesCount)\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n}\n","import type { EndpointType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder, Configuration } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor } from '../tools/monitor'\nimport { addEventListener } from '../browser/addEventListener'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\nimport type { FlushReason } from './flushController'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData\n  bytesCount: number\n  retry?: RetryInfo\n  flushReason?: FlushReason\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount, flushReason }: Payload\n) {\n  const canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', flushReason)\n      const isQueued = navigator.sendBeacon(beaconUrl, data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  const xhrUrl = endpointBuilder.build('xhr', flushReason)\n  sendXHR(configuration, xhrUrl, data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount, flushReason, retry }: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch', flushReason, retry)\n    fetch(fetchUrl, { method: 'POST', body: data, keepalive: true, mode: 'cors' }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })),\n      monitor(() => {\n        const xhrUrl = endpointBuilder.build('xhr', flushReason, retry)\n        // failed to queue the request\n        sendXHR(configuration, xhrUrl, data, onResponse)\n      })\n    )\n  } else {\n    const xhrUrl = endpointBuilder.build('xhr', flushReason, retry)\n    sendXHR(configuration, xhrUrl, data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(\n  configuration: Configuration,\n  url: string,\n  data: Payload['data'],\n  onResponse?: (r: HttpResponse) => void\n) {\n  const request = new XMLHttpRequest()\n  request.open('POST', url, true)\n  addEventListener(\n    configuration,\n    request,\n    'loadend',\n    () => {\n      onResponse?.({ status: request.status })\n    },\n    {\n      // prevent multiple onResponse callbacks\n      // if the xhr instance is reused by a third party\n      once: true,\n    }\n  )\n  request.send(data)\n}\n","import type {\n  Context,\n  EndpointBuilder,\n  TelemetryEvent,\n  Observable,\n  RawError,\n  PageExitEvent,\n  FlushEvent,\n} from '@datadog/browser-core'\nimport {\n  createFlushController,\n  Batch,\n  combine,\n  createHttpRequest,\n  isTelemetryReplicationAllowed,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  telemetryEventObservable: Observable<TelemetryEvent & Context>,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const batch = makeRumBatch(configuration, reportError, pageExitObservable, sessionExpireObservable)\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    if (serverRumEvent.type === RumEventType.VIEW) {\n      batch.upsert(serverRumEvent, serverRumEvent.view.id)\n    } else {\n      batch.add(serverRumEvent)\n    }\n  })\n\n  telemetryEventObservable.subscribe((event) => batch.add(event, isTelemetryReplicationAllowed(configuration)))\n\n  return batch\n}\n\nexport interface RumBatch {\n  flushObservable: Observable<FlushEvent>\n  add: (message: Context, replicated?: boolean) => void\n  upsert: (message: Context, key: string) => void\n}\n\nfunction makeRumBatch(\n  configuration: RumConfiguration,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n): RumBatch {\n  const { batch: primaryBatch, flushController: primaryFlushController } = createRumBatch(\n    configuration.rumEndpointBuilder\n  )\n  let replicaBatch: Batch | undefined\n  const replica = configuration.replica\n  if (replica !== undefined) {\n    replicaBatch = createRumBatch(replica.rumEndpointBuilder).batch\n  }\n\n  function createRumBatch(endpointBuilder: EndpointBuilder) {\n    const flushController = createFlushController({\n      messagesLimit: configuration.batchMessagesLimit,\n      bytesLimit: configuration.batchBytesLimit,\n      durationLimit: configuration.flushTimeout,\n      pageExitObservable,\n      sessionExpireObservable,\n    })\n\n    const batch = new Batch(\n      createHttpRequest(configuration, endpointBuilder, configuration.batchBytesLimit, reportError),\n      flushController,\n      configuration.messageBytesLimit\n    )\n\n    return {\n      batch,\n      flushController,\n    }\n  }\n\n  function withReplicaApplicationId(message: Context) {\n    return combine(message, { application: { id: replica!.applicationId } })\n  }\n\n  return {\n    flushObservable: primaryFlushController.flushObservable,\n    add: (message: Context, replicated = true) => {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(withReplicaApplicationId(message))\n      }\n    },\n    upsert: (message: Context, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(withReplicaApplicationId(message), key)\n      }\n    },\n  }\n}\n","import type { RelativeTime, Observable } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, relativeNow, ValueHistory } from '@datadog/browser-core'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\n\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface UrlContext {\n  url: string\n  referrer: string\n}\n\nexport interface UrlContexts {\n  findUrl: (startTime?: RelativeTime) => UrlContext | undefined\n  stop: () => void\n}\n\nexport function startUrlContexts(\n  lifeCycle: LifeCycle,\n  locationChangeObservable: Observable<LocationChange>,\n  location: Location\n) {\n  const urlContextHistory = new ValueHistory<UrlContext>(URL_CONTEXT_TIME_OUT_DELAY)\n\n  let previousViewUrl: string | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    urlContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, ({ startClocks }) => {\n    const viewUrl = location.href\n    urlContextHistory.add(\n      buildUrlContext({\n        url: viewUrl,\n        referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n      }),\n      startClocks.relative\n    )\n    previousViewUrl = viewUrl\n  })\n\n  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n    const current = urlContextHistory.find()\n    if (current) {\n      const changeTime = relativeNow()\n      urlContextHistory.closeActive(changeTime)\n      urlContextHistory.add(\n        buildUrlContext({\n          url: newLocation.href,\n          referrer: current.referrer,\n        }),\n        changeTime\n      )\n    }\n  })\n\n  function buildUrlContext({ url, referrer }: { url: string; referrer: string }) {\n    return {\n      url,\n      referrer,\n    }\n  }\n\n  return {\n    findUrl: (startTime?: RelativeTime) => urlContextHistory.find(startTime),\n    stop: () => {\n      locationChangeSubscription.unsubscribe()\n      urlContextHistory.stop()\n    },\n  }\n}\n","import {\n  addEventListener,\n  DOM_EVENT,\n  instrumentMethodAndCallOriginal,\n  Observable,\n  shallowClone,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\nexport interface LocationChange {\n  oldLocation: Readonly<Location>\n  newLocation: Readonly<Location>\n}\n\nexport function createLocationChangeObservable(configuration: RumConfiguration, location: Location) {\n  let currentLocation = shallowClone(location)\n  const observable = new Observable<LocationChange>(() => {\n    const { stop: stopHistoryTracking } = trackHistory(configuration, onLocationChange)\n    const { stop: stopHashTracking } = trackHash(configuration, onLocationChange)\n    return () => {\n      stopHistoryTracking()\n      stopHashTracking()\n    }\n  })\n\n  function onLocationChange() {\n    if (currentLocation.href === location.href) {\n      return\n    }\n    const newLocation = shallowClone(location)\n    observable.notify({\n      newLocation,\n      oldLocation: currentLocation,\n    })\n    currentLocation = newLocation\n  }\n\n  return observable\n}\n\nfunction trackHistory(configuration: RumConfiguration, onHistoryChange: () => void) {\n  const { stop: stopInstrumentingPushState } = instrumentMethodAndCallOriginal(history, 'pushState', {\n    after: onHistoryChange,\n  })\n  const { stop: stopInstrumentingReplaceState } = instrumentMethodAndCallOriginal(history, 'replaceState', {\n    after: onHistoryChange,\n  })\n  const { stop: removeListener } = addEventListener(configuration, window, DOM_EVENT.POP_STATE, onHistoryChange)\n\n  return {\n    stop: () => {\n      stopInstrumentingPushState()\n      stopInstrumentingReplaceState()\n      removeListener()\n    },\n  }\n}\n\nfunction trackHash(configuration: RumConfiguration, onHashChange: () => void) {\n  return addEventListener(configuration, window, DOM_EVENT.HASH_CHANGE, onHashChange)\n}\n","import type { RelativeTime, ContextValue, Context } from '@datadog/browser-core'\nimport {\n  CustomerDataType,\n  warnIfCustomerDataLimitReached,\n  throttle,\n  jsonStringify,\n  computeBytesCount,\n  noop,\n  isExperimentalFeatureEnabled,\n  SESSION_TIME_OUT_DELAY,\n  ValueHistory,\n  ExperimentalFeature,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\nexport const FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type FeatureFlagContext = Context\n\nexport interface FeatureFlagContexts {\n  findFeatureFlagEvaluations: (startTime?: RelativeTime) => FeatureFlagContext | undefined\n  getFeatureFlagBytesCount: () => number\n  addFeatureFlagEvaluation: (key: string, value: ContextValue) => void\n  stop: () => void\n}\n\n/**\n * Start feature flag contexts\n *\n * Feature flag contexts follow the life of views.\n * A new context is added when a view is created and ended when the view is ended\n *\n * Note: we choose not to add a new context at each evaluation to save memory\n */\nexport function startFeatureFlagContexts(\n  lifeCycle: LifeCycle,\n  computeBytesCountImpl = computeBytesCount\n): FeatureFlagContexts {\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.FEATURE_FLAGS)) {\n    return {\n      findFeatureFlagEvaluations: () => undefined,\n      getFeatureFlagBytesCount: () => 0,\n      addFeatureFlagEvaluation: noop,\n      stop: noop,\n    }\n  }\n\n  const featureFlagContexts = new ValueHistory<FeatureFlagContext>(FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY)\n  let bytesCountCache = 0\n  let alreadyWarned = false\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    featureFlagContexts.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, ({ startClocks }) => {\n    featureFlagContexts.add({}, startClocks.relative)\n    bytesCountCache = 0\n  })\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call addFeatureFlagEvaluation API synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled, cancel: cancelPendingComputation } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCountImpl(jsonStringify(context)!)\n    if (!alreadyWarned) {\n      alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, CustomerDataType.FeatureFlag)\n    }\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  return {\n    findFeatureFlagEvaluations: (startTime?: RelativeTime) => featureFlagContexts.find(startTime),\n    getFeatureFlagBytesCount: () => {\n      const currentContext = featureFlagContexts.find()\n      if (!currentContext) {\n        return 0\n      }\n\n      return bytesCountCache\n    },\n    addFeatureFlagEvaluation: (key: string, value: ContextValue) => {\n      const currentContext = featureFlagContexts.find()\n      if (currentContext) {\n        currentContext[key] = value\n        computeBytesCountThrottled(currentContext)\n      }\n    },\n    stop: cancelPendingComputation,\n  }\n}\n","import type { Context, ContextManager, FlushEvent, Observable, Telemetry } from '@datadog/browser-core'\nimport { isEmptyObject, includes, performDraw, ONE_SECOND, addTelemetryDebug, setInterval } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RumConfiguration } from './configuration'\nimport type { FeatureFlagContexts } from './contexts/featureFlagContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const MEASURES_PERIOD_DURATION = 10 * ONE_SECOND\n\ntype Measure = {\n  min: number\n  max: number\n  sum: number\n}\n\ntype CurrentPeriodMeasures = {\n  batchCount: number\n  batchBytesCount: Measure\n  batchMessagesCount: Measure\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\ntype CurrentBatchMeasures = {\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\nlet currentPeriodMeasures: CurrentPeriodMeasures\nlet currentBatchMeasures: CurrentBatchMeasures\nlet batchHasRumEvent: boolean\n\nexport function startCustomerDataTelemetry(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  lifeCycle: LifeCycle,\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  featureFlagContexts: FeatureFlagContexts,\n  batchFlushObservable: Observable<FlushEvent>\n) {\n  const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n  if (!customerDataTelemetryEnabled) {\n    return\n  }\n\n  initCurrentPeriodMeasures()\n  initCurrentBatchMeasures()\n\n  // We measure the data of every view updates even if there could only be one per batch due to the upsert\n  // It means that contexts bytes count sums can be higher than it really is\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event: RumEvent & Context) => {\n    batchHasRumEvent = true\n    updateMeasure(\n      currentBatchMeasures.globalContextBytes,\n      !isEmptyObject(globalContextManager.get()) ? globalContextManager.getBytesCount() : 0\n    )\n\n    updateMeasure(\n      currentBatchMeasures.userContextBytes,\n      !isEmptyObject(userContextManager.get()) ? userContextManager.getBytesCount() : 0\n    )\n\n    const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations()\n    const hasFeatureFlagContext =\n      includes([RumEventType.VIEW, RumEventType.ERROR], event.type) &&\n      featureFlagContext &&\n      !isEmptyObject(featureFlagContext)\n    updateMeasure(\n      currentBatchMeasures.featureFlagBytes,\n      hasFeatureFlagContext ? featureFlagContexts.getFeatureFlagBytesCount() : 0\n    )\n  })\n\n  batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {\n    // Don't measure batch that only contains telemetry events to avoid batch sending loop\n    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n    if (!batchHasRumEvent) {\n      return\n    }\n    currentPeriodMeasures.batchCount += 1\n    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount)\n    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount)\n    mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes)\n    mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes)\n    mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes)\n    initCurrentBatchMeasures()\n  })\n\n  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION)\n}\n\nfunction sendCurrentPeriodMeasures() {\n  if (currentPeriodMeasures.batchCount === 0) {\n    return\n  }\n\n  addTelemetryDebug('Customer data measures', currentPeriodMeasures)\n  initCurrentPeriodMeasures()\n}\n\nfunction createMeasure(): Measure {\n  return { min: Infinity, max: 0, sum: 0 }\n}\n\nfunction updateMeasure(measure: Measure, value: number) {\n  measure.sum += value\n  measure.min = Math.min(measure.min, value)\n  measure.max = Math.max(measure.max, value)\n}\n\nfunction mergeMeasure(target: Measure, source: Measure) {\n  target.sum += source.sum\n  target.min = Math.min(target.min, source.min)\n  target.max = Math.max(target.max, source.max)\n}\n\nfunction initCurrentPeriodMeasures() {\n  currentPeriodMeasures = {\n    batchCount: 0,\n    batchBytesCount: createMeasure(),\n    batchMessagesCount: createMeasure(),\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n\nfunction initCurrentBatchMeasures() {\n  batchHasRumEvent = false\n  currentBatchMeasures = {\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  elapsed,\n  ValueHistory,\n  SESSION_TIME_OUT_DELAY,\n  toServerDuration,\n  addEventListeners,\n  relativeNow,\n  DOM_EVENT,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { PageStateServerEntry } from '../../rawRumEvent.types'\n\n// Arbitrary value to cap number of element for memory consumption in the browser\nexport const MAX_PAGE_STATE_ENTRIES = 4000\n// Arbitrary value to cap number of element for backend & to save bandwidth\nexport const MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500\n\nexport const PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport const enum PageState {\n  ACTIVE = 'active',\n  PASSIVE = 'passive',\n  HIDDEN = 'hidden',\n  FROZEN = 'frozen',\n  TERMINATED = 'terminated',\n}\n\nexport type PageStateEntry = { state: PageState; startTime: RelativeTime }\n\nexport interface PageStateHistory {\n  findAll: (startTime: RelativeTime, duration: Duration) => PageStateServerEntry[] | undefined\n  isInActivePageStateAt: (startTime: RelativeTime) => boolean\n  addPageState(nextPageState: PageState, startTime?: RelativeTime): void\n  stop: () => void\n}\n\nexport function startPageStateHistory(\n  configuration: RumConfiguration,\n  maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE\n): PageStateHistory {\n  const pageStateHistory = new ValueHistory<PageStateEntry>(PAGE_STATE_CONTEXT_TIME_OUT_DELAY, MAX_PAGE_STATE_ENTRIES)\n\n  let currentPageState: PageState\n  addPageState(getPageState(), relativeNow())\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [\n      DOM_EVENT.PAGE_SHOW,\n      DOM_EVENT.FOCUS,\n      DOM_EVENT.BLUR,\n      DOM_EVENT.VISIBILITY_CHANGE,\n      DOM_EVENT.RESUME,\n      DOM_EVENT.FREEZE,\n      DOM_EVENT.PAGE_HIDE,\n    ],\n    (event) => {\n      // Only get events fired by the browser to avoid false currentPageState changes done with custom events\n      // cf: developer extension auto flush: https://github.com/DataDog/browser-sdk/blob/2f72bf05a672794c9e33965351964382a94c72ba/developer-extension/src/panel/flushEvents.ts#L11-L12\n      if (event.isTrusted) {\n        addPageState(computePageState(event), event.timeStamp as RelativeTime)\n      }\n    },\n    { capture: true }\n  )\n\n  function addPageState(nextPageState: PageState, startTime = relativeNow()) {\n    if (nextPageState === currentPageState) {\n      return\n    }\n\n    currentPageState = nextPageState\n    pageStateHistory.closeActive(startTime)\n    pageStateHistory.add({ state: currentPageState, startTime }, startTime)\n  }\n\n  return {\n    findAll: (eventStartTime: RelativeTime, duration: Duration): PageStateServerEntry[] | undefined => {\n      const pageStateEntries = pageStateHistory.findAll(eventStartTime, duration)\n\n      if (pageStateEntries.length === 0) {\n        return\n      }\n\n      const pageStateServerEntries = []\n      // limit the number of entries to return\n      const limit = Math.max(0, pageStateEntries.length - maxPageStateEntriesSelectable)\n\n      // loop page state entries backward to return the selected ones in desc order\n      for (let index = pageStateEntries.length - 1; index >= limit; index--) {\n        const pageState = pageStateEntries[index]\n        // compute the start time relative to the event start time (ex: to be relative to the view start time)\n        const relativeStartTime = elapsed(eventStartTime, pageState.startTime)\n\n        pageStateServerEntries.push({\n          state: pageState.state,\n          start: toServerDuration(relativeStartTime),\n        })\n      }\n\n      return pageStateServerEntries\n    },\n    isInActivePageStateAt: (startTime: RelativeTime) => {\n      const pageStateEntry = pageStateHistory.find(startTime)\n      return pageStateEntry !== undefined && pageStateEntry.state === PageState.ACTIVE\n    },\n    addPageState,\n    stop: () => {\n      stopEventListeners()\n      pageStateHistory.stop()\n    },\n  }\n}\n\nfunction computePageState(event: Event) {\n  if (event.type === DOM_EVENT.FREEZE) {\n    return PageState.FROZEN\n  } else if (event.type === DOM_EVENT.PAGE_HIDE) {\n    return (event as PageTransitionEvent).persisted ? PageState.FROZEN : PageState.TERMINATED\n  }\n  return getPageState()\n}\n\nfunction getPageState() {\n  if (document.visibilityState === 'hidden') {\n    return PageState.HIDDEN\n  }\n\n  if (document.hasFocus()) {\n    return PageState.ACTIVE\n  }\n\n  return PageState.PASSIVE\n}\n","import { INTAKE_SITE_STAGING, INTAKE_SITE_US1, INTAKE_SITE_EU1 } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { ViewContext } from './contexts/viewContexts'\nimport type { RumSession } from './rumSessionManager'\n\nexport function getSessionReplayUrl(\n  configuration: RumConfiguration,\n  {\n    session,\n    viewContext,\n    errorType,\n  }: {\n    session?: RumSession\n    viewContext?: ViewContext\n    errorType?: string\n  }\n): string {\n  const sessionId = session ? session.id : 'no-session-id'\n  const parameters: string[] = []\n  if (errorType !== undefined) {\n    parameters.push(`error-type=${errorType}`)\n  }\n  if (viewContext) {\n    parameters.push(`seed=${viewContext.id}`)\n    parameters.push(`from=${viewContext.startClocks.timeStamp}`)\n  }\n\n  const origin = getDatadogSiteUrl(configuration)\n  const path = `/rum/replay/sessions/${sessionId}`\n  return `${origin}${path}?${parameters.join('&')}`\n}\n\nexport function getDatadogSiteUrl(rumConfiguration: RumConfiguration) {\n  const site = rumConfiguration.site\n  const subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration)\n  return `https://${subdomain ? `${subdomain}.` : ''}${site}`\n}\n\nfunction getSiteDefaultSubdomain(configuration: RumConfiguration): string | undefined {\n  switch (configuration.site) {\n    case INTAKE_SITE_US1:\n    case INTAKE_SITE_EU1:\n      return 'app'\n    case INTAKE_SITE_STAGING:\n      return 'dd'\n    default:\n      return undefined\n  }\n}\n","import type * as SessionReplay from './sessionReplay'\n\nexport const RecordType: {\n  FullSnapshot: SessionReplay.BrowserFullSnapshotRecord['type']\n  IncrementalSnapshot: SessionReplay.BrowserIncrementalSnapshotRecord['type']\n  Meta: SessionReplay.MetaRecord['type']\n  Focus: SessionReplay.FocusRecord['type']\n  ViewEnd: SessionReplay.ViewEndRecord['type']\n  VisualViewport: SessionReplay.VisualViewportRecord['type']\n  FrustrationRecord: SessionReplay.FrustrationRecord['type']\n} = {\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Focus: 6,\n  ViewEnd: 7,\n  VisualViewport: 8,\n  FrustrationRecord: 9,\n} as const\n\nexport type RecordType = (typeof RecordType)[keyof typeof RecordType]\n\nexport const NodeType: {\n  Document: SessionReplay.DocumentNode['type']\n  DocumentType: SessionReplay.DocumentTypeNode['type']\n  Element: SessionReplay.ElementNode['type']\n  Text: SessionReplay.TextNode['type']\n  CDATA: SessionReplay.CDataNode['type']\n  DocumentFragment: SessionReplay.DocumentFragmentNode['type']\n} = {\n  Document: 0,\n  DocumentType: 1,\n  Element: 2,\n  Text: 3,\n  CDATA: 4,\n  DocumentFragment: 11,\n} as const\n\nexport type NodeType = (typeof NodeType)[keyof typeof NodeType]\n\nexport const IncrementalSource: {\n  Mutation: SessionReplay.BrowserMutationData['source']\n  MouseMove: Exclude<SessionReplay.MousemoveData['source'], 6>\n  MouseInteraction: SessionReplay.MouseInteractionData['source']\n  Scroll: SessionReplay.ScrollData['source']\n  ViewportResize: SessionReplay.ViewportResizeData['source']\n  Input: SessionReplay.InputData['source']\n  TouchMove: Exclude<SessionReplay.MousemoveData['source'], 1>\n  MediaInteraction: SessionReplay.MediaInteractionData['source']\n  StyleSheetRule: SessionReplay.StyleSheetRuleData['source']\n} = {\n  Mutation: 0,\n  MouseMove: 1,\n  MouseInteraction: 2,\n  Scroll: 3,\n  ViewportResize: 4,\n  Input: 5,\n  TouchMove: 6,\n  MediaInteraction: 7,\n  StyleSheetRule: 8,\n  // CanvasMutation : 9,\n  // Font : 10,\n} as const\n\nexport type IncrementalSource = (typeof IncrementalSource)[keyof typeof IncrementalSource]\n\nexport const MouseInteractionType = {\n  MouseUp: 0,\n  MouseDown: 1,\n  Click: 2,\n  ContextMenu: 3,\n  DblClick: 4,\n  Focus: 5,\n  Blur: 6,\n  TouchStart: 7,\n  TouchEnd: 9,\n} as const\n\nexport type MouseInteractionType = (typeof MouseInteractionType)[keyof typeof MouseInteractionType]\n\nexport const MediaInteractionType = {\n  Play: 0,\n  Pause: 1,\n} as const\n\nexport type MediaInteractionType = (typeof MediaInteractionType)[keyof typeof MediaInteractionType]\n","import { assign, timeStampNow } from '@datadog/browser-core'\nimport type { BrowserIncrementalData, BrowserIncrementalSnapshotRecord } from '../../types'\nimport { RecordType } from '../../types'\n\nexport function assembleIncrementalSnapshot<Data extends BrowserIncrementalData>(\n  source: Data['source'],\n  data: Omit<Data, 'source'>\n): BrowserIncrementalSnapshotRecord {\n  return {\n    data: assign(\n      {\n        source,\n      },\n      data\n    ) as Data,\n    type: RecordType.IncrementalSnapshot,\n    timestamp: timeStampNow(),\n  }\n}\n","import { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nexport const NodePrivacyLevel = {\n  IGNORE: 'ignore',\n  HIDDEN: 'hidden',\n  ALLOW: DefaultPrivacyLevel.ALLOW,\n  MASK: DefaultPrivacyLevel.MASK,\n  MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n} as const\nexport type NodePrivacyLevel = (typeof NodePrivacyLevel)[keyof typeof NodePrivacyLevel]\n\nexport const PRIVACY_ATTR_NAME = 'data-dd-privacy'\n\n// Privacy Attrs\nexport const PRIVACY_ATTR_VALUE_ALLOW = 'allow'\nexport const PRIVACY_ATTR_VALUE_MASK = 'mask'\nexport const PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input'\nexport const PRIVACY_ATTR_VALUE_HIDDEN = 'hidden'\n\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport const PRIVACY_CLASS_ALLOW = 'dd-privacy-allow'\nexport const PRIVACY_CLASS_MASK = 'dd-privacy-mask'\nexport const PRIVACY_CLASS_MASK_USER_INPUT = 'dd-privacy-mask-user-input'\nexport const PRIVACY_CLASS_HIDDEN = 'dd-privacy-hidden'\n\n// Private Replacement Templates\nexport const CENSORED_STRING_MARK = '***'\nexport const CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=='\n\nexport const FORM_PRIVATE_TAG_NAMES: { [tagName: string]: true } = {\n  INPUT: true,\n  OUTPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n  OPTION: true,\n  DATALIST: true,\n  OPTGROUP: true,\n}\n","import { isElementNode, getParentNode, isTextNode } from '@datadog/browser-rum-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_ALLOW,\n  PRIVACY_ATTR_VALUE_MASK,\n  PRIVACY_ATTR_VALUE_MASK_USER_INPUT,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  PRIVACY_CLASS_ALLOW,\n  PRIVACY_CLASS_MASK,\n  PRIVACY_CLASS_MASK_USER_INPUT,\n  PRIVACY_CLASS_HIDDEN,\n  FORM_PRIVATE_TAG_NAMES,\n  CENSORED_STRING_MARK,\n} from '../../constants'\n\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100_000\n\nconst TEXT_MASKING_CHAR = 'x'\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node: Node, defaultPrivacyLevel: NodePrivacyLevel): NodePrivacyLevel {\n  const parentNode = getParentNode(node)\n  const parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel) : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return\n  }\n\n  const privAttr = node.getAttribute(PRIVACY_ATTR_NAME)\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isStyle = parentTagName === 'STYLE' ? true : undefined\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (\n    shouldMaskNode(textNode, nodePrivacyLevel) &&\n    // Style tags are `overruled` (Use `hide` to enforce privacy)\n    !isStyle\n  ) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n","import { buildUrl } from '@datadog/browser-core'\nimport { getParentNode, isNodeShadowRoot } from '@datadog/browser-rum-core'\nimport type { NodePrivacyLevel } from '../../../constants'\nimport { CENSORED_STRING_MARK } from '../../../constants'\nimport { shouldMaskNode } from '../privacy'\nimport type { NodeWithSerializedNode } from './serialization.types'\n\nconst serializedNodeIds = new WeakMap<Node, number>()\n\nexport function hasSerializedNode(node: Node): node is NodeWithSerializedNode {\n  return serializedNodeIds.has(node)\n}\n\nexport function nodeAndAncestorsHaveSerializedNode(node: Node): node is NodeWithSerializedNode {\n  let current: Node | null = node\n  while (current) {\n    if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n      return false\n    }\n    current = getParentNode(current)\n  }\n  return true\n}\n\nexport function getSerializedNodeId(node: NodeWithSerializedNode): number\nexport function getSerializedNodeId(node: Node): number | undefined\nexport function getSerializedNodeId(node: Node) {\n  return serializedNodeIds.get(node)\n}\n\nexport function setSerializedNodeId(node: Node, serializeNodeId: number) {\n  serializedNodeIds.set(node, serializeNodeId)\n}\n\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element: Element, nodePrivacyLevel: NodePrivacyLevel) {\n  /*\n   BROWSER SPEC NOTE: <input>, <select>\n   For some <input> elements, the `value` is an exceptional property/attribute that has the\n   value synced between el.value and el.getAttribute()\n   input[type=button,checkbox,hidden,image,radio,reset,submit]\n   */\n  const tagName = element.tagName\n  const value = (element as HTMLInputElement | HTMLTextAreaElement).value\n\n  if (shouldMaskNode(element, nodePrivacyLevel)) {\n    const type = (element as HTMLInputElement | HTMLTextAreaElement).type\n    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n      // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n      // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n      return value\n    } else if (!value || tagName === 'OPTION') {\n      // <Option> value provides no benefit\n      return\n    }\n    return CENSORED_STRING_MARK\n  }\n\n  if (tagName === 'OPTION' || tagName === 'SELECT') {\n    return (element as HTMLOptionElement | HTMLSelectElement).value\n  }\n\n  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n    return\n  }\n\n  return value\n}\n\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//\nexport const DATA_URI = /^data:.*,/i\n\nexport function switchToAbsoluteUrl(cssText: string, cssHref: string | null): string {\n  return cssText.replace(\n    URL_IN_CSS_REF,\n    (\n      matchingSubstring: string,\n      singleQuote: string | undefined,\n      urlWrappedInSingleQuotes: string | undefined,\n      doubleQuote: string | undefined,\n      urlWrappedInDoubleQuotes: string | undefined,\n      urlNotWrappedInQuotes: string | undefined\n    ) => {\n      const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes\n\n      if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n        return matchingSubstring\n      }\n\n      const quote = singleQuote || doubleQuote || ''\n      return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`\n    }\n  )\n}\n\nexport function makeUrlAbsolute(url: string, baseUrl: string): string {\n  try {\n    return buildUrl(url, baseUrl).href\n  } catch (_) {\n    return url\n  }\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nexport function getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n","import type { StyleSheet } from '../../../types'\n\nexport function serializeStyleSheets(cssStyleSheets: CSSStyleSheet[] | undefined): StyleSheet[] | undefined {\n  if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n    return undefined\n  }\n  return cssStyleSheets.map((cssStyleSheet) => {\n    const rules = cssStyleSheet.cssRules || cssStyleSheet.rules\n    const cssRules = Array.from(rules, (cssRule) => cssRule.cssText)\n\n    const styleSheet: StyleSheet = {\n      cssRules,\n      disabled: cssStyleSheet.disabled || undefined,\n      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n    }\n    return styleSheet\n  })\n}\n","import { startsWith } from '@datadog/browser-core'\nimport { STABLE_ATTRIBUTES } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, CENSORED_STRING_MARK, CENSORED_IMG_MARK } from '../../../constants'\nimport { MAX_ATTRIBUTE_VALUE_CHAR_LENGTH } from '../privacy'\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | number | boolean | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n  const attributeValue = element.getAttribute(attributeName)\n  if (\n    nodePrivacyLevel === NodePrivacyLevel.MASK &&\n    attributeName !== PRIVACY_ATTR_NAME &&\n    !STABLE_ATTRIBUTES.includes(attributeName) &&\n    attributeName !== configuration.actionNameAttribute\n  ) {\n    const tagName = element.tagName\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK\n    }\n    // mask image URLs\n    if (tagName === 'IMG' || tagName === 'SOURCE') {\n      if (attributeName === 'src' || attributeName === 'srcset') {\n        return CENSORED_IMG_MARK\n      }\n    }\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK\n    }\n\n    // mask data-* attributes\n    if (attributeValue && startsWith(attributeName, 'data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue\n  }\n\n  // Minimum Fix for customer.\n  if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n    return 'data:truncated'\n  }\n\n  return attributeValue\n}\n","import { ExperimentalFeature, isExperimentalFeatureEnabled } from '@datadog/browser-core'\n\nimport { NodePrivacyLevel } from '../../../constants'\nimport { shouldMaskNode } from '../privacy'\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { SerializationContextStatus } from './serialization.types'\nimport { serializeAttribute } from './serializeAttribute'\n\nexport function serializeAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i)!\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet)\n    if (cssText && stylesheet && !isExperimentalFeatureEnabled(ExperimentalFeature.DISABLE_REPLAY_INLINE_CSS)) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (\n    tagName === 'style' &&\n    (element as HTMLStyleElement).sheet &&\n    // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n    !((element as HTMLStyleElement).innerText || element.textContent || '').trim().length\n  ) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      delete safeAttrs.checked\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n\nfunction getCssRulesString(cssStyleSheet: CSSStyleSheet | undefined | null): string | null {\n  if (!cssStyleSheet) {\n    return null\n  }\n  let rules: CSSRuleList | undefined\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules\n  } catch {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null\n  }\n  const styleSheetCssText = Array.from(rules, getCssRuleString).join('')\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href)\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n","import { isNodeShadowRoot, isNodeShadowHost } from '@datadog/browser-rum-core'\nimport { assign } from '@datadog/browser-core'\nimport type {\n  DocumentFragmentNode,\n  DocumentNode,\n  SerializedNode,\n  SerializedNodeWithId,\n  CDataNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n} from '../../../types'\nimport { NodeType } from '../../../types'\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN } from '../../../constants'\nimport { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent } from '../privacy'\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { serializeStyleSheets } from './serializeStyleSheets'\nimport { serializeAttributes } from './serializeAttributes'\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nlet _nextId = 1\nexport function generateNextId(): number {\n  return _nextId++\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  node.childNodes.forEach((childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  options: SerializeOptions\n): DocumentFragmentNode | undefined {\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    childNodes = serializeChildNodes(element, options)\n  }\n\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes,\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\nfunction serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = serializeAttributes(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      })\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  if (isNodeShadowHost(element)) {\n    const shadowRoot = serializeNodeWithId(element.shadowRoot, options)\n    if (shadowRoot !== null) {\n      childNodes.push(shadowRoot)\n    }\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (textContent === undefined) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n    isStyle: parentTagName === 'STYLE' ? true : undefined,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n","import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { SerializedNodeWithId } from '../../../types'\nimport type { SerializationContext } from './serialization.types'\nimport { serializeNodeWithId } from './serializeNode'\n\nexport function serializeDocument(\n  document: Document,\n  configuration: RumConfiguration,\n  serializationContext: SerializationContext\n): SerializedNodeWithId {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration,\n  })!\n}\n","import { isNodeShadowHost } from '@datadog/browser-rum-core'\n\nexport function isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches)\n}\n\nexport function getEventTarget(event: Event): Node {\n  if (event.composed === true && isNodeShadowHost(event.target as Node)) {\n    return event.composedPath()[0] as Node\n  }\n  return event.target as Node\n}\n","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport: VisualViewport) {\n  return (\n    Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visualViewport = window.visualViewport\n  const normalized: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft)\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft)\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop)\n  }\n  return normalized\n}\n\nexport const getVisualViewport = (visualViewport: VisualViewport): VisualViewportRecord['data'] => ({\n  scale: visualViewport.scale,\n  offsetLeft: visualViewport.offsetLeft,\n  offsetTop: visualViewport.offsetTop,\n  pageLeft: visualViewport.pageLeft,\n  pageTop: visualViewport.pageTop,\n  height: visualViewport.height,\n  width: visualViewport.width,\n})\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport { addEventListeners, addTelemetryDebug, DOM_EVENT, throttle } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { MousePosition } from '../../../types'\nimport { IncrementalSource } from '../../../types'\nimport { getEventTarget, isTouchEvent } from '../eventsUtils'\nimport { convertMouseEventToLayoutCoordinates } from '../viewports'\n\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50\n\nexport type MousemoveCallBack = (\n  p: MousePosition[],\n  source: typeof IncrementalSource.MouseMove | typeof IncrementalSource.TouchMove\n) => void\n\nexport function initMoveObserver(configuration: RumConfiguration, cb: MousemoveCallBack): ListenerHandler {\n  const { throttled: updatePosition } = throttle(\n    (event: MouseEvent | TouchEvent) => {\n      const target = getEventTarget(event)\n      if (hasSerializedNode(target)) {\n        const coordinates = tryToComputeCoordinates(event)\n        if (!coordinates) {\n          return\n        }\n        const position: MousePosition = {\n          id: getSerializedNodeId(target),\n          timeOffset: 0,\n          x: coordinates.x,\n          y: coordinates.y,\n        }\n\n        cb([position], isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove)\n      }\n    },\n    MOUSE_MOVE_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n\n  return addEventListeners(configuration, document, [DOM_EVENT.MOUSE_MOVE, DOM_EVENT.TOUCH_MOVE], updatePosition, {\n    capture: true,\n    passive: true,\n  }).stop\n}\n\nexport function tryToComputeCoordinates(event: MouseEvent | TouchEvent) {\n  let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event\n  if (window.visualViewport) {\n    const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y)\n    x = visualViewportX\n    y = visualViewportY\n  }\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    if (event.isTrusted) {\n      addTelemetryDebug('mouse/touch event without x/y')\n    }\n    return undefined\n  }\n  return { x, y }\n}\n","import type { DefaultPrivacyLevel, ListenerHandler } from '@datadog/browser-core'\nimport { DOM_EVENT, throttle, addEventListener } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getScrollX, getScrollY } from '@datadog/browser-rum-core'\nimport type { ElementsScrollPositions } from '../elementsScrollPositions'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel } from '../privacy'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { ScrollPosition } from '../../../types'\nimport { NodePrivacyLevel } from '../../../constants'\n\nconst SCROLL_OBSERVER_THRESHOLD = 100\n\nexport type ScrollCallback = (p: ScrollPosition) => void\n\nexport function initScrollObserver(\n  configuration: RumConfiguration,\n  cb: ScrollCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel,\n  elementsScrollPositions: ElementsScrollPositions\n): ListenerHandler {\n  const { throttled: updatePosition } = throttle((event: Event) => {\n    const target = getEventTarget(event) as HTMLElement | Document\n    if (\n      !target ||\n      getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const scrollPositions =\n      target === document\n        ? {\n            scrollTop: getScrollY(),\n            scrollLeft: getScrollX(),\n          }\n        : {\n            scrollTop: Math.round((target as HTMLElement).scrollTop),\n            scrollLeft: Math.round((target as HTMLElement).scrollLeft),\n          }\n    elementsScrollPositions.set(target, scrollPositions)\n    cb({\n      id,\n      x: scrollPositions.scrollLeft,\n      y: scrollPositions.scrollTop,\n    })\n  }, SCROLL_OBSERVER_THRESHOLD)\n  return addEventListener(configuration, document, DOM_EVENT.SCROLL, updatePosition, { capture: true, passive: true })\n    .stop\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport { assign, addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type { MouseInteraction, MouseInteractionData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { IncrementalSource, MouseInteractionType } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel } from '../privacy'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { tryToComputeCoordinates } from './moveObserver'\nimport type { RecordIds } from './recordIds'\n\nconst eventTypeToMouseInteraction = {\n  // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n  // allows to reference such records from Frustration records.\n  //\n  // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n  // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n  // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n  // convey such interaction. This would cleanly solve the issue since we would have\n  // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n  [DOM_EVENT.POINTER_UP]: MouseInteractionType.MouseUp,\n\n  [DOM_EVENT.MOUSE_DOWN]: MouseInteractionType.MouseDown,\n  [DOM_EVENT.CLICK]: MouseInteractionType.Click,\n  [DOM_EVENT.CONTEXT_MENU]: MouseInteractionType.ContextMenu,\n  [DOM_EVENT.DBL_CLICK]: MouseInteractionType.DblClick,\n  [DOM_EVENT.FOCUS]: MouseInteractionType.Focus,\n  [DOM_EVENT.BLUR]: MouseInteractionType.Blur,\n  [DOM_EVENT.TOUCH_START]: MouseInteractionType.TouchStart,\n  [DOM_EVENT.TOUCH_END]: MouseInteractionType.TouchEnd,\n}\n\nexport type MouseInteractionCallBack = (record: BrowserIncrementalSnapshotRecord) => void\n\nexport function initMouseInteractionObserver(\n  configuration: RumConfiguration,\n  cb: MouseInteractionCallBack,\n  recordIds: RecordIds\n): ListenerHandler {\n  const handler = (event: MouseEvent | TouchEvent | FocusEvent) => {\n    const target = getEventTarget(event)\n    if (\n      getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const type = eventTypeToMouseInteraction[event.type as keyof typeof eventTypeToMouseInteraction]\n\n    let interaction: MouseInteraction\n    if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n      const coordinates = tryToComputeCoordinates(event as MouseEvent | TouchEvent)\n      if (!coordinates) {\n        return\n      }\n      interaction = { id, type, x: coordinates.x, y: coordinates.y }\n    } else {\n      interaction = { id, type }\n    }\n\n    const record = assign(\n      { id: recordIds.getIdForEvent(event) },\n      assembleIncrementalSnapshot<MouseInteractionData>(IncrementalSource.MouseInteraction, interaction)\n    )\n    cb(record)\n  }\n  return addEventListeners(\n    configuration,\n    document,\n    Object.keys(eventTypeToMouseInteraction) as Array<keyof typeof eventTypeToMouseInteraction>,\n    handler,\n    {\n      capture: true,\n      passive: true,\n    }\n  ).stop\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport { instrumentSetter, assign, DOM_EVENT, addEventListeners, forEach, noop, cssEscape } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type { InputState } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel, shouldMaskNode } from '../privacy'\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization'\n\nexport type InputCallback = (v: InputState & { id: number }) => void\n\nexport function initInputObserver(\n  configuration: RumConfiguration,\n  cb: InputCallback,\n  target: Document | ShadowRoot = document\n): ListenerHandler {\n  const defaultPrivacyLevel = configuration.defaultPrivacyLevel\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  const isShadowRoot = target !== document\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    target,\n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        target instanceof HTMLInputElement ||\n        target instanceof HTMLTextAreaElement ||\n        target instanceof HTMLSelectElement\n      ) {\n        onElementChange(target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  let stopPropertySetterInstrumentation: () => void\n  if (!isShadowRoot) {\n    const instrumentationStoppers = [\n      instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n    ]\n    stopPropertySetterInstrumentation = () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    }\n  } else {\n    stopPropertySetterInstrumentation = noop\n  }\n\n  return () => {\n    stopPropertySetterInstrumentation()\n    stopEventListeners()\n  }\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      forEach(document.querySelectorAll(`input[type=\"radio\"][name=\"${cssEscape(name)}\"]`), (el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target: Node, inputState: InputState) {\n    if (!hasSerializedNode(target)) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      cb(\n        assign(\n          {\n            id: getSerializedNodeId(target),\n          },\n          inputState\n        )\n      )\n    }\n  }\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport { instrumentMethodAndCallOriginal } from '@datadog/browser-core'\nimport type { StyleSheetRule } from '../../../types'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\nexport type StyleSheetCallback = (s: StyleSheetRule) => void\n\nexport function initStyleSheetObserver(cb: StyleSheetCallback): ListenerHandler {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode!)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode))\n    }\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethodAndCallOriginal(CSSStyleSheet.prototype, 'insertRule', {\n      before(rule, index) {\n        checkStyleSheetAndCallback(this, (id) => cb({ id, adds: [{ rule, index }] }))\n      },\n    }),\n    instrumentMethodAndCallOriginal(CSSStyleSheet.prototype, 'deleteRule', {\n      before(index) {\n        checkStyleSheetAndCallback(this, (id) => cb({ id, removes: [{ index }] }))\n      },\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethodAndCallOriginal(cls.prototype, 'insertRule', {\n        before(rule, index) {\n          checkStyleSheetAndCallback(this.parentStyleSheet, (id) => {\n            const path = getPathToNestedCSSRule(this)\n            if (path) {\n              path.push(index || 0)\n              cb({ id, adds: [{ rule, index: path }] })\n            }\n          })\n        },\n      }),\n      instrumentMethodAndCallOriginal(cls.prototype, 'deleteRule', {\n        before(index) {\n          checkStyleSheetAndCallback(this.parentStyleSheet, (id) => {\n            const path = getPathToNestedCSSRule(this)\n            if (path) {\n              path.push(index)\n              cb({ id, removes: [{ index: path }] })\n            }\n          })\n        },\n      })\n    )\n  }\n\n  return () => instrumentationStoppers.forEach((stopper) => stopper.stop())\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport { throttle, DOM_EVENT, addEventListeners, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { initViewportObservable } from '@datadog/browser-rum-core'\nimport type { ViewportResizeDimension, VisualViewportRecord } from '../../../types'\nimport { getVisualViewport } from '../viewports'\n\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200\n\nexport type ViewportResizeCallback = (d: ViewportResizeDimension) => void\n\nexport type VisualViewportResizeCallback = (data: VisualViewportRecord['data']) => void\n\nexport function initViewportResizeObserver(\n  configuration: RumConfiguration,\n  cb: ViewportResizeCallback\n): ListenerHandler {\n  return initViewportObservable(configuration).subscribe(cb).unsubscribe\n}\n\nexport function initVisualViewportResizeObserver(\n  configuration: RumConfiguration,\n  cb: VisualViewportResizeCallback\n): ListenerHandler {\n  const visualViewport = window.visualViewport\n  if (!visualViewport) {\n    return noop\n  }\n  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(\n    () => {\n      cb(getVisualViewport(visualViewport))\n    },\n    VISUAL_VIEWPORT_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n  const removeListener = addEventListeners(\n    configuration,\n    visualViewport,\n    [DOM_EVENT.RESIZE, DOM_EVENT.SCROLL],\n    updateDimension,\n    {\n      capture: true,\n      passive: true,\n    }\n  ).stop\n\n  return function stop() {\n    removeListener()\n    cancelThrottle()\n  }\n}\n","import { noop, monitor } from '@datadog/browser-core'\nimport type { RumMutationRecord } from './observers'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(flush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n    },\n  }\n}\n\n/**\n * Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n * browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n * fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n * browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes efficiently.\n *\n * Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n */\nfunction requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  if (window.requestIdleCallback && window.cancelIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n","import { monitor, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport {\n  getChildNodes,\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n} from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type {\n  AddedNodeMutation,\n  AttributeMutation,\n  BrowserMutationPayload,\n  RemovedNodeMutation,\n  TextMutation,\n} from '../../../types'\nimport { getNodePrivacyLevel, getTextContent } from '../privacy'\nimport type { NodeWithSerializedNode } from '../serialization'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n  serializeNodeWithId,\n  SerializationContextStatus,\n  serializeAttribute,\n} from '../serialization'\nimport { createMutationBatch } from '../mutationBatch'\nimport type { ShadowRootCallBack, ShadowRootsController } from '../shadowRootsController'\n\nexport type MutationCallBack = (m: BrowserMutationPayload) => void\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\ninterface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\ninterface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\ninterface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function initMutationObserver(\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n) {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(\n      mutations.concat(observer.takeRecords() as RumMutationRecord[]),\n      mutationCallback,\n      configuration,\n      shadowRootsController,\n      target\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: MutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n) {\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      target.contains(mutation.target) &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration,\n    shadowRootsController\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback({\n    adds,\n    removes,\n    texts,\n    attributes,\n  })\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode!, configuration.defaultPrivacyLevel)\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION, shadowRootsController },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      configuration.defaultPrivacyLevel\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes?.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: ShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  getChildNodes(removedNode).forEach((child) => traverseRemovedShadowDom(child, shadowDomRemovedCallback))\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration } from '@datadog/browser-rum-core'\nimport type { ElementsScrollPositions } from '../elementsScrollPositions'\nimport type { ShadowRootsController } from '../shadowRootsController'\nimport type { MousemoveCallBack } from './moveObserver'\nimport { initMoveObserver } from './moveObserver'\nimport type { ScrollCallback } from './scrollObserver'\nimport { initScrollObserver } from './scrollObserver'\nimport type { MouseInteractionCallBack } from './mouseInteractionObserver'\nimport { initMouseInteractionObserver } from './mouseInteractionObserver'\nimport type { InputCallback } from './inputObserver'\nimport { initInputObserver } from './inputObserver'\nimport type { StyleSheetCallback } from './styleSheetObserver'\nimport { initStyleSheetObserver } from './styleSheetObserver'\nimport type { MediaInteractionCallback } from './mediaInteractionObserver'\nimport { initMediaInteractionObserver } from './mediaInteractionObserver'\nimport type { FrustrationCallback } from './frustrationObserver'\nimport { initFrustrationObserver } from './frustrationObserver'\nimport type { ViewportResizeCallback, VisualViewportResizeCallback } from './viewportResizeObserver'\nimport { initViewportResizeObserver, initVisualViewportResizeObserver } from './viewportResizeObserver'\nimport type { MutationCallBack } from './mutationObserver'\nimport { initMutationObserver } from './mutationObserver'\nimport type { FocusCallback } from './focusObserver'\nimport { initFocusObserver } from './focusObserver'\nimport { initRecordIds } from './recordIds'\n\ninterface ObserverParam {\n  lifeCycle: LifeCycle\n  configuration: RumConfiguration\n  elementsScrollPositions: ElementsScrollPositions\n  mutationCb: MutationCallBack\n  mousemoveCb: MousemoveCallBack\n  mouseInteractionCb: MouseInteractionCallBack\n  scrollCb: ScrollCallback\n  viewportResizeCb: ViewportResizeCallback\n  visualViewportResizeCb: VisualViewportResizeCallback\n  inputCb: InputCallback\n  mediaInteractionCb: MediaInteractionCallback\n  styleSheetCb: StyleSheetCallback\n  focusCb: FocusCallback\n  frustrationCb: FrustrationCallback\n  shadowRootsController: ShadowRootsController\n}\n\nexport function initObservers(\n  configuration: RumConfiguration,\n  o: ObserverParam\n): { stop: ListenerHandler; flush: ListenerHandler } {\n  const recordIds = initRecordIds()\n  const mutationHandler = initMutationObserver(o.mutationCb, o.configuration, o.shadowRootsController, document)\n  const mousemoveHandler = initMoveObserver(configuration, o.mousemoveCb)\n  const mouseInteractionHandler = initMouseInteractionObserver(configuration, o.mouseInteractionCb, recordIds)\n  const scrollHandler = initScrollObserver(\n    configuration,\n    o.scrollCb,\n    o.configuration.defaultPrivacyLevel,\n    o.elementsScrollPositions\n  )\n  const viewportResizeHandler = initViewportResizeObserver(configuration, o.viewportResizeCb)\n  const inputHandler = initInputObserver(configuration, o.inputCb)\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    configuration,\n    o.mediaInteractionCb,\n    o.configuration.defaultPrivacyLevel\n  )\n  const styleSheetObserver = initStyleSheetObserver(o.styleSheetCb)\n  const focusHandler = initFocusObserver(configuration, o.focusCb)\n  const visualViewportResizeHandler = initVisualViewportResizeObserver(configuration, o.visualViewportResizeCb)\n  const frustrationHandler = initFrustrationObserver(o.lifeCycle, o.frustrationCb, recordIds)\n\n  return {\n    flush: () => {\n      mutationHandler.flush()\n    },\n    stop: () => {\n      mutationHandler.stop()\n      mousemoveHandler()\n      mouseInteractionHandler()\n      scrollHandler()\n      viewportResizeHandler()\n      inputHandler()\n      mediaInteractionHandler()\n      styleSheetObserver()\n      focusHandler()\n      visualViewportResizeHandler()\n      frustrationHandler()\n    },\n  }\n}\n","import type { DefaultPrivacyLevel, ListenerHandler } from '@datadog/browser-core'\nimport { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type { MediaInteraction } from '../../../types'\nimport { MediaInteractionType } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel } from '../privacy'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\n\nexport type MediaInteractionCallback = (p: MediaInteraction) => void\n\nexport function initMediaInteractionObserver(\n  configuration: RumConfiguration,\n  mediaInteractionCb: MediaInteractionCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel\n): ListenerHandler {\n  const handler = (event: Event) => {\n    const target = getEventTarget(event)\n    if (\n      !target ||\n      getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    mediaInteractionCb({\n      id: getSerializedNodeId(target),\n      type: event.type === DOM_EVENT.PLAY ? MediaInteractionType.Play : MediaInteractionType.Pause,\n    })\n  }\n  return addEventListeners(configuration, document, [DOM_EVENT.PLAY, DOM_EVENT.PAUSE], handler, {\n    capture: true,\n    passive: true,\n  }).stop\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { FocusRecord } from '../../../types'\n\nexport type FocusCallback = (data: FocusRecord['data']) => void\n\nexport function initFocusObserver(configuration: RumConfiguration, focusCb: FocusCallback): ListenerHandler {\n  return addEventListeners(configuration, window, [DOM_EVENT.FOCUS, DOM_EVENT.BLUR], () => {\n    focusCb({ has_focus: document.hasFocus() })\n  }).stop\n}\n","export type RecordIds = ReturnType<typeof initRecordIds>\n\nexport function initRecordIds() {\n  const recordIds = new WeakMap<Event, number>()\n  let nextId = 1\n\n  return {\n    getIdForEvent(event: Event): number {\n      if (!recordIds.has(event)) {\n        recordIds.set(event, nextId++)\n      }\n      return recordIds.get(event)!\n    },\n  }\n}\n","import type { ListenerHandler } from '@datadog/browser-core'\nimport type { LifeCycle } from '@datadog/browser-rum-core'\nimport { ActionType, RumEventType, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { FrustrationRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { RecordIds } from './recordIds'\n\nexport type FrustrationCallback = (record: FrustrationRecord) => void\n\nexport function initFrustrationObserver(\n  lifeCycle: LifeCycle,\n  frustrationCb: FrustrationCallback,\n  recordIds: RecordIds\n): ListenerHandler {\n  return lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n    if (\n      data.rawRumEvent.type === RumEventType.ACTION &&\n      data.rawRumEvent.action.type === ActionType.CLICK &&\n      data.rawRumEvent.action.frustration?.type?.length &&\n      'events' in data.domainContext &&\n      data.domainContext.events?.length\n    ) {\n      frustrationCb({\n        timestamp: data.rawRumEvent.date,\n        type: RecordType.FrustrationRecord,\n        data: {\n          frustrationTypes: data.rawRumEvent.action.frustration.type,\n          recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n        },\n      })\n    }\n  }).unsubscribe\n}\n","import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { InputCallback, MutationCallBack } from './observers'\nimport { initInputObserver, initMutationObserver } from './observers'\n\ninterface ShadowRootController {\n  stop: () => void\n  flush: () => void\n}\n\nexport type ShadowRootCallBack = (shadowRoot: ShadowRoot) => void\n\nexport interface ShadowRootsController {\n  addShadowRoot: ShadowRootCallBack\n  removeShadowRoot: ShadowRootCallBack\n  stop: () => void\n  flush: () => void\n}\n\nexport const initShadowRootsController = (\n  configuration: RumConfiguration,\n  {\n    mutationCb,\n    inputCb,\n  }: {\n    mutationCb: MutationCallBack\n    inputCb: InputCallback\n  }\n): ShadowRootsController => {\n  const controllerByShadowRoot = new Map<ShadowRoot, ShadowRootController>()\n\n  const shadowRootsController: ShadowRootsController = {\n    addShadowRoot: (shadowRoot: ShadowRoot) => {\n      const { stop: stopMutationObserver, flush } = initMutationObserver(\n        mutationCb,\n        configuration,\n        shadowRootsController,\n        shadowRoot\n      )\n      // the change event no do bubble up across the shadow root, we have to listen on the shadow root\n      const stopInputObserver = initInputObserver(configuration, inputCb, shadowRoot)\n      controllerByShadowRoot.set(shadowRoot, {\n        flush,\n        stop: () => {\n          stopMutationObserver()\n          stopInputObserver()\n        },\n      })\n    },\n    removeShadowRoot: (shadowRoot: ShadowRoot) => {\n      const entry = controllerByShadowRoot.get(shadowRoot)\n      if (!entry) {\n        // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n        return\n      }\n      entry.stop()\n      controllerByShadowRoot.delete(shadowRoot)\n    },\n    stop: () => {\n      controllerByShadowRoot.forEach(({ stop }) => stop())\n    },\n    flush: () => {\n      controllerByShadowRoot.forEach(({ flush }) => flush())\n    },\n  }\n  return shadowRootsController\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { timeStampNow } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration } from '@datadog/browser-rum-core'\nimport { getViewportDimension, getScrollX, getScrollY } from '@datadog/browser-rum-core'\nimport type {\n  BrowserMutationData,\n  BrowserMutationPayload,\n  BrowserRecord,\n  InputData,\n  MediaInteractionData,\n  MousemoveData,\n  ScrollData,\n  StyleSheetRuleData,\n  ViewportResizeData,\n} from '../../types'\nimport { RecordType, IncrementalSource } from '../../types'\nimport { assembleIncrementalSnapshot } from './assembly'\nimport { SerializationContextStatus, serializeDocument } from './serialization'\nimport { initObservers } from './observers'\nimport { getVisualViewport } from './viewports'\nimport { createElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { initShadowRootsController } from './shadowRootsController'\nimport type { InputCallback } from './observers'\n\nexport interface RecordOptions {\n  emit?: (record: BrowserRecord) => void\n  configuration: RumConfiguration\n  lifeCycle: LifeCycle\n}\n\nexport interface RecordAPI {\n  stop: () => void\n  takeSubsequentFullSnapshot: (timestamp?: TimeStamp) => void\n  flushMutations: () => void\n  shadowRootsController: ShadowRootsController\n}\n\nexport function record(options: RecordOptions): RecordAPI {\n  const { emit, configuration } = options\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required')\n  }\n\n  const elementsScrollPositions = createElementsScrollPositions()\n\n  const mutationCb = (mutation: BrowserMutationPayload) => {\n    emit(assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, mutation))\n  }\n  const inputCb: InputCallback = (s) => emit(assembleIncrementalSnapshot<InputData>(IncrementalSource.Input, s))\n\n  const shadowRootsController = initShadowRootsController(configuration, { mutationCb, inputCb })\n\n  const takeFullSnapshot = (\n    timestamp = timeStampNow(),\n    serializationContext = {\n      status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT,\n      elementsScrollPositions,\n      shadowRootsController,\n    }\n  ) => {\n    const { width, height } = getViewportDimension()\n    emit({\n      data: {\n        height,\n        href: window.location.href,\n        width,\n      },\n      type: RecordType.Meta,\n      timestamp,\n    })\n\n    emit({\n      data: {\n        has_focus: document.hasFocus(),\n      },\n      type: RecordType.Focus,\n      timestamp,\n    })\n\n    emit({\n      data: {\n        node: serializeDocument(document, configuration, serializationContext),\n        initialOffset: {\n          left: getScrollX(),\n          top: getScrollY(),\n        },\n      },\n      type: RecordType.FullSnapshot,\n      timestamp,\n    })\n\n    if (window.visualViewport) {\n      emit({\n        data: getVisualViewport(window.visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp,\n      })\n    }\n  }\n\n  takeFullSnapshot()\n\n  const { stop: stopObservers, flush: flushMutationsFromObservers } = initObservers(configuration, {\n    lifeCycle: options.lifeCycle,\n    configuration,\n    elementsScrollPositions,\n    inputCb,\n    mediaInteractionCb: (p) =>\n      emit(assembleIncrementalSnapshot<MediaInteractionData>(IncrementalSource.MediaInteraction, p)),\n    mouseInteractionCb: (mouseInteractionRecord) => emit(mouseInteractionRecord),\n    mousemoveCb: (positions, source) => emit(assembleIncrementalSnapshot<MousemoveData>(source, { positions })),\n    mutationCb,\n    scrollCb: (p) => emit(assembleIncrementalSnapshot<ScrollData>(IncrementalSource.Scroll, p)),\n    styleSheetCb: (r) => emit(assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, r)),\n    viewportResizeCb: (d) => emit(assembleIncrementalSnapshot<ViewportResizeData>(IncrementalSource.ViewportResize, d)),\n\n    frustrationCb: (frustrationRecord) => emit(frustrationRecord),\n    focusCb: (data) =>\n      emit({\n        data,\n        type: RecordType.Focus,\n        timestamp: timeStampNow(),\n      }),\n    visualViewportResizeCb: (data) => {\n      emit({\n        data,\n        type: RecordType.VisualViewport,\n        timestamp: timeStampNow(),\n      })\n    },\n    shadowRootsController,\n  })\n\n  function flushMutations() {\n    shadowRootsController.flush()\n    flushMutationsFromObservers()\n  }\n\n  return {\n    stop: () => {\n      shadowRootsController.stop()\n      stopObservers()\n    },\n    takeSubsequentFullSnapshot: (timestamp) => {\n      flushMutations()\n      takeFullSnapshot(timestamp, {\n        shadowRootsController,\n        status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT,\n        elementsScrollPositions,\n      })\n    },\n    flushMutations,\n    shadowRootsController,\n  }\n}\n","export type ElementsScrollPositions = ReturnType<typeof createElementsScrollPositions>\nexport type ScrollPositions = { scrollLeft: number; scrollTop: number }\n\nexport function createElementsScrollPositions() {\n  const scrollPositionsByElement = new WeakMap<Element, ScrollPositions>()\n  return {\n    set(element: Element | Document, scrollPositions: ScrollPositions) {\n      if (element === document && !document.scrollingElement) {\n        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n        // in some cases scrolling elements can not be defined, we don't support those for now\n        return\n      }\n      scrollPositionsByElement.set(\n        element === document ? document.scrollingElement! : (element as Element),\n        scrollPositions\n      )\n    },\n    get(element: Element) {\n      return scrollPositionsByElement.get(element)\n    },\n    has(element: Element) {\n      return scrollPositionsByElement.has(element)\n    },\n  }\n}\n","import type { ReplayStats } from '@datadog/browser-rum-core'\n\nexport const MAX_STATS_HISTORY = 10\nlet statsPerView: Map<string, ReplayStats> | undefined\n\nexport function getSegmentsCount(viewId: string) {\n  return getOrCreateReplayStats(viewId).segments_count\n}\n\nexport function addSegment(viewId: string) {\n  getOrCreateReplayStats(viewId).segments_count += 1\n}\n\nexport function addRecord(viewId: string) {\n  getOrCreateReplayStats(viewId).records_count += 1\n}\n\nexport function addWroteData(viewId: string, additionalBytesCount: number) {\n  getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount\n}\n\nexport function getReplayStats(viewId: string) {\n  return statsPerView?.get(viewId)\n}\n\nexport function resetReplayStats() {\n  statsPerView = undefined\n}\n\nfunction getOrCreateReplayStats(viewId: string) {\n  if (!statsPerView) {\n    statsPerView = new Map()\n  }\n\n  let replayStats: ReplayStats\n  if (statsPerView.has(viewId)) {\n    replayStats = statsPerView.get(viewId)!\n  } else {\n    replayStats = {\n      records_count: 0,\n      segments_count: 0,\n      segments_total_raw_size: 0,\n    }\n    statsPerView.set(viewId, replayStats)\n    if (statsPerView.size > MAX_STATS_HISTORY) {\n      deleteOldestStats()\n    }\n  }\n\n  return replayStats\n}\n\nfunction deleteOldestStats() {\n  if (!statsPerView) {\n    return\n  }\n  if (statsPerView.keys) {\n    statsPerView.delete(statsPerView.keys().next().value)\n  } else {\n    // IE11 doesn't support map.keys\n    let isFirst = true\n    statsPerView.forEach((_value, key) => {\n      if (isFirst) {\n        statsPerView!.delete(key)\n        isFirst = false\n      }\n    })\n  }\n}\n","import { addTelemetryDebug, assign, sendToExtension, addEventListener, concatBuffers } from '@datadog/browser-core'\nimport type { DeflateWorkerResponse } from '@datadog/browser-worker'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { DeflateWorker } from './startDeflateWorker'\n\n// Arbitrary id, will be replaced when we have multiple parallel streams.\nconst STREAM_ID = 1\nlet nextId = 0\n\nexport type FlushReason = Exclude<CreationReason, 'init'> | 'stop'\n\nexport class Segment {\n  public flushReason: FlushReason | undefined\n\n  public readonly metadata: BrowserSegmentMetadata\n\n  private id = nextId++\n  private pendingWriteCount = 0\n\n  constructor(\n    configuration: RumConfiguration,\n    private worker: DeflateWorker,\n    context: SegmentContext,\n    creationReason: CreationReason,\n    initialRecord: BrowserRecord,\n    onWrote: (compressedBytesCount: number) => void,\n    onFlushed: (data: Uint8Array, rawBytesCount: number) => void\n  ) {\n    const viewId = context.view.id\n\n    this.metadata = assign(\n      {\n        start: initialRecord.timestamp,\n        end: initialRecord.timestamp,\n        creation_reason: creationReason,\n        records_count: 1,\n        has_full_snapshot: initialRecord.type === RecordType.FullSnapshot,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser' as const,\n      },\n      context\n    )\n\n    replayStats.addSegment(viewId)\n    replayStats.addRecord(viewId)\n    let rawBytesCount = 0\n    let compressedBytesCount = 0\n    const compressedData: Uint8Array[] = []\n\n    const { stop: removeMessageListener } = addEventListener(\n      configuration,\n      worker,\n      'message',\n      ({ data }: MessageEvent<DeflateWorkerResponse>) => {\n        if (data.type !== 'wrote') {\n          return\n        }\n\n        if (data.id === this.id) {\n          this.pendingWriteCount -= 1\n          replayStats.addWroteData(viewId, data.additionalBytesCount)\n          rawBytesCount += data.additionalBytesCount\n          compressedBytesCount += data.result.length\n          compressedData.push(data.result)\n          if (this.flushReason && this.pendingWriteCount === 0) {\n            compressedData.push(data.trailer)\n            onFlushed(concatBuffers(compressedData), rawBytesCount)\n            removeMessageListener()\n          } else {\n            onWrote(compressedBytesCount)\n          }\n        } else if (data.id > this.id) {\n          // Messages should be received in the same order as they are sent, so if we receive a\n          // message with an id superior to this Segment instance id, we know that another, more\n          // recent Segment instance is being used.\n          //\n          // In theory, a \"flush\" response should have been received at this point, so the listener\n          // should already have been removed. But if something goes wrong and we didn't receive a\n          // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n          // help investigate the issue.\n          removeMessageListener()\n          addTelemetryDebug(\"Segment did not receive a 'flush' response before being replaced.\")\n        }\n      }\n    )\n    sendToExtension('record', { record: initialRecord, segment: this.metadata })\n    this.write(`{\"records\":[${JSON.stringify(initialRecord)}`)\n  }\n\n  addRecord(record: BrowserRecord): void {\n    this.metadata.start = Math.min(this.metadata.start, record.timestamp)\n    this.metadata.end = Math.max(this.metadata.end, record.timestamp)\n    this.metadata.records_count += 1\n    replayStats.addRecord(this.metadata.view.id)\n    this.metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n    sendToExtension('record', { record, segment: this.metadata })\n    this.write(`,${JSON.stringify(record)}`)\n  }\n\n  flush(reason: FlushReason) {\n    this.write(`],${JSON.stringify(this.metadata).slice(1)}\\n`)\n    this.worker.postMessage({\n      action: 'reset',\n      streamId: STREAM_ID,\n    })\n    this.flushReason = reason\n  }\n\n  private write(data: string) {\n    this.pendingWriteCount += 1\n    this.worker.postMessage({\n      data,\n      id: this.id,\n      streamId: STREAM_ID,\n      action: 'write',\n    })\n  }\n}\n","import type { HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumSessionManager, RumConfiguration } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason } from './segment'\nimport { Segment } from './segment'\nimport type { DeflateWorker } from './startDeflateWorker'\n\nexport const SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  httpRequest: HttpRequest,\n  worker: DeflateWorker\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    configuration,\n    () => computeSegmentContext(configuration.applicationId, sessionManager, viewContexts),\n    httpRequest,\n    worker\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest,\n  worker: DeflateWorker\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    (pageExitEvent) => {\n      flushSegment(pageExitEvent.reason as FlushReason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush(flushReason)\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  function createNewSegment(creationReason: CreationReason, initialRecord: BrowserRecord) {\n    const context = getSegmentContext()\n    if (!context) {\n      return\n    }\n\n    const segment = new Segment(\n      configuration,\n      worker,\n      context,\n      creationReason,\n      initialRecord,\n      (compressedSegmentBytesCount) => {\n        if (!segment.flushReason && compressedSegmentBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      },\n      (data, rawSegmentBytesCount) => {\n        const payload = buildReplayPayload(data, segment.metadata, rawSegmentBytesCount)\n\n        if (isPageExitReason(segment.flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      }\n    )\n\n    state = {\n      status: SegmentCollectionStatus.SegmentPending,\n      segment,\n      expirationTimeoutId: setTimeout(() => {\n        flushSegment('segment_duration_limit')\n      }, SEGMENT_DURATION_LIMIT),\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      switch (state.status) {\n        case SegmentCollectionStatus.WaitingForInitialRecord:\n          createNewSegment(state.nextSegmentCreationReason, record)\n          break\n\n        case SegmentCollectionStatus.SegmentPending:\n          state.segment.addRecord(record)\n          break\n      }\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n","import type { Payload } from '@datadog/browser-core'\nimport { assign } from '@datadog/browser-core'\nimport type { BrowserSegmentMetadata } from '../../types'\n\nexport type BrowserSegmentMetadataAndSegmentSizes = BrowserSegmentMetadata & {\n  raw_segment_size: number\n  compressed_segment_size: number\n}\n\nexport function buildReplayPayload(\n  data: Uint8Array,\n  metadata: BrowserSegmentMetadata,\n  rawSegmentBytesCount: number\n): Payload {\n  const formData = new FormData()\n\n  formData.append(\n    'segment',\n    new Blob([data], {\n      type: 'application/octet-stream',\n    }),\n    `${metadata.session.id}-${metadata.start}`\n  )\n\n  const metadataAndSegmentSizes: BrowserSegmentMetadataAndSegmentSizes = assign(\n    {\n      raw_segment_size: rawSegmentBytesCount,\n      compressed_segment_size: data.byteLength,\n    },\n    metadata\n  )\n  const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes)\n  formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }))\n\n  return { data: formData, bytesCount: data.byteLength }\n}\n","export const workerString = \"!function(){\\\"use strict\\\";function t(t){for(var e=t.reduce((function(t,e){return t+e.length}),0),a=new Uint8Array(e),n=0,r=0,i=t;r<i.length;r++){var s=i[r];a.set(s,n),n+=s.length}return a}function e(t){for(var e=t.length;--e>=0;)t[e]=0}var a=256,n=286,r=30,i=15,s=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),_=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),h=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),l=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=new Array(576);e(o);var d=new Array(60);e(d);var u=new Array(512);e(u);var f=new Array(256);e(f);var c=new Array(29);e(c);var p,g,v,w=new Array(r);function b(t,e,a,n,r){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}function m(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}e(w);var y=function(t){return t<256?u[t]:u[256+(t>>>7)]},k=function(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},z=function(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,k(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},x=function(t,e,a){z(t,a[2*e],a[2*e+1])},A=function(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},E=function(t,e,a){var n,r,s=new Array(16),_=0;for(n=1;n<=i;n++)s[n]=_=_+a[n-1]<<1;for(r=0;r<=e;r++){var h=t[2*r+1];0!==h&&(t[2*r]=A(s[h]++,h))}},Z=function(t){var e;for(e=0;e<n;e++)t.dyn_ltree[2*e]=0;for(e=0;e<r;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0},U=function(t){t.bi_valid>8?k(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},S=function(t,e,a,n){var r=2*e,i=2*a;return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a]},R=function(t,e,a){for(var n=t.heap[a],r=a<<1;r<=t.heap_len&&(r<t.heap_len&&S(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!S(e,n,t.heap[r],t.depth));)t.heap[a]=t.heap[r],a=r,r<<=1;t.heap[a]=n},L=function(t,e,n){var r,i,h,l,o=0;if(0!==t.last_lit)do{r=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],i=t.pending_buf[t.l_buf+o],o++,0===r?x(t,i,e):(h=f[i],x(t,h+a+1,e),0!==(l=s[h])&&(i-=c[h],z(t,i,l)),r--,h=y(r),x(t,h,n),0!==(l=_[h])&&(r-=w[h],z(t,r,l)))}while(o<t.last_lit);x(t,256,e)},F=function(t,e){var a,n,r,s=e.dyn_tree,_=e.stat_desc.static_tree,h=e.stat_desc.has_stree,l=e.stat_desc.elems,o=-1;for(t.heap_len=0,t.heap_max=573,a=0;a<l;a++)0!==s[2*a]?(t.heap[++t.heap_len]=o=a,t.depth[a]=0):s[2*a+1]=0;for(;t.heap_len<2;)s[2*(r=t.heap[++t.heap_len]=o<2?++o:0)]=1,t.depth[r]=0,t.opt_len--,h&&(t.static_len-=_[2*r+1]);for(e.max_code=o,a=t.heap_len>>1;a>=1;a--)R(t,s,a);r=l;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],R(t,s,1),n=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=n,s[2*r]=s[2*a]+s[2*n],t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1,s[2*a+1]=s[2*n+1]=r,t.heap[1]=r++,R(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a,n,r,s,_,h,l=e.dyn_tree,o=e.max_code,d=e.stat_desc.static_tree,u=e.stat_desc.has_stree,f=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,g=0;for(s=0;s<=i;s++)t.bl_count[s]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<573;a++)(s=l[2*l[2*(n=t.heap[a])+1]+1]+1)>p&&(s=p,g++),l[2*n+1]=s,n>o||(t.bl_count[s]++,_=0,n>=c&&(_=f[n-c]),h=l[2*n],t.opt_len+=h*(s+_),u&&(t.static_len+=h*(d[2*n+1]+_)));if(0!==g){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,g-=2}while(g>0);for(s=p;0!==s;s--)for(n=t.bl_count[s];0!==n;)(r=t.heap[--a])>o||(l[2*r+1]!==s&&(t.opt_len+=(s-l[2*r+1])*l[2*r],l[2*r+1]=s),n--)}}(t,e),E(s,o,t.bl_count)},T=function(t,e,a){var n,r,i=-1,s=e[1],_=0,h=7,l=4;for(0===s&&(h=138,l=3),e[2*(a+1)+1]=65535,n=0;n<=a;n++)r=s,s=e[2*(n+1)+1],++_<h&&r===s||(_<l?t.bl_tree[2*r]+=_:0!==r?(r!==i&&t.bl_tree[2*r]++,t.bl_tree[32]++):_<=10?t.bl_tree[34]++:t.bl_tree[36]++,_=0,i=r,0===s?(h=138,l=3):r===s?(h=6,l=3):(h=7,l=4))},I=function(t,e,a){var n,r,i=-1,s=e[1],_=0,h=7,l=4;for(0===s&&(h=138,l=3),n=0;n<=a;n++)if(r=s,s=e[2*(n+1)+1],!(++_<h&&r===s)){if(_<l)do{x(t,r,t.bl_tree)}while(0!=--_);else 0!==r?(r!==i&&(x(t,r,t.bl_tree),_--),x(t,16,t.bl_tree),z(t,_-3,2)):_<=10?(x(t,17,t.bl_tree),z(t,_-3,3)):(x(t,18,t.bl_tree),z(t,_-11,7));_=0,i=r,0===s?(h=138,l=3):r===s?(h=6,l=3):(h=7,l=4)}},N=!1,O=function(t,e,a,n){z(t,0+(n?1:0),3),function(t,e,a,n){U(t),n&&(k(t,a),k(t,~a)),t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a}(t,e,a,!0)},D=function(t,e,n,r){var i,s,_=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,n=4093624447;for(e=0;e<=31;e++,n>>>=1)if(1&n&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<a;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),F(t,t.l_desc),F(t,t.d_desc),_=function(t){var e;for(T(t,t.dyn_ltree,t.l_desc.max_code),T(t,t.dyn_dtree,t.d_desc.max_code),F(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*l[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),i=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=i&&(i=s)):i=s=n+5,n+4<=i&&-1!==e?O(t,e,n,r):4===t.strategy||s===i?(z(t,2+(r?1:0),3),L(t,o,d)):(z(t,4+(r?1:0),3),function(t,e,a,n){var r;for(z(t,e-257,5),z(t,a-1,5),z(t,n-4,4),r=0;r<n;r++)z(t,t.bl_tree[2*l[r]+1],3);I(t,t.dyn_ltree,e-1),I(t,t.dyn_dtree,a-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,_+1),L(t,t.dyn_ltree,t.dyn_dtree)),Z(t),r&&U(t)},B={_tr_init:function(t){N||(!function(){var t,e,a,l,m,y=new Array(16);for(a=0,l=0;l<28;l++)for(c[l]=a,t=0;t<1<<s[l];t++)f[a++]=l;for(f[a-1]=l,m=0,l=0;l<16;l++)for(w[l]=m,t=0;t<1<<_[l];t++)u[m++]=l;for(m>>=7;l<r;l++)for(w[l]=m<<7,t=0;t<1<<_[l]-7;t++)u[256+m++]=l;for(e=0;e<=i;e++)y[e]=0;for(t=0;t<=143;)o[2*t+1]=8,t++,y[8]++;for(;t<=255;)o[2*t+1]=9,t++,y[9]++;for(;t<=279;)o[2*t+1]=7,t++,y[7]++;for(;t<=287;)o[2*t+1]=8,t++,y[8]++;for(E(o,287,y),t=0;t<r;t++)d[2*t+1]=5,d[2*t]=A(t,5);p=new b(o,s,257,n,i),g=new b(d,_,0,r,i),v=new b(new Array(0),h,0,19,7)}(),N=!0),t.l_desc=new m(t.dyn_ltree,p),t.d_desc=new m(t.dyn_dtree,g),t.bl_desc=new m(t.bl_tree,v),t.bi_buf=0,t.bi_valid=0,Z(t)},_tr_stored_block:O,_tr_flush_block:D,_tr_tally:function(t,e,n){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&n,t.last_lit++,0===e?t.dyn_ltree[2*n]++:(t.matches++,e--,t.dyn_ltree[2*(f[n]+a+1)]++,t.dyn_dtree[2*y(e)]++),t.last_lit===t.lit_bufsize-1},_tr_align:function(t){z(t,2,3),x(t,256,o),function(t){16===t.bi_valid?(k(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},C=function(t,e,a,n){for(var r=65535&t|0,i=t>>>16&65535|0,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{i=i+(r=r+e[n++]|0)|0}while(--s);r%=65521,i%=65521}return r|i<<16|0},H=new Uint32Array(function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var n=0;n<8;n++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}()),M=function(t,e,a,n){var r=H,i=n+a;t^=-1;for(var s=n;s<i;s++)t=t>>>8^r[255&(t^e[s])];return-1^t},Y={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"},K={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},P=B._tr_init,j=B._tr_stored_block,G=B._tr_flush_block,X=B._tr_tally,W=B._tr_align,q=K.Z_NO_FLUSH,J=K.Z_PARTIAL_FLUSH,Q=K.Z_FULL_FLUSH,V=K.Z_FINISH,$=K.Z_BLOCK,tt=K.Z_OK,et=K.Z_STREAM_END,at=K.Z_STREAM_ERROR,nt=K.Z_DATA_ERROR,rt=K.Z_BUF_ERROR,it=K.Z_DEFAULT_COMPRESSION,st=K.Z_FILTERED,_t=K.Z_HUFFMAN_ONLY,ht=K.Z_RLE,lt=K.Z_FIXED,ot=K.Z_DEFAULT_STRATEGY,dt=K.Z_UNKNOWN,ut=K.Z_DEFLATED,ft=258,ct=262,pt=103,gt=113,vt=666,wt=function(t,e){return t.msg=Y[e],e},bt=function(t){return(t<<1)-(t>4?9:0)},mt=function(t){for(var e=t.length;--e>=0;)t[e]=0},yt=function(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask},kt=function(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},zt=function(t,e){G(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,kt(t.strm)},xt=function(t,e){t.pending_buf[t.pending++]=e},At=function(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},Et=function(t,e){var a,n,r=t.max_chain_length,i=t.strstart,s=t.prev_length,_=t.nice_match,h=t.strstart>t.w_size-ct?t.strstart-(t.w_size-ct):0,l=t.window,o=t.w_mask,d=t.prev,u=t.strstart+ft,f=l[i+s-1],c=l[i+s];t.prev_length>=t.good_match&&(r>>=2),_>t.lookahead&&(_=t.lookahead);do{if(l[(a=e)+s]===c&&l[a+s-1]===f&&l[a]===l[i]&&l[++a]===l[i+1]){i+=2,a++;do{}while(l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&i<u);if(n=ft-(u-i),i=u-ft,n>s){if(t.match_start=e,s=n,n>=_)break;f=l[i+s-1],c=l[i+s]}}}while((e=d[e&o])>h&&0!=--r);return s<=t.lookahead?s:t.lookahead},Zt=function(t){var e,a,n,r,i,s,_,h,l,o,d=t.w_size;do{if(r=t.window_size-t.lookahead-t.strstart,t.strstart>=d+(d-ct)){t.window.set(t.window.subarray(d,d+d),0),t.match_start-=d,t.strstart-=d,t.block_start-=d,e=a=t.hash_size;do{n=t.head[--e],t.head[e]=n>=d?n-d:0}while(--a);e=a=d;do{n=t.prev[--e],t.prev[e]=n>=d?n-d:0}while(--a);r+=d}if(0===t.strm.avail_in)break;if(s=t.strm,_=t.window,h=t.strstart+t.lookahead,l=r,o=void 0,(o=s.avail_in)>l&&(o=l),a=0===o?0:(s.avail_in-=o,_.set(s.input.subarray(s.next_in,s.next_in+o),h),1===s.state.wrap?s.adler=C(s.adler,_,o,h):2===s.state.wrap&&(s.adler=M(s.adler,_,o,h)),s.next_in+=o,s.total_in+=o,o),t.lookahead+=a,t.lookahead+t.insert>=3)for(i=t.strstart-t.insert,t.ins_h=t.window[i],t.ins_h=yt(t,t.ins_h,t.window[i+1]);t.insert&&(t.ins_h=yt(t,t.ins_h,t.window[i+3-1]),t.prev[i&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=i,i++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<ct&&0!==t.strm.avail_in)},Ut=function(t,e){for(var a,n;;){if(t.lookahead<ct){if(Zt(t),t.lookahead<ct&&e===q)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ct&&(t.match_length=Et(t,a)),t.match_length>=3)if(n=X(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=yt(t,t.ins_h,t.window[t.strstart+1]);else n=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2},St=function(t,e){for(var a,n,r;;){if(t.lookahead<ct){if(Zt(t),t.lookahead<ct&&e===q)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ct&&(t.match_length=Et(t,a),t.match_length<=5&&(t.strategy===st||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,n=X(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,n&&(zt(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if((n=X(t,0,t.window[t.strstart-1]))&&zt(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=X(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2};function Rt(t,e,a,n,r){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=n,this.func=r}var Lt=[new Rt(0,0,0,0,(function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(Zt(t),0===t.lookahead&&e===q)return 1;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+a;if((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,zt(t,!1),0===t.strm.avail_out))return 1;if(t.strstart-t.block_start>=t.w_size-ct&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(zt(t,!1),t.strm.avail_out),1)})),new Rt(4,4,8,4,Ut),new Rt(4,5,16,8,Ut),new Rt(4,6,32,32,Ut),new Rt(4,4,16,16,St),new Rt(8,16,32,32,St),new Rt(8,16,128,128,St),new Rt(8,32,128,256,St),new Rt(32,128,258,1024,St),new Rt(32,258,258,4096,St)];function Ft(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ut,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),mt(this.dyn_ltree),mt(this.dyn_dtree),mt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),mt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),mt(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var Tt=function(t){if(!t||!t.state)return wt(t,at);t.total_in=t.total_out=0,t.data_type=dt;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?42:gt,t.adler=2===e.wrap?0:1,e.last_flush=q,P(e),tt},It=function(t){var e,a=Tt(t);return a===tt&&((e=t.state).window_size=2*e.w_size,mt(e.head),e.max_lazy_match=Lt[e.level].max_lazy,e.good_match=Lt[e.level].good_length,e.nice_match=Lt[e.level].nice_length,e.max_chain_length=Lt[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),a},Nt=function(t,e,a,n,r,i){if(!t)return at;var s=1;if(e===it&&(e=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),r<1||r>9||a!==ut||n<8||n>15||e<0||e>9||i<0||i>lt)return wt(t,at);8===n&&(n=9);var _=new Ft;return t.state=_,_.strm=t,_.wrap=s,_.gzhead=null,_.w_bits=n,_.w_size=1<<_.w_bits,_.w_mask=_.w_size-1,_.hash_bits=r+7,_.hash_size=1<<_.hash_bits,_.hash_mask=_.hash_size-1,_.hash_shift=~~((_.hash_bits+3-1)/3),_.window=new Uint8Array(2*_.w_size),_.head=new Uint16Array(_.hash_size),_.prev=new Uint16Array(_.w_size),_.lit_bufsize=1<<r+6,_.pending_buf_size=4*_.lit_bufsize,_.pending_buf=new Uint8Array(_.pending_buf_size),_.d_buf=1*_.lit_bufsize,_.l_buf=3*_.lit_bufsize,_.level=e,_.strategy=i,_.method=a,It(t)},Ot={deflateInit:function(t,e){return Nt(t,e,ut,15,8,ot)},deflateInit2:Nt,deflateReset:It,deflateResetKeep:Tt,deflateSetHeader:function(t,e){return t&&t.state?2!==t.state.wrap?at:(t.state.gzhead=e,tt):at},deflate:function(t,e){var a,n;if(!t||!t.state||e>$||e<0)return t?wt(t,at):at;var r=t.state;if(!t.output||!t.input&&0!==t.avail_in||r.status===vt&&e!==V)return wt(t,0===t.avail_out?rt:at);r.strm=t;var i=r.last_flush;if(r.last_flush=e,42===r.status)if(2===r.wrap)t.adler=0,xt(r,31),xt(r,139),xt(r,8),r.gzhead?(xt(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),xt(r,255&r.gzhead.time),xt(r,r.gzhead.time>>8&255),xt(r,r.gzhead.time>>16&255),xt(r,r.gzhead.time>>24&255),xt(r,9===r.level?2:r.strategy>=_t||r.level<2?4:0),xt(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(xt(r,255&r.gzhead.extra.length),xt(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(t.adler=M(t.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(xt(r,0),xt(r,0),xt(r,0),xt(r,0),xt(r,0),xt(r,9===r.level?2:r.strategy>=_t||r.level<2?4:0),xt(r,3),r.status=gt);else{var s=ut+(r.w_bits-8<<4)<<8;s|=(r.strategy>=_t||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(s|=32),s+=31-s%31,r.status=gt,At(r,s),0!==r.strstart&&(At(r,t.adler>>>16),At(r,65535&t.adler)),t.adler=1}if(69===r.status)if(r.gzhead.extra){for(a=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending!==r.pending_buf_size));)xt(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,xt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,xt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.status=pt)}else r.status=pt;if(r.status===pt&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&kt(t),r.pending+2<=r.pending_buf_size&&(xt(r,255&t.adler),xt(r,t.adler>>8&255),t.adler=0,r.status=gt)):r.status=gt),0!==r.pending){if(kt(t),0===t.avail_out)return r.last_flush=-1,tt}else if(0===t.avail_in&&bt(e)<=bt(i)&&e!==V)return wt(t,rt);if(r.status===vt&&0!==t.avail_in)return wt(t,rt);if(0!==t.avail_in||0!==r.lookahead||e!==q&&r.status!==vt){var _=r.strategy===_t?function(t,e){for(var a;;){if(0===t.lookahead&&(Zt(t),0===t.lookahead)){if(e===q)return 1;break}if(t.match_length=0,a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2}(r,e):r.strategy===ht?function(t,e){for(var a,n,r,i,s=t.window;;){if(t.lookahead<=ft){if(Zt(t),t.lookahead<=ft&&e===q)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=s[r=t.strstart-1])===s[++r]&&n===s[++r]&&n===s[++r]){i=t.strstart+ft;do{}while(n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&r<i);t.match_length=ft-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=X(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2}(r,e):Lt[r.level].func(r,e);if(3!==_&&4!==_||(r.status=vt),1===_||3===_)return 0===t.avail_out&&(r.last_flush=-1),tt;if(2===_&&(e===J?W(r):e!==$&&(j(r,0,0,!1),e===Q&&(mt(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),kt(t),0===t.avail_out))return r.last_flush=-1,tt}return e!==V?tt:r.wrap<=0?et:(2===r.wrap?(xt(r,255&t.adler),xt(r,t.adler>>8&255),xt(r,t.adler>>16&255),xt(r,t.adler>>24&255),xt(r,255&t.total_in),xt(r,t.total_in>>8&255),xt(r,t.total_in>>16&255),xt(r,t.total_in>>24&255)):(At(r,t.adler>>>16),At(r,65535&t.adler)),kt(t),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?tt:et)},deflateEnd:function(t){if(!t||!t.state)return at;var e=t.state.status;return 42!==e&&69!==e&&73!==e&&91!==e&&e!==pt&&e!==gt&&e!==vt?wt(t,at):(t.state=null,e===gt?wt(t,nt):tt)},deflateSetDictionary:function(t,e){var a=e.length;if(!t||!t.state)return at;var n=t.state,r=n.wrap;if(2===r||1===r&&42!==n.status||n.lookahead)return at;if(1===r&&(t.adler=C(t.adler,e,a,0)),n.wrap=0,a>=n.w_size){0===r&&(mt(n.head),n.strstart=0,n.block_start=0,n.insert=0);var i=new Uint8Array(n.w_size);i.set(e.subarray(a-n.w_size,a),0),e=i,a=n.w_size}var s=t.avail_in,_=t.next_in,h=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,Zt(n);n.lookahead>=3;){var l=n.strstart,o=n.lookahead-2;do{n.ins_h=yt(n,n.ins_h,n.window[l+3-1]),n.prev[l&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=l,l++}while(--o);n.strstart=l,n.lookahead=2,Zt(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,t.next_in=_,t.input=h,t.avail_in=s,n.wrap=r,tt},deflateInfo:\\\"pako deflate (from Nodeca project)\\\"};for(var Dt=new Uint8Array(256),Bt=0;Bt<256;Bt++)Dt[Bt]=Bt>=252?6:Bt>=248?5:Bt>=240?4:Bt>=224?3:Bt>=192?2:1;Dt[254]=Dt[254]=1;var Ct=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0},Ht=Object.prototype.toString,Mt=K.Z_NO_FLUSH,Yt=K.Z_SYNC_FLUSH,Kt=K.Z_FULL_FLUSH,Pt=K.Z_FINISH,jt=K.Z_OK,Gt=K.Z_STREAM_END,Xt=K.Z_DEFAULT_COMPRESSION,Wt=K.Z_DEFAULT_STRATEGY,qt=K.Z_DEFLATED;function Jt(){this.options={level:Xt,method:qt,chunkSize:16384,windowBits:15,memLevel:8,strategy:Wt};var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;var e=Ot.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==jt)throw new Error(Y[e]);if(t.header&&Ot.deflateSetHeader(this.strm,t.header),t.dictionary){var a;if(a=\\\"[object ArrayBuffer]\\\"===Ht.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(e=Ot.deflateSetDictionary(this.strm,a))!==jt)throw new Error(Y[e]);this._dict_set=!0}}function Qt(t,e,a){try{t.postMessage({type:\\\"errored\\\",error:e,streamId:a})}catch(n){t.postMessage({type:\\\"errored\\\",error:String(e),streamId:a})}}function Vt(t){var e=t.strm.adler;return new Uint8Array([3,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e])}Jt.prototype.push=function(t,e){var a,n,r=this.strm,i=this.options.chunkSize;if(this.ended)return!1;for(n=e===~~e?e:!0===e?Pt:Mt,\\\"[object ArrayBuffer]\\\"===Ht.call(t)?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(i),r.next_out=0,r.avail_out=i),(n===Yt||n===Kt)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if((a=Ot.deflate(r,n))===Gt)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=Ot.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===jt;if(0!==r.avail_out){if(n>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},Jt.prototype.onData=function(t){this.chunks.push(t)},Jt.prototype.onEnd=function(t){t===jt&&(this.result=function(t){for(var e=0,a=0,n=t.length;a<n;a++)e+=t[a].length;for(var r=new Uint8Array(e),i=0,s=0,_=t.length;i<_;i++){var h=t[i];r.set(h,s),s+=h.length}return r}(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},function(e){void 0===e&&(e=self);try{var a=new Map;e.addEventListener(\\\"message\\\",(function(n){try{var r=function(e,a){switch(a.action){case\\\"init\\\":return{type:\\\"initialized\\\",version:\\\"dev\\\"};case\\\"write\\\":var n=e.get(a.streamId);n||(n=new Jt,e.set(a.streamId,n));var r=n.chunks.length,i=function(t){if(\\\"function\\\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);var e,a,n,r,i,s=t.length,_=0;for(r=0;r<s;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),_+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(_),i=0,r=0;i<_;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),a<128?e[i++]=a:a<2048?(e[i++]=192|a>>>6,e[i++]=128|63&a):a<65536?(e[i++]=224|a>>>12,e[i++]=128|a>>>6&63,e[i++]=128|63&a):(e[i++]=240|a>>>18,e[i++]=128|a>>>12&63,e[i++]=128|a>>>6&63,e[i++]=128|63&a);return e}(a.data);return n.push(i,K.Z_SYNC_FLUSH),{type:\\\"wrote\\\",id:a.id,streamId:a.streamId,result:t(n.chunks.slice(r)),trailer:Vt(n),additionalBytesCount:i.length};case\\\"reset\\\":e.delete(a.streamId)}}(a,n.data);r&&e.postMessage(r)}catch(t){Qt(e,t,n.data&&\\\"streamId\\\"in n.data?n.data.streamId:void 0)}}))}catch(t){Qt(e,t)}}()}();\"\n","import { addTelemetryError, display, includes, addEventListener, setTimeout, ONE_SECOND } from '@datadog/browser-core'\nimport type { DeflateWorkerAction, DeflateWorkerResponse } from '@datadog/browser-worker'\nimport { workerString } from '@datadog/browser-worker/string'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\n\nexport const INITIALIZATION_TIME_OUT_DELAY = 10 * ONE_SECOND\n\n/**\n * In order to be sure that the worker is correctly working, we need a round trip of\n * initialization messages, making the creation asynchronous.\n * These worker lifecycle states handle this case.\n */\nconst enum DeflateWorkerStatus {\n  Nil,\n  Loading,\n  Error,\n  Initialized,\n}\n\ntype DeflateWorkerState =\n  | {\n      status: DeflateWorkerStatus.Nil\n    }\n  | {\n      status: DeflateWorkerStatus.Loading\n      callbacks: Array<(worker?: DeflateWorker) => void>\n    }\n  | {\n      status: DeflateWorkerStatus.Error\n    }\n  | {\n      status: DeflateWorkerStatus.Initialized\n      worker: DeflateWorker\n      version: string\n    }\n\nexport interface DeflateWorker extends Worker {\n  postMessage(message: DeflateWorkerAction): void\n}\n\nlet workerBlobUrl: string | undefined\n\nfunction createWorkerBlobUrl() {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerBlobUrl) {\n    workerBlobUrl = URL.createObjectURL(new Blob([workerString]))\n  }\n  return workerBlobUrl\n}\n\nexport function createDeflateWorker(configuration: RumConfiguration): DeflateWorker {\n  return new Worker(configuration.workerUrl || createWorkerBlobUrl())\n}\n\nlet state: DeflateWorkerState = { status: DeflateWorkerStatus.Nil }\n\nexport function startDeflateWorker(\n  configuration: RumConfiguration,\n  callback: (worker?: DeflateWorker) => void,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  switch (state.status) {\n    case DeflateWorkerStatus.Nil:\n      state = { status: DeflateWorkerStatus.Loading, callbacks: [callback] }\n      doStartDeflateWorker(configuration, createDeflateWorkerImpl)\n      break\n    case DeflateWorkerStatus.Loading:\n      state.callbacks.push(callback)\n      break\n    case DeflateWorkerStatus.Error:\n      callback()\n      break\n    case DeflateWorkerStatus.Initialized:\n      callback(state.worker)\n      break\n  }\n}\n\nexport function resetDeflateWorkerState() {\n  state = { status: DeflateWorkerStatus.Nil }\n}\n\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(configuration: RumConfiguration, createDeflateWorkerImpl = createDeflateWorker) {\n  try {\n    const worker = createDeflateWorkerImpl(configuration)\n    addEventListener(configuration, worker, 'error', (error) => {\n      onError(configuration, error)\n    })\n    addEventListener(configuration, worker, 'message', ({ data }: MessageEvent<DeflateWorkerResponse>) => {\n      if (data.type === 'errored') {\n        onError(configuration, data.error, data.streamId)\n      } else if (data.type === 'initialized') {\n        onInitialized(worker, data.version)\n      }\n    })\n    worker.postMessage({ action: 'init' })\n    setTimeout(onTimeout, INITIALIZATION_TIME_OUT_DELAY)\n    return worker\n  } catch (error) {\n    onError(configuration, error)\n  }\n}\n\nfunction onTimeout() {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    display.error('Session Replay recording failed to start: a timeout occurred while initializing the Worker')\n    state.callbacks.forEach((callback) => callback())\n    state = { status: DeflateWorkerStatus.Error }\n  }\n}\n\nfunction onInitialized(worker: DeflateWorker, version: string) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    state.callbacks.forEach((callback) => callback(worker))\n    state = { status: DeflateWorkerStatus.Initialized, worker, version }\n  }\n}\n\nfunction onError(configuration: RumConfiguration, error: unknown, streamId?: number) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    display.error('Session Replay recording failed to start: an error occurred while creating the Worker:', error)\n    if (error instanceof Event || (error instanceof Error && isMessageCspRelated(error.message))) {\n      let baseMessage\n      if (configuration.workerUrl) {\n        baseMessage = `Please make sure the Worker URL ${configuration.workerUrl} is correct and CSP is correctly configured.`\n      } else {\n        baseMessage = 'Please make sure CSP is correctly configured.'\n      }\n      display.error(\n        `${baseMessage} See documentation at https://docs.datadoghq.com/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay`\n      )\n    } else {\n      addTelemetryError(error)\n    }\n    state.callbacks.forEach((callback) => callback())\n    state = { status: DeflateWorkerStatus.Error }\n  } else {\n    addTelemetryError(error, {\n      worker_version: state.status === DeflateWorkerStatus.Initialized && state.version,\n      stream_id: streamId,\n    })\n  }\n}\n\nfunction isMessageCspRelated(message: string) {\n  return (\n    includes(message, 'Content Security Policy') ||\n    // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for\n    includes(message, \"requires 'TrustedScriptURL'\")\n  )\n}\n","/**\n * Test for Browser features used while recording\n */\nexport function isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' &&\n    typeof CSSSupportsRule === 'function' &&\n    typeof URL.createObjectURL === 'function' &&\n    'forEach' in NodeList.prototype\n  )\n}\n","import type { RumConfiguration, RumSessionManager, ViewContexts, RumSession } from '@datadog/browser-rum-core'\nimport { getSessionReplayUrl } from '@datadog/browser-rum-core'\nimport { isBrowserSupported } from '../boot/isBrowserSupported'\n\nexport function getSessionReplayLink(\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  isRecordingStarted: boolean\n): string | undefined {\n  const session = sessionManager.findTrackedSession()\n  const errorType = getErrorType(session, isRecordingStarted)\n  const viewContext = viewContexts.findView()\n\n  return getSessionReplayUrl(configuration, {\n    viewContext,\n    errorType,\n    session,\n  })\n}\n\nfunction getErrorType(session: RumSession | undefined, isRecordingStarted: boolean) {\n  if (!isBrowserSupported()) {\n    return 'browser-not-supported'\n  }\n  if (!session) {\n    // possibilities:\n    // - rum sampled out\n    // - session expired (edge case)\n    return 'rum-not-tracked'\n  }\n  if (!session.sessionReplayAllowed) {\n    // possibilities\n    // - replay sampled out\n    return 'incorrect-session-plan'\n  }\n  if (!isRecordingStarted) {\n    return 'replay-not-started'\n  }\n}\n","// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core'\n\nimport { startRecording } from '../boot/startRecording'\nimport { makeRecorderApi } from '../boot/recorderApi'\n\nexport {\n  CommonProperties,\n  RumPublicApi as RumGlobal,\n  RumInitConfiguration,\n  // Events\n  RumEvent,\n  RumActionEvent,\n  RumErrorEvent,\n  RumLongTaskEvent,\n  RumResourceEvent,\n  RumViewEvent,\n  // Events context\n  RumEventDomainContext,\n  RumViewEventDomainContext,\n  RumErrorEventDomainContext,\n  RumActionEventDomainContext,\n  RumFetchResourceEventDomainContext,\n  RumXhrResourceEventDomainContext,\n  RumOtherResourceEventDomainContext,\n  RumLongTaskEventDomainContext,\n} from '@datadog/browser-rum-core'\nexport { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nconst recorderApi = makeRecorderApi(startRecording)\nexport const datadogRum = makeRumPublicApi(startRum, recorderApi)\n\ninterface BrowserWindow extends Window {\n  DD_RUM?: RumPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_RUM', datadogRum)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils/polyfills'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function makePublicApi<T>(stub: T): T & { onReady(callback: () => void): void; version: string } {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable = global[name] as { q?: Array<() => void> } | undefined\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { Observable, canUseEventBridge, noop, runOnReadyState, relativeNow } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport { getReplayStats } from '../domain/replayStats'\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink'\nimport { startDeflateWorker } from '../domain/segmentCollection'\n\nimport { getSerializedNodeId } from '../domain/record'\nimport type { startRecording } from './startRecording'\nimport { isBrowserSupported } from './isBrowserSupported'\n\nexport type StartRecording = typeof startRecording\n\nconst enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\ntype RecorderState =\n  | {\n      status: RecorderStatus.Stopped\n    }\n  | {\n      status: RecorderStatus.IntentToStart\n    }\n  | {\n      status: RecorderStatus.Starting\n    }\n  | {\n      status: RecorderStatus.Started\n      stopRecording: () => void\n    }\n\nexport function makeRecorderApi(\n  startRecordingImpl: StartRecording,\n  startDeflateWorkerImpl = startDeflateWorker\n): RecorderApi {\n  const recorderStartObservable = new Observable<RelativeTime>()\n\n  if (canUseEventBridge() || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n      getSessionReplayLink: () => undefined,\n      getSerializedNodeId: () => undefined,\n      recorderStartObservable,\n    }\n  }\n\n  let state: RecorderState = {\n    status: RecorderStatus.Stopped,\n  }\n\n  let startStrategy = () => {\n    state = { status: RecorderStatus.IntentToStart }\n  }\n  let stopStrategy = () => {\n    state = { status: RecorderStatus.Stopped }\n  }\n  return {\n    start: () => startStrategy(),\n    stop: () => stopStrategy(),\n    getReplayStats,\n    getSessionReplayLink: (configuration, sessionManager, viewContexts) =>\n      getSessionReplayLink(configuration, sessionManager, viewContexts, state.status !== RecorderStatus.Stopped),\n    recorderStartObservable,\n    getSerializedNodeId,\n    onRumStart: (\n      lifeCycle: LifeCycle,\n      configuration: RumConfiguration,\n      sessionManager: RumSessionManager,\n      viewContexts: ViewContexts\n    ) => {\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          stopStrategy()\n          state = { status: RecorderStatus.IntentToStart }\n        }\n      })\n\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n        if (state.status === RecorderStatus.IntentToStart) {\n          startStrategy()\n        }\n      })\n\n      startStrategy = () => {\n        const session = sessionManager.findTrackedSession()\n        if (!session || !session.sessionReplayAllowed) {\n          state = { status: RecorderStatus.IntentToStart }\n          return\n        }\n\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          return\n        }\n\n        state = { status: RecorderStatus.Starting }\n\n        runOnReadyState(configuration, 'interactive', () => {\n          if (state.status !== RecorderStatus.Starting) {\n            return\n          }\n\n          startDeflateWorkerImpl(configuration, (worker) => {\n            if (state.status !== RecorderStatus.Starting) {\n              return\n            }\n\n            if (!worker) {\n              state = {\n                status: RecorderStatus.Stopped,\n              }\n              return\n            }\n\n            const { stop: stopRecording } = startRecordingImpl(\n              lifeCycle,\n              configuration,\n              sessionManager,\n              viewContexts,\n              worker\n            )\n            recorderStartObservable.notify(relativeNow())\n            state = {\n              status: RecorderStatus.Started,\n              stopRecording,\n            }\n          })\n        })\n      }\n\n      stopStrategy = () => {\n        if (state.status === RecorderStatus.Stopped) {\n          return\n        }\n\n        if (state.status === RecorderStatus.Started) {\n          state.stopRecording()\n        }\n\n        state = {\n          status: RecorderStatus.Stopped,\n        }\n      }\n\n      if (state.status === RecorderStatus.IntentToStart) {\n        startStrategy()\n      }\n    },\n\n    isRecording: () => state.status === RecorderStatus.Started,\n  }\n}\n","import type { RawError, HttpRequest } from '@datadog/browser-core'\nimport { timeStampNow, createHttpRequest, addTelemetryDebug } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumConfiguration,\n  RumSessionManager,\n  ViewCreatedEvent,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\n\nimport { record } from '../domain/record'\nimport type { DeflateWorker } from '../domain/segmentCollection'\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection'\nimport { RecordType } from '../types'\n\nexport function startRecording(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  worker: DeflateWorker,\n  httpRequest?: HttpRequest\n) {\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n\n  const replayRequest =\n    httpRequest ||\n    createHttpRequest(configuration, configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError)\n\n  const { addRecord, stop: stopSegmentCollection } = startSegmentCollection(\n    lifeCycle,\n    configuration,\n    sessionManager,\n    viewContexts,\n    replayRequest,\n    worker\n  )\n\n  const {\n    stop: stopRecording,\n    takeSubsequentFullSnapshot,\n    flushMutations,\n  } = record({\n    emit: addRecord,\n    configuration,\n    lifeCycle,\n  })\n\n  const { unsubscribe: unsubscribeViewEnded } = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, () => {\n    flushMutations()\n    addRecord({\n      timestamp: timeStampNow(),\n      type: RecordType.ViewEnd,\n    })\n  })\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(\n    LifeCycleEventType.VIEW_CREATED,\n    (view: ViewCreatedEvent) => {\n      takeSubsequentFullSnapshot(view.startClocks.timeStamp)\n    }\n  )\n\n  return {\n    stop: () => {\n      unsubscribeViewEnded()\n      unsubscribeViewCreated()\n      stopRecording()\n      stopSegmentCollection()\n    },\n  }\n}\n","import type { Context, InitConfiguration, TimeStamp, RelativeTime, User, Observable } from '@datadog/browser-core'\nimport {\n  noop,\n  CustomerDataType,\n  willSyntheticsInjectRum,\n  assign,\n  BoundedBuffer,\n  createContextManager,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  timeStampNow,\n  display,\n  callMonitored,\n  createHandlingStack,\n  canUseEventBridge,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewContexts } from '../domain/contexts/viewContexts'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { ReplayStats } from '../rawRumEvent.types'\nimport { ActionType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport type { startRum } from './startRum'\n\nexport type RumPublicApi = ReturnType<typeof makeRumPublicApi>\n\nexport type StartRum = typeof startRum\n\ntype StartRumResult = ReturnType<typeof startRum>\n\nexport interface RecorderApi {\n  start: () => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n  getSessionReplayLink: (\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts\n  ) => string | undefined\n  getSerializedNodeId: (node: Node) => number | undefined\n  recorderStartObservable: Observable<RelativeTime>\n}\ninterface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n}\n\nexport function makeRumPublicApi(\n  startRumImpl: StartRum,\n  recorderApi: RecorderApi,\n  { ignoreInitIfSyntheticsWillInjectRum = true }: RumPublicApiOptions = {}\n) {\n  let isAlreadyInitialized = false\n\n  const globalContextManager = createContextManager(CustomerDataType.GlobalContext)\n  const userContextManager = createContextManager(CustomerDataType.User)\n\n  let getInternalContextStrategy: StartRumResult['getInternalContext'] = () => undefined\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n  let stopSessionStrategy: () => void = noop\n  let getSessionReplayLinkStrategy: () => string | undefined = () => undefined\n\n  let bufferApiCalls = new BoundedBuffer()\n  let addTimingStrategy: StartRumResult['addTiming'] = (name, time = timeStampNow()) => {\n    bufferApiCalls.add(() => addTimingStrategy(name, time))\n  }\n  let startViewStrategy: StartRumResult['startView'] = (options, startClocks = clocksNow()) => {\n    bufferApiCalls.add(() => startViewStrategy(options, startClocks))\n  }\n  let addActionStrategy: StartRumResult['addAction'] = (\n    action,\n    commonContext = buildCommonContext(globalContextManager, userContextManager, recorderApi)\n  ) => {\n    bufferApiCalls.add(() => addActionStrategy(action, commonContext))\n  }\n  let addErrorStrategy: StartRumResult['addError'] = (\n    providedError,\n    commonContext = buildCommonContext(globalContextManager, userContextManager, recorderApi)\n  ) => {\n    bufferApiCalls.add(() => addErrorStrategy(providedError, commonContext))\n  }\n\n  let addFeatureFlagEvaluationStrategy: StartRumResult['addFeatureFlagEvaluation'] = (key: string, value: any) => {\n    bufferApiCalls.add(() => addFeatureFlagEvaluationStrategy(key, value))\n  }\n\n  function initRum(initConfiguration: RumInitConfiguration) {\n    // This function should be available, regardless of initialization success.\n    getInitConfigurationStrategy = () => deepClone<InitConfiguration>(initConfiguration)\n\n    // If we are in a Synthetics test configured to automatically inject a RUM instance, we want to\n    // completely discard the customer application RUM instance by ignoring their init() call.  But,\n    // we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n    // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n    if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n      return\n    }\n\n    const eventBridgeAvailable = canUseEventBridge()\n    if (eventBridgeAvailable) {\n      initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n    }\n\n    if (!canInitRum(initConfiguration)) {\n      return\n    }\n\n    const configuration = validateAndBuildRumConfiguration(initConfiguration)\n    if (!configuration) {\n      return\n    }\n\n    if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {\n      display.warn('No storage available for session. We will not send any data.')\n      return\n    }\n\n    if (!configuration.trackViewsManually) {\n      doStartRum(initConfiguration, configuration)\n    } else {\n      // drain beforeInitCalls by buffering them until we start RUM\n      // if we get a startView, drain re-buffered calls before continuing to drain beforeInitCalls\n      // in order to ensure that calls are processed in order\n      const beforeInitCalls = bufferApiCalls\n      bufferApiCalls = new BoundedBuffer()\n\n      startViewStrategy = (options) => {\n        doStartRum(initConfiguration, configuration, options)\n      }\n      beforeInitCalls.drain()\n    }\n\n    isAlreadyInitialized = true\n  }\n\n  function doStartRum(\n    initConfiguration: RumInitConfiguration,\n    configuration: RumConfiguration,\n    initialViewOptions?: ViewOptions\n  ) {\n    const startRumResults = startRumImpl(\n      initConfiguration,\n      configuration,\n      recorderApi,\n      globalContextManager,\n      userContextManager,\n      initialViewOptions\n    )\n    getSessionReplayLinkStrategy = () =>\n      recorderApi.getSessionReplayLink(configuration, startRumResults.session, startRumResults.viewContexts)\n    ;({\n      startView: startViewStrategy,\n      addAction: addActionStrategy,\n      addError: addErrorStrategy,\n      addTiming: addTimingStrategy,\n      addFeatureFlagEvaluation: addFeatureFlagEvaluationStrategy,\n      getInternalContext: getInternalContextStrategy,\n      stopSession: stopSessionStrategy,\n    } = startRumResults)\n    bufferApiCalls.drain()\n\n    recorderApi.onRumStart(\n      startRumResults.lifeCycle,\n      configuration,\n      startRumResults.session,\n      startRumResults.viewContexts\n    )\n  }\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    startViewStrategy(sanitizedOptions)\n  })\n\n  const rumPublicApi = makePublicApi({\n    init: monitor(initRum),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addRumGlobalContext: monitor(globalContextManager.add),\n    setGlobalContextProperty: monitor(globalContextManager.setContextProperty),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeRumGlobalContext: monitor(globalContextManager.remove),\n    removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),\n\n    /** @deprecated: use getGlobalContext instead */\n    getRumGlobalContext: monitor(globalContextManager.get),\n    getGlobalContext: monitor(globalContextManager.getContext),\n\n    /** @deprecated: use setGlobalContext instead */\n    setRumGlobalContext: monitor(globalContextManager.set),\n    setGlobalContext: monitor(globalContextManager.setContext),\n\n    clearGlobalContext: monitor(globalContextManager.clearContext),\n\n    getInternalContext: monitor((startTime?: number) => getInternalContextStrategy(startTime)),\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    addAction: monitor((name: string, context?: object) => {\n      addActionStrategy({\n        name: sanitize(name)!,\n        context: sanitize(context) as Context,\n        startClocks: clocksNow(),\n        type: ActionType.CUSTOM,\n      })\n    }),\n\n    addError: (error: unknown, context?: object) => {\n      const handlingStack = createHandlingStack()\n      callMonitored(() => {\n        addErrorStrategy({\n          error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n          handlingStack,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n        })\n      })\n    },\n\n    addTiming: monitor((name: string, time?: number) => {\n      addTimingStrategy(sanitize(name)!, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setUser: monitor((newUser: User) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(userContextManager.getContext),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor(userContextManager.removeContextProperty),\n\n    /** @deprecated: renamed to clearUser */\n    removeUser: monitor(userContextManager.clearContext),\n    clearUser: monitor(userContextManager.clearContext),\n\n    startView,\n\n    stopSession: monitor(() => {\n      stopSessionStrategy()\n    }),\n\n    startSessionReplayRecording: monitor(recorderApi.start),\n    stopSessionReplayRecording: monitor(recorderApi.stop),\n\n    /**\n     * This feature is currently in beta. For more information see the full [feature flag tracking guide](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/).\n     */\n    addFeatureFlagEvaluation: monitor((key: string, value: any) => {\n      addFeatureFlagEvaluationStrategy(sanitize(key)!, sanitize(value))\n    }),\n    getSessionReplayLink: monitor(() => getSessionReplayLinkStrategy()),\n  })\n\n  return rumPublicApi\n\n  function canInitRum(initConfiguration: RumInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_RUM is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, {\n      applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n      clientToken: 'empty',\n      sessionSampleRate: 100,\n    })\n  }\n}\n","import type { Observable, TelemetryEvent, RawError, ContextManager } from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageExitObservable,\n  TelemetryService,\n  addTelemetryConfiguration,\n  startTelemetry,\n  canUseEventBridge,\n  getEventBridge,\n  addTelemetryDebug,\n} from '@datadog/browser-core'\nimport { createDOMMutationObservable } from '../browser/domMutationObservable'\nimport { startPerformanceCollection } from '../browser/performanceCollection'\nimport { startRumAssembly } from '../domain/assembly'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startViewContexts } from '../domain/contexts/viewContexts'\nimport { startRequestCollection } from '../domain/requestCollection'\nimport { startActionCollection } from '../domain/rumEventsCollection/action/actionCollection'\nimport { startErrorCollection } from '../domain/rumEventsCollection/error/errorCollection'\nimport { startLongTaskCollection } from '../domain/rumEventsCollection/longTask/longTaskCollection'\nimport { startResourceCollection } from '../domain/rumEventsCollection/resource/resourceCollection'\nimport { startViewCollection } from '../domain/rumEventsCollection/view/viewCollection'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager'\nimport { startRumBatch } from '../transport/startRumBatch'\nimport { startRumEventBridge } from '../transport/startRumEventBridge'\nimport { startUrlContexts } from '../domain/contexts/urlContexts'\nimport type { LocationChange } from '../browser/locationChangeObservable'\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { serializeRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport { startFeatureFlagContexts } from '../domain/contexts/featureFlagContext'\nimport { startCustomerDataTelemetry } from '../domain/startCustomerDataTelemetry'\nimport { startPageStateHistory } from '../domain/contexts/pageStateHistory'\nimport type { CommonContext } from '../domain/contexts/commonContext'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport { startWebVitalTelemetryDebug } from '../domain/rumEventsCollection/view/startWebVitalTelemetryDebug'\nimport type { RecorderApi } from './rumPublicApi'\n\nexport function startRum(\n  initConfiguration: RumInitConfiguration,\n  configuration: RumConfiguration,\n  recorderApi: RecorderApi,\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  initialViewOptions?: ViewOptions\n) {\n  const lifeCycle = new LifeCycle()\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event) => sendToExtension('rum', event))\n\n  const telemetry = startRumTelemetry(configuration)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: configuration.applicationId,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: viewContexts.findView()?.id,\n    },\n    action: {\n      id: actionContexts.findActionId(),\n    },\n  }))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n  const featureFlagContexts = startFeatureFlagContexts(lifeCycle)\n\n  const pageExitObservable = createPageExitObservable(configuration)\n  pageExitObservable.subscribe((event) => {\n    lifeCycle.notify(LifeCycleEventType.PAGE_EXITED, event)\n  })\n\n  const session = !canUseEventBridge() ? startRumSessionManager(configuration, lifeCycle) : startRumSessionManagerStub()\n  if (!canUseEventBridge()) {\n    const batch = startRumBatch(\n      configuration,\n      lifeCycle,\n      telemetry.observable,\n      reportError,\n      pageExitObservable,\n      session.expireObservable\n    )\n    startCustomerDataTelemetry(\n      configuration,\n      telemetry,\n      lifeCycle,\n      globalContextManager,\n      userContextManager,\n      featureFlagContexts,\n      batch.flushObservable\n    )\n  } else {\n    startRumEventBridge(lifeCycle)\n  }\n\n  const domMutationObservable = createDOMMutationObservable()\n  const locationChangeObservable = createLocationChangeObservable(configuration, location)\n\n  const { viewContexts, pageStateHistory, urlContexts, actionContexts, addAction } = startRumEventCollection(\n    lifeCycle,\n    configuration,\n    location,\n    session,\n    locationChangeObservable,\n    domMutationObservable,\n    () => buildCommonContext(globalContextManager, userContextManager, recorderApi),\n    reportError\n  )\n\n  addTelemetryConfiguration(serializeRumConfiguration(initConfiguration))\n\n  startLongTaskCollection(lifeCycle, session)\n  startResourceCollection(lifeCycle, configuration, session, pageStateHistory)\n\n  const webVitalTelemetryDebug = startWebVitalTelemetryDebug(configuration, telemetry, recorderApi, session)\n  const { addTiming, startView } = startViewCollection(\n    lifeCycle,\n    configuration,\n    location,\n    domMutationObservable,\n    locationChangeObservable,\n    featureFlagContexts,\n    pageStateHistory,\n    recorderApi,\n    webVitalTelemetryDebug,\n    initialViewOptions\n  )\n  const { addError } = startErrorCollection(lifeCycle, configuration, pageStateHistory, featureFlagContexts)\n\n  startRequestCollection(lifeCycle, configuration, session)\n  startPerformanceCollection(lifeCycle, configuration)\n\n  const internalContext = startInternalContext(\n    configuration.applicationId,\n    session,\n    viewContexts,\n    actionContexts,\n    urlContexts\n  )\n\n  return {\n    addAction,\n    addError,\n    addTiming,\n    addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,\n    startView,\n    lifeCycle,\n    viewContexts,\n    session,\n    stopSession: () => session.expire(),\n    getInternalContext: internalContext.get,\n  }\n}\n\nfunction startRumTelemetry(configuration: RumConfiguration) {\n  const telemetry = startTelemetry(TelemetryService.RUM, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  }\n  return telemetry\n}\n\nexport function startRumEventCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  sessionManager: RumSessionManager,\n  locationChangeObservable: Observable<LocationChange>,\n  domMutationObservable: Observable<void>,\n  buildCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const viewContexts = startViewContexts(lifeCycle)\n  const urlContexts = startUrlContexts(lifeCycle, locationChangeObservable, location)\n\n  const pageStateHistory = startPageStateHistory(configuration)\n\n  const { addAction, actionContexts } = startActionCollection(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    pageStateHistory\n  )\n\n  startRumAssembly(\n    configuration,\n    lifeCycle,\n    sessionManager,\n    viewContexts,\n    urlContexts,\n    actionContexts,\n    buildCommonContext,\n    reportError\n  )\n\n  return {\n    viewContexts,\n    pageStateHistory,\n    urlContexts,\n    addAction,\n    actionContexts,\n    stop: () => {\n      viewContexts.stop()\n      pageStateHistory.stop()\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumEventBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'rum', RumEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    bridge.send('rum', serverRumEvent)\n  })\n}\n","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongTaskEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumSessionManager } from '../../rumSessionManager'\n\nexport function startLongTaskCollection(lifeCycle: LifeCycle, sessionManager: RumSessionManager) {\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType !== 'longtask') {\n        break\n      }\n      const session = sessionManager.findTrackedSession(entry.startTime)\n      if (!session || !session.longTaskAllowed) {\n        break\n      }\n      const startClocks = relativeToClocks(entry.startTime)\n      const rawRumEvent: RawRumLongTaskEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          duration: toServerDuration(entry.duration),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        domainContext: { performanceEntry: entry.toJSON() },\n      })\n    }\n  })\n}\n","import { addTelemetryDebug, elapsed, noop, performDraw, relativeNow, toServerDuration } from '@datadog/browser-core'\nimport type { Telemetry, RelativeTime } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../../boot/rumPublicApi'\nimport type { RumSessionManager } from '../../rumSessionManager'\nimport type { RumConfiguration } from '../../configuration'\n\nexport type WebVitalTelemetryDebug = ReturnType<typeof startWebVitalTelemetryDebug>\n\nexport function startWebVitalTelemetryDebug(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  recorderApi: RecorderApi,\n  session: RumSessionManager\n) {\n  const webVitalTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n\n  if (!webVitalTelemetryEnabled) {\n    return {\n      addWebVitalTelemetryDebug: noop,\n    }\n  }\n  return {\n    addWebVitalTelemetryDebug(webVitalName: string, webVitalNode: Node | undefined, webVitalTime: RelativeTime) {\n      const computationTime = relativeNow()\n      if (!recorderApi.isRecording()) {\n        recorderApi.recorderStartObservable.subscribe((recordingStartTime) => {\n          addTelemetryDebug(`${webVitalName} attribution recording delay`, {\n            computationDelay: toServerDuration(elapsed(webVitalTime, computationTime)),\n            recordingDelay: toServerDuration(elapsed(webVitalTime, recordingStartTime)),\n            hasNode: !!webVitalNode,\n            serializedDomNode: webVitalNode ? recorderApi.getSerializedNodeId(webVitalNode) : undefined,\n          })\n        })\n      }\n\n      addTelemetryDebug(`${webVitalName} attribution`, {\n        computationDelay: toServerDuration(elapsed(webVitalTime, computationTime)),\n        hasNode: !!webVitalNode,\n        replayRecording: recorderApi.isRecording(),\n        replaySampled: session.findTrackedSession()?.sessionReplayAllowed,\n        serializedDomNode: webVitalNode ? recorderApi.getSerializedNodeId(webVitalNode) : undefined,\n      })\n    },\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { ActionContexts } from '../rumEventsCollection/action/actionCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { ViewContexts } from './viewContexts'\nimport type { UrlContexts } from './urlContexts'\n\nexport interface InternalContext {\n  application_id: string\n  session_id: string | undefined\n  view?: {\n    id: string\n    url: string\n    referrer: string\n    name?: string\n  }\n  user_action?: {\n    id: string | string[]\n  }\n}\n\n/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  actionContexts: ActionContexts,\n  urlContexts: UrlContexts\n) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const viewContext = viewContexts.findView(startTime as RelativeTime)\n      const urlContext = urlContexts.findUrl(startTime as RelativeTime)\n      const session = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (session && viewContext && urlContext) {\n        const actionId = actionContexts.findActionId(startTime as RelativeTime)\n        return {\n          application_id: applicationId,\n          session_id: session.id,\n          user_action: actionId ? { id: actionId } : undefined,\n          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n        }\n      }\n    },\n  }\n}\n"],"names":["ConsoleApiName","log","debug","info","warn","error","display","api","Object","prototype","hasOwnProperty","call","args","globalConsole","console","catchUserErrors","fn","errorMsg","err","bind","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitor","callMonitored","this","arguments","context","apply","e","displayIfDebugEnabled","includes","candidate","search","indexOf","arrayFrom","arrayLike","Array","from","array","Set","forEach","item","push","i","length","find","predicate","objectValues","object","keys","map","key","objectEntries","startsWith","slice","cssEscape","str","window","CSS","escape","replace","ch","asCodePoint","charCodeAt","toString","target","toAssign","source","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","ONE_KIBI_BYTE","ONE_MEBI_BYTE","HAS_MULTI_BYTES_CHARACTERS","computeBytesCount","test","undefined","TextEncoder","encode","Blob","size","getZoneJsOriginalValue","name","original","browserWindow","Zone","__symbol__","callback","delay","timeoutId","throttle","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","cancel","noop","getType","value","isArray","mergeInto","destination","circularReferenceChecker","WeakSet","hasAlreadyBeenSeen","has","add","createCircularReferenceChecker","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","jsonStringify","replacer","space","JSON","stringify","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","objectToJson","toJSON","SANITIZE_DEFAULT_MAX_CHARACTER_COUNT","JSON_PATH_ROOT_ELEMENT","KEY_DECORATION_LENGTH","sanitize","maxCharacterCount","containerQueue","visitedObjectsWithPath","WeakMap","sanitizedData","sanitizeProcessor","accumulatedCharacterCount","containerToProcess","shift","separatorLength","targetData","path","warnOverCharacterLimit","parentPath","queue","sourceToSanitize","tryToApplyToJSON","description","sanitizePrimitivesAndFunctions","sanitizedSource","Event","isTrusted","match","sanitizeObjects","sourceAsObject","currentPath","set","changeType","CUSTOMER_DATA_BYTES_LIMIT","warnIfCustomerDataLimitReached","bytesCount","customerDataType","BYTES_COMPUTATION_THROTTLING_DELAY","createContextManager","computeBytesCountImpl","bytesCountCache","alreadyWarned","computeBytesCountThrottled","contextManager","getBytesCount","remove","newContext","getContext","setContext","clearContext","setContextProperty","property","removeContextProperty","buffer","splice","drain","performDraw","threshold","Math","random","round","num","decimals","toFixed","isPercentage","isNumber","navigationStart","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_YEAR","relativeToClocks","relative","timeStamp","getCorrectedTimeStamp","relativeTime","correctedOrigin","dateNow","performance","now","getNavigationStart","addDuration","getTimeStamp","toServerDuration","duration","timeStampNow","relativeNow","clocksNow","clocksOrigin","elapsed","start","end","a","b","getRelativeTime","timestamp","timing","generateUUID","placeholder","parseInt","findCommaSeparatedValue","rawString","matches","exec","safeTruncate","suffix","lastChar","correctedLength","getCurrentSiteCache","cookieMap","Map","setCookie","_expireDelay","_options","getCookie","deleteCookie","delete","SYNTHETICS_TEST_ID_COOKIE_NAME","SYNTHETICS_RESULT_ID_COOKIE_NAME","SYNTHETICS_INJECTS_RUM_COOKIE_NAME","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getAllowedWebViewHosts","parse","send","eventType","event","canUseEventBridge","currentHost","location","hostname","bridge","some","allowedHost","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","split","line","stackFrame","parts","CHROME_LINE_RE","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","url","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","ExperimentalFeature","NO_ERROR_STACK_PRESENT_MESSAGE","computeRawError","stackTrace","originalError","handlingStack","startClocks","nonErrorPrefix","handling","isErrorInstance","Error","computeMessage","hasUsableStack","toStackTraceString","causes","parentSource","currentError","cause","type","flattenErrorCauses","fingerprint","tryToGetFingerprint","dd_fingerprint","result","formatErrorMessage","frame","createHandlingStack","formattedStack","sanitizeUser","newUser","user","enabledExperimentalFeatures","isExperimentalFeatureEnabled","featureName","getExperimentalFeatures","shallowClone","objectHasValue","isEmptyObject","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","filter","other","notify","data","observer","mergeObservables","globalObservable","Observable","subscriptions","observables","observable","subscription","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","SESSION_STORE_KEY","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","isSessionInExpiredState","session","expandSessionState","expire","toSessionString","toSessionState","sessionString","isValidSessionString","entry","OLD_SESSION_COOKIE_NAME","OLD_RUM_COOKIE_NAME","OLD_LOGS_COOKIE_NAME","RUM_SESSION_KEY","LOGS_SESSION_KEY","selectCookieStrategy","initConfiguration","cookieOptions","secure","useSecureSessionCookie","useCrossSiteSessionCookie","crossSite","trackSessionAcrossSubdomains","domain","testCookieName","domainLevels","candidateDomain","pop","getCurrentSite","buildCookieOptions","document","cookie","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","initCookieStrategy","cookieStore","persistSession","retrieveSession","retrieveSessionCookie","clearSession","deleteSessionCookie","cookieStoreStrategy","oldSessionId","oldRumType","oldLogsType","id","tryOldCookiesMigration","LOCAL_STORAGE_TEST_KEY","persistInLocalStorage","sessionState","localStorage","setItem","retrieveSessionFromLocalStorage","getItem","clearSessionFromLocalStorage","removeItem","ongoingOperations","LOCK_RETRY_DELAY","LOCK_MAX_TRIES","bufferedOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","lockEnabled","isLockEnabled","next","currentLock","currentSession","lock","retryLater","processedSession","process","after","chrome","navigator","userAgent","sessionStore","currentNumberOfRetries","nextOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","sessionStoreStrategyType","allowFallbackToLocalStorage","testKey","retrievedId","selectLocalStorageStrategy","startSessionStore","productKey","computeSessionState","renewObservable","expireObservable","watchSessionTimeoutId","isActiveSession","synchronizeSession","sessionCache","retrieveActiveSession","hasSessionInCache","isSessionInCacheOutdated","created","Number","expandOrRenewSession","isTracked","synchronizedSession","trackingType","expandOrRenewSessionState","renewSessionInCache","expandSession","getSession","stop","normalizeUrl","buildUrl","getLinkElementOrigin","href","getOrigin","base","supportedURL","isURLSupported","originalURL","getSupportedUrl","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","URL","element","origin","sanitizedHost","host","protocol","INTAKE_SITE_STAGING","INTAKE_SITE_US1","INTAKE_SITE_EU1","INTAKE_SITE_AP1","ENDPOINTS","logs","rum","sessionReplay","INTAKE_TRACKS","createEndpointBuilder","endpointType","configurationTags","buildUrlWithParameters","proxy","proxyUrl","encodeURIComponent","site","internalAnalyticsSubdomain","domainParts","extension","subdomain","buildEndpointHost","createEndpointUrlWithParametersBuilder","build","flushReason","retry","clientToken","tags","concat","COLLECT_FLUSH_REASON","count","lastFailureStatus","reverse","buildEndpointParameters","urlPrefix","TAG_SIZE_LIMIT","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","configuration","env","service","version","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeUrlPrefixes","builder","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","DefaultPrivacyLevel","ALLOW","MASK","MASK_USER_INPUT","validateAndBuildConfiguration","sessionSampleRate","sampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","enableExperimentalFeatures","flag","beforeSend","silentMultipleInit","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","isMatchOption","itemType","matchList","list","useStartsWith","clearTracingIfNeeded","status","isAborted","traceId","spanId","traceSampled","injectHeadersIfTracingAllowed","sessionManager","inject","getCrypto","findTrackedSession","propagatorTypes","tracingHeaders","tracingOption","allowedTracingUrls","TraceIdentifier","traceSampleRate","propagatorType","toDecimalString","traceparent","toPaddedHexadecimalString","b3","crypto","msCrypto","Uint8Array","getRandomValues","radix","high","readInt32","low","mod","floor","offset","validateAndBuildRumConfiguration","sessionReplaySampleRate","premiumSampleRate","replaySampleRate","tracingSampleRate","excludedActivityUrls","allowedTracingOrigins","option","expectedItem","legacyMatchOption","convertLegacyMatchOptionToTracingOption","validateAndBuildTracingOptions","baseConfiguration","trackUserInteractions","trackInteractions","trackFrustrations","actionNameAttribute","oldPlansBehavior","workerUrl","trackViewsManually","trackResources","trackLongTasks","defaultPrivacyLevel","customerDataTelemetrySampleRate","getSelectedTracingPropagators","usedTracingPropagators","buildCommonContext","globalContextManager","userContextManager","recorderApi","hasReplay","isRecording","sendToExtension","payload","__ddBrowserSdkExtensionCallback","onRawTelemetryEventCollected","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","telemetryConfiguration","maxEventsPerPage","sentEventCount","telemetryEnabled","telemetryConfigurationEnabled","startTelemetry","telemetryService","contextProvider","rawEvent","date","_dd","format_version","telemetry","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","enabled","addTelemetryDebug","addTelemetry","kind","scrubCustomerFrames","formatError","allowedFrameUrl","addEventListener","eventTarget","eventName","listener","addEventListeners","_","eventNames","once","capture","passive","wrappedListener","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","isPageExitReason","reason","getMutationObserverConstructor","constructor","MutationObserver","originalInstance","runOnReadyState","expectedReadyState","readyState","FAKE_INITIAL_DOCUMENT","RESOURCE_TYPES","initiatorType","computeResourceKind","isValidUrl","pathname","getPathName","isType","areInOrder","numbers","computePerformanceResourceDetails","validEntry","toValidEntry","startTime","fetchStart","redirectStart","redirectEnd","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","details","download","formatTiming","first_byte","connect","ssl","dns","hasRedirection","redirect","responseEnd","computeSize","decodedBodySize","isAllowedRequestUrl","isTextNode","node","nodeType","Node","TEXT_NODE","isElementNode","ELEMENT_NODE","isNodeShadowHost","shadowRoot","isNodeShadowRoot","DOCUMENT_FRAGMENT_NODE","getParentNode","parentNode","INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD","getDocumentTraceId","traceIdMeta","querySelector","traceTimeMeta","createDocumentTraceData","content","getDocumentTraceDataFromMeta","comment","childNodes","getTraceCommentFromNode","findTraceComment","getDocumentTraceDataFromComment","traceTime","rawTraceTime","COMMENT_NODE","isCommentNode","supportPerformanceObject","supportPerformanceTimingEvent","entryType","PerformanceObserver","supportedEntryTypes","startPerformanceCollection","lifeCycle","forcedAttributes","getEntriesByType","relativePerformanceTiming","computeRelativePerformanceTiming","retrieveInitialDocumentResourceTiming","handleRumPerformanceEntries","getEntries","entries","mainEntries","experimentalEntries","observe","buffered","entryTypes","clearResourceTimings","sendFakeTiming","retrieveNavigationTiming","startTimeStamp","timingSent","removeEventListeners","evt","cancelable","processingStart","sendTimingIfPointerIsNotCancelled","sendTiming","retrieveFirstInputTiming","numberKey","timingElement","rumAllowedPerformanceEntries","loadEventEnd","isIncompleteNavigation","isForbiddenResource","viewportObservable","viewport","ErrorSource","AGENT","CONSOLE","CUSTOM","LOGGER","NETWORK","SOURCE","REPORT","createEventRateLimiter","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","getSyntheticsContext","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","_DATADOG_SYNTHETICS_RESULT_ID","getSyntheticsResultId","test_id","result_id","injected","initViewportObservable","updateDimension","getViewportDimension","createViewportObservable","visual","visualViewport","width","scale","height","innerWidth","innerHeight","getDisplayContext","viewportDimension","limitModification","modifiableFieldPaths","modifier","clone","fieldPath","fieldType","newValue","current","field","isValidObjectContaining","newType","fields","isValidObject","modifiableFieldPathsByEvent","VIEW_MODIFIABLE_FIELD_PATHS","USER_CUSTOMIZABLE_FIELD_PATHS","startRumAssembly","viewContexts","urlContexts","actionContexts","reportError","eventRateLimiters","syntheticsContext","ciTestContext","testExecutionId","Cypress","test_execution_id","getCiTestContext","rawRumEvent","domainContext","savedCommonContext","customerContext","viewContext","findView","urlContext","findUrl","commonContext","actionId","findActionId","serverRumEvent","drift","plan","session_sample_rate","session_replay_sample_rate","browser_sdk_version","application","view","referrer","action","synthetics","ci_test","has_replay","usr","rateLimitReached","shouldSend","xhrObservable","LifeCycle","callbacks","eventCallbacks","END_OF_TIMES","Infinity","CLEAR_OLD_VALUES_INTERVAL","expireDelay","maxEntries","clearOldValuesInterval","clearOldValues","endTime","index","close","unshift","closeActive","latestEntry","findAll","reset","oldTimeThreshold","VIEW_CONTEXT_TIME_OUT_DELAY","instrumentMethod","method","instrumentationFactory","instrumentation","instrumentationWrapper","instrumentMethodAndCallOriginal","before","instrumentSetter","originalDescriptor","getOwnPropertyDescriptor","thisObject","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","XMLHttpRequest","openXhr","stopInstrumentingSend","sendXhr","stopInstrumentingAbort","abortXhr","createXhrObservable","state","startContext","xhr","hasBeenReported","stopInstrumentingOnReadyStateChange","DONE","onEnd","unsubscribeLoadEndListener","completeContext","initFetchObservable","fetch","originalFetch","input","init","responsePromise","afterSend","Request","reportFetch","response","DOMException","code","ABORT_ERR","responseType","then","nextRequestIndex","startRequestCollection","tracer","traceFetch","headers","append","Headers","header","traceXhr","setRequestHeader","startTracer","rawContext","requestIndex","getNextRequestIndex","trackXhr","clonedResponse","tryToClone","stream","reader","getReader","chunks","readBytesCount","onDone","bytes","limitExceeded","catch","collectStreamBody","chunk","bytesLimit","readMore","read","done","readBytesFromStream","POSITIVE_INFINITY","waitForResponseToComplete","trackFetch","trackEventCounts","isChildEvent","onChange","eventCounts","errorCount","longTaskCount","resourceCount","actionCount","frustrationCount","frustration","PAGE_ACTIVITY_VALIDATION_DELAY","PAGE_ACTIVITY_END_DELAY","waitPageActivityEnd","domMutationObservable","pageActivityEndCallback","maxDuration","pageActivityObservable","firstRequestIndex","pendingRequestsCount","notifyPageActivity","isExcludedUrl","startEvent","request","stopTrackingWindowOpen","s","isBusy","createPageActivityObservable","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","complete","hadActivity","maxDurationTimeoutId","pageActivitySubscription","lastChangeTime","doWaitPageActivityEnd","requestUrl","MAX_DURATION_BETWEEN_CLICKS","MAX_DISTANCE_BETWEEN_CLICKS","createClickChain","firstClick","onFinalize","maxDurationBetweenClicksTimeoutId","bufferedClicks","appendClick","click","stopObservable","tryFinalize","dontAcceptMoreClick","every","isStopped","tryAppend","first","second","sqrt","pow","clientX","clientY","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","getActionNameFromElement","userProgrammaticAttribute","getActionNameFromElementProgrammatically","getActionNameFromElementForStrategies","priorityStrategies","fallbackStrategies","targetElement","programmaticAttribute","elementWithAttribute","supportsElementClosestResult","HTMLElement","supportsElementClosest","closest","hasAttribute","parentElement","truncate","normalizeWhitespace","getAttribute","trim","supportsLabelPropertyResult","HTMLInputElement","supportsLabelProperty","labels","getTextualContent","label","ownerDocument","querySelectorAll","htmlFor","nodeName","labelledByAttribute","refElement","getElementById","MAX_PARENTS_TO_CONSIDER","strategies","recursionCounter","strategy","trimmedName","isContentEditable","innerText","removeTextFromElements","query","textToReplace","documentMode","textContent","supportScopeSelectorCache","STABLE_ATTRIBUTES","GLOBALLY_UNIQUE_SELECTOR_GETTERS","getStableAttributeSelector","isGeneratedValue","UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS","tagName","classList","className","getSelectorFromElement","targetElementSelector","globallyUniqueSelector","findSelector","isSelectorUniqueGlobally","isSelectorUniqueAmongSiblings","combineSelector","getPositionSelector","selector","getAttributeSelector","attributeName","sibling","firstElementChild","elementIndex","nextElementSibling","selectorGetters","childSelector","elementSelector","selectorGetter","fullSelector","supportScopeSelector","parent","child","isSelectionEmpty","selection","getSelection","isCollapsed","isValidPointerEvent","Element","isPrimary","MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE","computeFrustration","clicks","rageClick","getUserActivity","isRage","addFrustration","isDead","hasError","hasSelectionChanged","DEAD_CLICK_EXCLUDE_SELECTOR","hasPageActivity","msMatchesSelector","CLICK_ACTION_MAX_DURATION","ACTION_CONTEXT_TIME_OUT_DELAY","trackClickActions","currentClickChain","history","ValueHistory","stopClickChain","stopActionEventsListener","selectionEmptyAtPointerDown","clickContext","onPointerDown","onPointerUp","userActivity","listeners","listenActionEvents","pointerDownEvent","clickActionBase","rect","getBoundingClientRect","position","x","left","y","top","hadActivityOnPointerDown","pageActivityEndEvent","processPointerDown","appendClickToClickChain","newClick","stopWaitPageActivityEnd","discard","validate","viewEndedSubscription","endClocks","stopSubscription","startClickAction","finalizeClicks","activityEndTime","historyEntry","eventCountsSubscription","frustrationTypes","newActivityEndTime","frustrationType","domEvents","clickAction","counts","events","processAction","pageStateHistory","autoActionProperties","isAutoAction","loading_time","long_task","resource","in_foreground","isInActivePageStateAt","ERROR_TYPES_RE","startUnhandledErrorCollection","stopInstrumentingOnError","messageObj","errorObj","tryToParseMessage","instrumentOnError","stopInstrumentingOnUnhandledRejection","instrumentUnhandledRejection","consoleObservablesByApi","initConsoleObservable","apis","consoleObservables","originalConsoleApi","params","param","formatConsoleParameters","firstErrorParam","buildConsoleLog","createConsoleObservable","trackFirstHiddenSingleton","RawReportType","intervention","deprecation","cspViolation","initReportObservable","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","buildRawReportFromCspViolation","createCspViolationReportObservable","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportFromReport","types","disconnect","createReportObservable","startErrorCollection","featureFlagContexts","errorObservable","consoleError","trackConsoleError","trackRuntimeError","trackReportError","handling_stack","source_type","featureFlagContext","findFeatureFlagEvaluations","feature_flags","processError","addError","rawError","doStartErrorCollection","matchRequestTiming","sameNameEntries","getEntriesByName","candidates","errorMargin","startResourceCollection","matchingTiming","correspondingTimingOverrides","computePerformanceEntryMetrics","tracingInfo","hasBeenTraced","span_id","trace_id","rule_psr","getRulePsr","computeRequestTracingInfo","indexingInfo","computeIndexingInfo","NO_RESOURCE_DURATION_FROZEN_STATE","requestCrossedFrozenState","pageState","computeRequestDuration","pageStateInfo","computePageStateInfo","resourceEvent","status_code","performanceEntry","requestInput","requestInit","processRequest","processResourceEntry","entryMetrics","computeEntryTracingInfo","resourceStart","discarded","resourceAllowed","RESOURCE_PAGE_STATES","page_states","page_was_discarded","wasDiscarded","mapToForegroundPeriods","pageStateServerEntries","foregroundPeriods","trackFirstHidden","visibilityState","TIMING_MAXIMUM_DELAY","KEEP_TRACKING_TIMINGS_AFTER_VIEW_DELAY","trackInitialViewTimings","webVitalTelemetryDebug","setLoadEvent","scheduleViewUpdate","timings","setTimings","newTimings","stopNavigationTracking","domComplete","domContentLoaded","domContentLoadedEventEnd","domInteractive","loadEvent","firstByte","trackNavigationTimings","stopFCPTracking","firstHidden","fcpEntry","trackFirstContentfulPaintTiming","firstContentfulPaint","stopLCPTracking","firstInteractionTimestamp","stopEventListener","unsubscribeLifeCycle","lcpEntry","findLast","trackLargestContentfulPaintTiming","largestContentfulPaint","lcpElement","addWebVitalTelemetryDebug","stopFIDTracking","firstInputEntry","firstInputDelay","firstInputTime","firstInputTarget","trackFirstInputTimings","scheduleStop","getScrollX","scrollX","pageLeft","offsetLeft","pageXOffset","getScrollY","scrollY","pageTop","offsetTop","pageYOffset","THROTTLE_SCROLL_DURATION","trackViewMetrics","loadingType","viewStart","scrollMetrics","stopCLSTracking","viewMetrics","loadType","isWaitingForLoadEvent","isWaitingForActivityLoadingTime","loadingTimeCandidates","invokeCallbackIfAllCandidatesAreReceived","max","trackLoadingTime","newLoadingTime","loadingTime","computeScrollValues","scrollHeight","scrollDepth","scrollTop","maxDepth","maxDepthScrollHeight","maxDepthTime","maxDepthScrollTop","stopLoadingTimeTracking","stopScrollMetricsTracking","getScrollValues","handleScrollEvent","trackScrollMetrics","newScrollMetrics","clsAttributionCollected","cumulativeLayoutShift","maxClsValue","largestLayoutShiftNode","largestLayoutShiftTime","largestLayoutShift","update","largestLayoutShiftSource","slidingSessionWindow","hadRecentInput","trackCumulativeLayoutShift","getScrollMetrics","scrollingElement","documentElement","KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY","THROTTLE_VIEW_UPDATE_PERIOD","SESSION_KEEP_ALIVE_INTERVAL","trackViews","locationChangeObservable","areViewsTrackedAutomatically","initialViewOptions","locationChangeSubscription","currentView","startNewView","viewOptions","initialLocation","customTimings","documentVersion","sessionIsActive","triggerViewUpdate","cancelScheduleViewUpdate","stopViewMetricsTracking","scheduleStopInitialViewTimingsTracking","viewId","trackViewEventCounts","scheduleStopEventCountsTracking","keepAliveIntervalId","currentEnd","isActive","addTiming","time","looksLikeRelativeTime","sanitized","sanitizeTiming","newView","pageExitEvent","currentLocation","otherLocation","hash","correspondingId","oldLocation","newLocation","substr","getPathFromHash","renewViewOnLocationChange","startView","startViewCollection","replayStats","getReplayStats","pageStatesEnabled","PAGE_STATES","pageStates","viewEvent","document_version","replay_stats","cumulative_layout_shift","dom_complete","dom_content_loaded","dom_interactive","first_contentful_paint","first_input_delay","first_input_time","is_active","largest_contentful_paint","load_event","discardNegativeDuration","loading_type","time_spent","in_foreground_periods","scroll","max_depth","max_depth_scroll_height","max_depth_scroll_top","max_depth_time","privacy","replay_level","custom_timings","newObject","mapValues","processViewUpdate","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","stopCallbacks","startSessionManager","sessionContextHistory","buildSessionContext","expandSessionWhenVisible","visibilityCheckInterval","trackVisibility","findActiveSession","startRumSessionManager","rawTrackingType","hasValidRumSession","isTypeTracked","sessionReplayAllowed","longTaskAllowed","rumSessionType","createFlushController","messagesLimit","durationLimit","pageExitObservable","sessionExpireObservable","flushObservable","flush","durationLimitTimeoutId","currentBytesCount","currentMessagesCount","messagesCount","cancelDurationLimitTimeout","notifyBeforeAddMessage","messageBytesCount","notifyAfterAddMessage","notifyAfterRemoveMessage","flushController","pushOnlyBuffer","upsertBuffer","addOrUpdate","upsert","messages","sendOnExit","processedMessage","hasMessageFor","separatorBytesCount","removedMessage","MAX_ONGOING_BYTES_COUNT","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","MAX_BACKOFF_TIME","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","sendStrategy","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","dequeue","currentBackoffTime","min","onLine","shouldRetryRequest","ongoingRequestCount","isFull","queueFullReported","previousQueue","newPayloadQueue","createHttpRequest","endpointBuilder","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","canUseKeepAlive","isKeepAliveSupported","fetchUrl","keepalive","mode","xhrUrl","sendXHR","fetchKeepAliveStrategy","canUseBeacon","sendBeacon","beaconUrl","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","open","startRumBatch","telemetryEventObservable","batch","replicaBatch","createRumBatch","primaryBatch","primaryFlushController","Batch","withReplicaApplicationId","replicated","makeRumBatch","isTelemetryReplicationAllowed","URL_CONTEXT_TIME_OUT_DELAY","createLocationChangeObservable","stopHistoryTracking","onHistoryChange","stopInstrumentingPushState","stopInstrumentingReplaceState","removeListener","trackHistory","onLocationChange","stopHashTracking","onHashChange","trackHash","FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY","currentPeriodMeasures","currentBatchMeasures","batchHasRumEvent","MEASURES_PERIOD_DURATION","sendCurrentPeriodMeasures","batchCount","initCurrentPeriodMeasures","updateMeasure","measure","sum","mergeMeasure","batchBytesCount","batchMessagesCount","globalContextBytes","userContextBytes","featureFlagBytes","initCurrentBatchMeasures","MAX_PAGE_STATE_ENTRIES","MAX_PAGE_STATE_ENTRIES_SELECTABLE","PAGE_STATE_CONTEXT_TIME_OUT_DELAY","startPageStateHistory","maxPageStateEntriesSelectable","currentPageState","addPageState","getPageState","stopEventListeners","persisted","computePageState","nextPageState","eventStartTime","pageStateEntries","relativeStartTime","pageStateEntry","hasFocus","getSessionReplayUrl","errorType","sessionId","rumConfiguration","getSiteDefaultSubdomain","RecordType","FullSnapshot","IncrementalSnapshot","Meta","Focus","ViewEnd","VisualViewport","FrustrationRecord","NodeType","Document","DocumentType","Text","CDATA","DocumentFragment","IncrementalSource","Mutation","MouseMove","MouseInteraction","Scroll","ViewportResize","Input","TouchMove","MediaInteraction","StyleSheetRule","MouseInteractionType","MouseUp","MouseDown","Click","ContextMenu","DblClick","Blur","TouchStart","TouchEnd","MediaInteractionType","Play","Pause","assembleIncrementalSnapshot","NodePrivacyLevel","IGNORE","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_ALLOW","PRIVACY_ATTR_VALUE_MASK","PRIVACY_ATTR_VALUE_MASK_USER_INPUT","PRIVACY_ATTR_VALUE_HIDDEN","PRIVACY_CLASS_ALLOW","PRIVACY_CLASS_MASK","PRIVACY_CLASS_MASK_USER_INPUT","PRIVACY_CLASS_HIDDEN","CENSORED_STRING_MARK","CENSORED_IMG_MARK","FORM_PRIVATE_TAG_NAMES","INPUT","OUTPUT","TEXTAREA","SELECT","OPTION","DATALIST","OPTGROUP","MAX_ATTRIBUTE_VALUE_CHAR_LENGTH","getNodePrivacyLevel","parentNodePrivacyLevel","reducePrivacyLevel","getNodeSelfPrivacyLevel","childPrivacyLevel","privAttr","inputElement","autocomplete","contains","relAttribute","getLowerCaseAttribute","nameAttribute","propertyAttribute","toLowerCase","shouldIgnoreElement","shouldMaskNode","privacyLevel","isFormElement","censorText","text","getTextContent","textNode","ignoreWhiteSpace","parentTagName","nodePrivacyLevel","isStyle","serializedNodeIds","hasSerializedNode","getSerializedNodeId","getElementInputValue","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssText","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","quote","baseUrl","makeUrlAbsolute","TAG_NAME_REGEX","getValidTagName","processedTagName","serializeStyleSheets","cssStyleSheets","cssStyleSheet","rules","cssRules","cssRule","disabled","media","serializeAttribute","attributeValue","getCssRulesString","getCssRuleString","rule","isCSSImportRule","styleSheet","serializeNodeWithId","serializedNode","DOCUMENT_NODE","serializeChildNodes","adoptedStyleSheets","serializeDocumentNode","isShadowRoot","serializationContext","shadowRootsController","addShadowRoot","serializeDocumentFragmentNode","DOCUMENT_TYPE_NODE","documentType","publicId","systemId","isSVG","el","SVGElement","attributes","rr_width","rr_height","safeAttrs","formValue","optionElement","selected","stylesheet","styleSheets","DISABLE_REPLAY_INLINE_CSS","_cssText","sheet","scrollLeft","checked","mediaElement","rr_mediaState","paused","elementsScrollPositions","rr_scrollLeft","rr_scrollTop","serializeAttributes","serializeElementNode","serializeTextNode","CDATA_SECTION_NODE","serializeNode","_nextId","serializedNodeWithId","serializeNodeId","setSerializedNodeId","childNode","serializedChildNode","serializeDocument","isTouchEvent","changedTouches","getEventTarget","composed","composedPath","convertMouseEventToLayoutCoordinates","normalized","layoutViewportX","layoutViewportY","visualViewportX","visualViewportY","abs","isVisualViewportFactoredIn","getVisualViewport","MOUSE_MOVE_OBSERVER_THRESHOLD","tryToComputeCoordinates","isFinite","SCROLL_OBSERVER_THRESHOLD","eventTypeToMouseInteraction","initInputObserver","cb","stopPropertySetterInstrumentation","lastInputStateMap","HTMLTextAreaElement","HTMLSelectElement","onElementChange","stopper","inputState","isChecked","cbWithDedup","lastInputState","getPathToNestedCSSRule","currentRule","parentRule","parentStyleSheet","VISUAL_VIEWPORT_OBSERVER_THRESHOLD","MUTATION_PROCESS_MAX_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","addMutations","mutations","opts","requestIdleCallback","cancelIdleCallback","requestAnimationFrame","cancelAnimationFrame","timeout","initMutationObserver","mutationCallback","mutationBatch","mutation","removedNodes","removedNode","traverseRemovedShadowDom","removeShadowRoot","filteredMutations","nodeAndAncestorsHaveSerializedNode","addedAndMovedNodes","addedNodes","sortedAddedAndMovedNodes","nodes","sort","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","addedNodeMutations","hasBeenSerialized","nextId","getNextSibling","parentId","removedNodeMutations","adds","removes","nextSibling","processChildListMutations","texts","textMutations","handledNodes","oldValue","processCharacterDataMutations","attributeMutations","handledElements","handledAttributes","emittedMutations","transformedValue","inputValue","emittedMutation","processAttributesMutations","processMutations","takeRecords","attributeOldValue","characterData","characterDataOldValue","childList","subtree","shadowDomRemovedCallback","initObservers","o","updatePosition","mediaInteractionCb","focusCb","recordIds","getIdForEvent","initRecordIds","mutationHandler","mutationCb","mousemoveHandler","mousemoveCb","coordinates","timeOffset","mouseInteractionHandler","interaction","record","initMouseInteractionObserver","mouseInteractionCb","scrollHandler","scrollPositions","initScrollObserver","scrollCb","viewportResizeHandler","initViewportResizeObserver","viewportResizeCb","inputHandler","inputCb","mediaInteractionHandler","styleSheetObserver","checkStyleSheetAndCallback","ownerNode","instrumentationStoppers","CSSStyleSheet","instrumentGroupingCSSRuleClass","cls","CSSGroupingRule","CSSMediaRule","CSSSupportsRule","initStyleSheetObserver","styleSheetCb","focusHandler","has_focus","visualViewportResizeHandler","cancelThrottle","initVisualViewportResizeObserver","visualViewportResizeCb","frustrationHandler","frustrationCb","initFrustrationObserver","initShadowRootsController","controllerByShadowRoot","stopMutationObserver","stopInputObserver","emit","scrollPositionsByElement","takeFullSnapshot","initialOffset","p","mouseInteractionRecord","positions","r","d","frustrationRecord","stopObservers","flushMutationsFromObservers","flushMutations","takeSubsequentFullSnapshot","statsPerView","MAX_STATS_HISTORY","getSegmentsCount","getOrCreateReplayStats","segments_count","addRecord","records_count","segments_total_raw_size","_value","deleteOldestStats","worker","creationReason","initialRecord","onWrote","onFlushed","pendingWriteCount","metadata","creation_reason","has_full_snapshot","index_in_view","rawBytesCount","compressedBytesCount","compressedData","removeMessageListener","additionalBytesCount","trailer","buffers","reduce","total","concatBuffers","segment","write","postMessage","streamId","SEGMENT_DURATION_LIMIT","SEGMENT_BYTES_LIMIT","startSegmentCollection","httpRequest","getSegmentContext","nextSegmentCreationReason","unsubscribeViewCreated","flushSegment","unsubscribePageExited","expirationTimeoutId","createNewSegment","Segment","compressedSegmentBytesCount","rawSegmentBytesCount","formData","FormData","metadataAndSegmentSizes","raw_segment_size","compressed_segment_size","byteLength","serializedMetadataAndSegmentSizes","buildReplayPayload","doStartSegmentCollection","computeSegmentContext","workerBlobUrl","workerString","INITIALIZATION_TIME_OUT_DELAY","createDeflateWorker","Worker","createObjectURL","startDeflateWorker","createDeflateWorkerImpl","onError","onTimeout","doStartDeflateWorker","baseMessage","worker_version","stream_id","isBrowserSupported","NodeList","getSessionReplayLink","isRecordingStarted","getErrorType","existingGlobalVariable","startRecordingImpl","startDeflateWorkerImpl","recorderStartObservable","onRumStart","startStrategy","stopStrategy","stopRecording","makeRecorderApi","replayRequest","stopSegmentCollection","unsubscribeViewEnded","datadogRum","startRumImpl","ignoreInitIfSyntheticsWillInjectRum","isAlreadyInitialized","getInternalContextStrategy","getInitConfigurationStrategy","stopSessionStrategy","getSessionReplayLinkStrategy","bufferApiCalls","BoundedBuffer","addTimingStrategy","startViewStrategy","addActionStrategy","addErrorStrategy","providedError","addFeatureFlagEvaluationStrategy","doStartRum","startRumResults","stub","publicApi","rumPublicApi","eventBridgeAvailable","overrideInitConfigurationForBridge","canInitRum","beforeInitCalls","addRumGlobalContext","setGlobalContextProperty","removeRumGlobalContext","removeGlobalContextProperty","getRumGlobalContext","getGlobalContext","setRumGlobalContext","setGlobalContext","clearGlobalContext","getInternalContext","getInitConfiguration","addAction","setUser","isValid","checkUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","removeUser","clearUser","stopSession","startSessionReplayRecording","stopSessionReplayRecording","addFeatureFlagEvaluation","onReady","enumerable","makeRumPublicApi","startRumTelemetry","FEATURE_FLAGS","getFeatureFlagBytesCount","currentContext","startFeatureFlagContexts","pagehideEnabled","stopListeners","stopBeforeUnloadListener","createPageExitObservable","startRumSessionManagerStub","startRumEventBridge","batchFlushObservable","hasFeatureFlagContext","startCustomerDataTelemetry","viewContextHistory","buildViewContext","startViewContexts","previousViewUrl","urlContextHistory","viewUrl","buildUrlContext","changeTime","startUrlContexts","startActionCollection","startRumEventCollection","addTelemetryConfiguration","baseSerializedConfiguration","telemetry_sample_rate","telemetry_configuration_sample_rate","use_before_send","use_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","track_resources","track_long_task","allow_fallback_to_local_storage","serializeConfiguration","premium_sample_rate","replay_sample_rate","trace_sample_rate","action_name_attribute","use_allowed_tracing_origins","use_allowed_tracing_urls","selected_tracing_propagators","default_privacy_level","use_excluded_activity_urls","use_worker_url","track_frustrations","track_views_manually","track_user_interactions","serializeRumConfiguration","startLongTaskCollection","webVitalName","webVitalNode","webVitalTime","computationTime","recordingStartTime","computationDelay","recordingDelay","hasNode","serializedDomNode","replayRecording","replaySampled","startWebVitalTelemetryDebug","internalContext","application_id","session_id","user_action","startInternalContext","q"],"sourceRoot":""}