{"version":3,"file":"datadog-rum.js","mappings":"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","sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils/polyfills.ts","webpack:///../core/src/tools/getGlobalObject.ts","webpack:///../core/src/tools/utils/byteUtils.ts","webpack:///../core/src/tools/getZoneJsOriginalValue.ts","webpack:///../core/src/tools/timer.ts","webpack:///../core/src/tools/utils/functionUtils.ts","webpack:///../core/src/tools/serialisation/jsonStringify.ts","webpack:///../core/src/tools/utils/objectUtils.ts","webpack:///../core/src/domain/context/customerDataTracker.ts","webpack:///../core/src/tools/utils/typeUtils.ts","webpack:///../core/src/tools/mergeInto.ts","webpack:///../core/src/tools/serialisation/sanitize.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/context/contextManager.ts","webpack:///../core/src/domain/trackingConsent.ts","webpack:///../core/src/tools/experimentalFeatures.ts","webpack:///../core/src/tools/utils/numberUtils.ts","webpack:///../core/src/tools/utils/timeUtils.ts","webpack:///../core/src/tools/stackTrace/computeStackTrace.ts","webpack:///../core/src/tools/stackTrace/handlingStack.ts","webpack:///../core/src/domain/error/error.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/tools/sendToExtension.ts","webpack:///../core/src/domain/connectivity/connectivity.ts","webpack:///../core/src/tools/utils/arrayUtils.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/browser/addEventListener.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../core/src/domain/context/storeContextManager.ts","webpack:///../core/src/tools/encoder.ts","webpack:///../core/src/domain/user/user.ts","webpack:///../core/src/boot/displayAlreadyInitializedError.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/tools/utils/stringUtils.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/tools/utils/browserDetection.ts","webpack:///../core/src/domain/session/storeStrategies/sessionStoreStrategy.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/domain/session/sessionState.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInCookie.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInLocalStorage.ts","webpack:///../core/src/domain/session/sessionStoreOperations.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/tools/utils/urlPolyfill.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/tools/matchOption.ts","webpack:///../rum-core/src/domain/tracing/tracer.ts","webpack:///../rum-core/src/domain/configuration/configuration.ts","webpack:///../rum-core/src/domain/configuration/remoteConfiguration.ts","webpack:///../rum-core/src/boot/preStartRum.ts","webpack:///../rum-core/src/domain/plugins.ts","webpack:///../core/src/browser/pageExitObservable.ts","webpack:///../rum-core/src/browser/domMutationObservable.ts","webpack:///../core/src/browser/runOnReadyState.ts","webpack:///../rum-core/src/domain/resource/resourceUtils.ts","webpack:///../rum-core/src/browser/htmlDomUtils.ts","webpack:///../rum-core/src/domain/tracing/getDocumentTraceId.ts","webpack:///../rum-core/src/browser/performanceCollection.ts","webpack:///../core/src/domain/error/error.types.ts","webpack:///../core/src/domain/eventRateLimiter/createEventRateLimiter.ts","webpack:///../rum-core/src/domain/contexts/syntheticsContext.ts","webpack:///../rum-core/src/domain/limitModification.ts","webpack:///../rum-core/src/domain/assembly.ts","webpack:///../core/src/tools/abstractLifeCycle.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../rum-core/src/domain/lifeCycle.ts","webpack:///../core/src/tools/valueHistory.ts","webpack:///../rum-core/src/domain/contexts/viewContexts.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///../rum-core/src/domain/requestCollection.ts","webpack:///../core/src/tools/utils/responseUtils.ts","webpack:///../core/src/tools/readBytesFromStream.ts","webpack:///../rum-core/src/domain/discardNegativeDuration.ts","webpack:///../rum-core/src/domain/trackEventCounts.ts","webpack:///../rum-core/src/domain/waitPageActivityEnd.ts","webpack:///../rum-core/src/browser/polyfills.ts","webpack:///../rum-core/src/domain/privacy.ts","webpack:///../rum-core/src/domain/action/getActionNameFromElement.ts","webpack:///../rum-core/src/domain/getSelectorFromElement.ts","webpack:///../rum-core/src/domain/action/clickChain.ts","webpack:///../rum-core/src/domain/action/listenActionEvents.ts","webpack:///../rum-core/src/domain/action/computeFrustration.ts","webpack:///../rum-core/src/domain/action/trackClickActions.ts","webpack:///../rum-core/src/domain/action/actionCollection.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///../rum-core/src/domain/error/errorCollection.ts","webpack:///../rum-core/src/domain/error/trackConsoleError.ts","webpack:///../rum-core/src/domain/error/trackReportError.ts","webpack:///../rum-core/src/domain/resource/matchRequestTiming.ts","webpack:///../rum-core/src/domain/resource/resourceCollection.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackFirstContentfulPaint.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackLargestContentfulPaint.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackInitialViewMetrics.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackNavigationTimings.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackFirstHidden.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackFirstInput.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackCumulativeLayoutShift.ts","webpack:///../rum-core/src/domain/view/viewMetrics/interactionCountPolyfill.ts","webpack:///../rum-core/src/browser/viewportObservable.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackInteractionToNextPaint.ts","webpack:///../rum-core/src/browser/scroll.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackScrollMetrics.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackCommonViewMetrics.ts","webpack:///../rum-core/src/domain/view/viewMetrics/trackLoadingTime.ts","webpack:///../rum-core/src/domain/view/trackViews.ts","webpack:///../rum-core/src/domain/view/trackViewEventCounts.ts","webpack:///../rum-core/src/domain/view/viewCollection.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///../rum-core/src/domain/rumSessionManager.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../core/src/transport/flushController.ts","webpack:///../rum-core/src/transport/startRumBatch.ts","webpack:///../core/src/transport/startBatchWithReplica.ts","webpack:///../rum-core/src/domain/contexts/urlContexts.ts","webpack:///../rum-core/src/browser/locationChangeObservable.ts","webpack:///../rum-core/src/domain/contexts/featureFlagContext.ts","webpack:///../rum-core/src/domain/startCustomerDataTelemetry.ts","webpack:///../rum-core/src/domain/contexts/pageStateHistory.ts","webpack:///../rum-core/src/domain/vital/vitalCollection.ts","webpack:///../rum-core/src/browser/cookieObservable.ts","webpack:///../rum-core/src/domain/contexts/ciVisibilityContext.ts","webpack:///../rum-core/src/domain/getSessionReplayUrl.ts","webpack:///./src/domain/replayStats.ts","webpack:///./src/domain/record/serialization/serializationUtils.ts","webpack:///./src/types/sessionReplayConstants.ts","webpack:///./src/domain/record/serialization/serializeStyleSheets.ts","webpack:///./src/domain/record/serialization/serializeAttribute.ts","webpack:///./src/domain/record/serialization/serializeAttributes.ts","webpack:///./src/domain/record/serialization/serializeNode.ts","webpack:///./src/domain/record/serialization/serializeDocument.ts","webpack:///./src/domain/record/eventsUtils.ts","webpack:///./src/domain/record/viewports.ts","webpack:///./src/domain/record/assembly.ts","webpack:///./src/domain/record/trackers/trackMove.ts","webpack:///./src/domain/record/trackers/trackMouseInteraction.ts","webpack:///./src/domain/record/trackers/trackScroll.ts","webpack:///./src/domain/record/trackers/trackViewportResize.ts","webpack:///./src/domain/record/trackers/trackMediaInteraction.ts","webpack:///./src/domain/record/trackers/trackStyleSheet.ts","webpack:///./src/domain/record/trackers/trackFocus.ts","webpack:///./src/domain/record/trackers/trackFrustration.ts","webpack:///./src/domain/record/trackers/trackViewEnd.ts","webpack:///./src/domain/record/trackers/trackInput.ts","webpack:///./src/domain/record/mutationBatch.ts","webpack:///./src/domain/record/trackers/trackMutation.ts","webpack:///./src/domain/record/shadowRootsController.ts","webpack:///./src/domain/record/record.ts","webpack:///./src/domain/record/elementsScrollPositions.ts","webpack:///./src/domain/record/startFullSnapshots.ts","webpack:///./src/domain/record/recordIds.ts","webpack:///./src/domain/segmentCollection/segment.ts","webpack:///./src/domain/segmentCollection/segmentCollection.ts","webpack:///./src/domain/segmentCollection/buildReplayPayload.ts","webpack:///./src/boot/isBrowserSupported.ts","webpack:///./src/domain/getSessionReplayLink.ts","webpack:///./src/domain/deflate/deflateEncoder.ts","webpack:///./src/domain/deflate/deflateWorker.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///./src/boot/recorderApi.ts","webpack:///./src/boot/startRecording.ts","webpack:///./src/domain/startRecordBridge.ts","webpack:///../rum-core/src/boot/rumPublicApi.ts","webpack:///../rum-core/src/domain/contexts/commonContext.ts","webpack:///../rum-core/src/boot/startRum.ts","webpack:///../rum-core/src/transport/startRumEventBridge.ts","webpack:///../rum-core/src/domain/contexts/displayContext.ts","webpack:///../rum-core/src/domain/longTask/longTaskCollection.ts","webpack:///../rum-core/src/domain/contexts/internalContext.ts"],"sourcesContent":["/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = (typeof ConsoleApiName)[keyof typeof ConsoleApiName]\n\ninterface Display {\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console\n\nexport const originalConsoleMethods = {} as Display\nObject.keys(ConsoleApiName).forEach((name) => {\n  originalConsoleMethods[name as ConsoleApiName] = globalConsole[name as ConsoleApiName]\n})\n\nconst PREFIX = 'Datadog Browser SDK:'\n\nexport const display: Display = {\n  debug: originalConsoleMethods.debug.bind(globalConsole, PREFIX),\n  log: originalConsoleMethods.log.bind(globalConsole, PREFIX),\n  info: originalConsoleMethods.info.bind(globalConsole, PREFIX),\n  warn: originalConsoleMethods.warn.bind(globalConsole, PREFIX),\n  error: originalConsoleMethods.error.bind(globalConsole, PREFIX),\n}\n\nexport const DOCS_ORIGIN = 'https://docs.datadoghq.com'\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(...args: any[]) {\n  if (debugMode) {\n    display.error('[MONITOR]', ...args)\n  }\n}\n","export function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(array: ArrayLike<unknown>, predicate: (item: unknown, index: number) => boolean): unknown {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function forEach<List extends { [index: number]: any }>(\n  list: List,\n  callback: (value: List[number], index: number, parent: List) => void\n) {\n  Array.prototype.forEach.call(list, callback as any)\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectEntries<T = unknown>(object: { [key: string]: T }): Array<[string, T]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign<T, U, V, W, X>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\n\nexport function getGlobalObject<T = typeof globalThis>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n","export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]) {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n","import { getGlobalObject } from './getGlobalObject'\n\nexport interface BrowserWindowWithZoneJs extends Window {\n  Zone?: {\n    // All Zone.js versions expose the __symbol__ method, but we observed that some website have a\n    // 'Zone' global variable unrelated to Zone.js, so let's consider this method optional\n    // nonetheless.\n    __symbol__?: (name: string) => string\n  }\n}\n\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue<Target, Name extends keyof Target & string>(\n  target: Target,\n  name: Name\n): Target[Name] {\n  const browserWindow = getGlobalObject<BrowserWindowWithZoneJs>()\n  let original: Target[Name] | undefined\n  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n    original = (target as any)[browserWindow.Zone.__symbol__(name)]\n  }\n  if (!original) {\n    original = target[name]\n  }\n  return original\n}\n","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue'\nimport { monitor } from './monitor'\nimport { getGlobalObject } from './getGlobalObject'\n\nexport type TimeoutId = ReturnType<typeof globalThis.setTimeout>\n\nexport function setTimeout(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay)\n}\n\nexport function clearTimeout(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId)\n}\n\nexport function setInterval(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay)\n}\n\nexport function clearInterval(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId)\n}\n","import type { TimeoutId } from '../timer'\nimport { setTimeout, clearTimeout } from '../timer'\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n","import { noop } from '../utils/functionUtils'\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(\n  value: unknown,\n  replacer?: Array<string | number>,\n  space?: string | number\n): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, replacer, space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\nexport interface ObjectWithToJsonMethod {\n  toJSON?: () => unknown\n}\n\nexport function detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n","import { assign } from './polyfills'\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n","import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport type { Context } from '../../tools/serialisation/context'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { DOCS_ORIGIN, display } from '../../tools/display'\nimport { isEmptyObject } from '../../tools/utils/objectUtils'\nimport type { CustomerDataType } from './contextConstants'\n\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE\n\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport const CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE\n\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type CustomerDataTracker = ReturnType<typeof createCustomerDataTracker>\nexport type CustomerDataTrackerManager = ReturnType<typeof createCustomerDataTrackerManager>\n\nexport const enum CustomerDataCompressionStatus {\n  Unknown,\n  Enabled,\n  Disabled,\n}\n\nexport function createCustomerDataTrackerManager(\n  compressionStatus: CustomerDataCompressionStatus = CustomerDataCompressionStatus.Disabled\n) {\n  const customerDataTrackers = new Map<CustomerDataType, CustomerDataTracker>()\n\n  let alreadyWarned = false\n  function checkCustomerDataLimit(initialBytesCount = 0) {\n    if (alreadyWarned || compressionStatus === CustomerDataCompressionStatus.Unknown) {\n      return\n    }\n\n    const bytesCountLimit =\n      compressionStatus === CustomerDataCompressionStatus.Disabled\n        ? CUSTOMER_DATA_BYTES_LIMIT\n        : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT\n\n    let bytesCount = initialBytesCount\n    customerDataTrackers.forEach((tracker) => {\n      bytesCount += tracker.getBytesCount()\n    })\n\n    if (bytesCount > bytesCountLimit) {\n      displayCustomerDataLimitReachedWarning(bytesCountLimit)\n      alreadyWarned = true\n    }\n  }\n\n  return {\n    /**\n     * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n     * bytes count will be counted independently from other detached trackers.\n     *\n     * This is particularly useful when we don't know when the tracker will be unused, so we don't\n     * leak memory (ex: when used in Logger instances).\n     */\n    createDetachedTracker: () => {\n      const tracker = createCustomerDataTracker(() => checkCustomerDataLimit(tracker.getBytesCount()))\n      return tracker\n    },\n\n    /**\n     * Creates a tracker if it doesn't exist, and returns it.\n     */\n    getOrCreateTracker: (type: CustomerDataType) => {\n      if (!customerDataTrackers.has(type)) {\n        customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit))\n      }\n      return customerDataTrackers.get(type)!\n    },\n\n    setCompressionStatus: (newCompressionStatus: CustomerDataCompressionStatus) => {\n      if (compressionStatus === CustomerDataCompressionStatus.Unknown) {\n        compressionStatus = newCompressionStatus\n        checkCustomerDataLimit()\n      }\n    },\n\n    getCompressionStatus: () => compressionStatus,\n\n    stop: () => {\n      customerDataTrackers.forEach((tracker) => tracker.stop())\n      customerDataTrackers.clear()\n    },\n  }\n}\n\nexport function createCustomerDataTracker(checkCustomerDataLimit: () => void) {\n  let bytesCountCache = 0\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled, cancel: cancelComputeBytesCount } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCount(jsonStringify(context)!)\n    checkCustomerDataLimit()\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  const resetBytesCount = () => {\n    cancelComputeBytesCount()\n    bytesCountCache = 0\n  }\n\n  return {\n    updateCustomerData: (context: Context) => {\n      if (isEmptyObject(context)) {\n        resetBytesCount()\n      } else {\n        computeBytesCountThrottled(context)\n      }\n    },\n    resetCustomerData: resetBytesCount,\n    getBytesCount: () => bytesCountCache,\n    stop: () => {\n      cancelComputeBytesCount()\n    },\n  }\n}\n\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit: number) {\n  display.warn(\n    `Customer data exceeds the recommended ${\n      bytesCountLimit / ONE_KIBI_BYTE\n    }KiB threshold. More details: ${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-threshold-warning`\n  )\n}\n","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n","import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n      TDestination extends undefined\n      ? TSource\n      : // case 3 - source is an array - see if it merges or overwrites\n        TSource extends any[]\n        ? TDestination extends any[]\n          ? TDestination & TSource\n          : TSource\n        : // case 4 - source is an object - see if it merges or overwrites\n          TSource extends object\n          ? TDestination extends object\n            ? TDestination extends any[]\n              ? TSource\n              : TDestination & TSource\n            : TSource\n          : // case 5 - cannot merge - return source\n            TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n","import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  let accumulatedCharacterCount = JSON.stringify(sanitizedData)?.length || 0\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value: object) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted,\n      }\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: (observable: Observable<T>) => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe(this) || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  return new Observable<T>((globalObservable) => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n}\n","import { deepClone } from '../../tools/mergeInto'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { Context } from '../../tools/serialisation/context'\nimport { Observable } from '../../tools/observable'\nimport type { CustomerDataTracker } from './customerDataTracker'\n\nexport type ContextManager = ReturnType<typeof createContextManager>\n\nexport function createContextManager(customerDataTracker: CustomerDataTracker) {\n  let context: Context = {}\n  const changeObservable = new Observable<void>()\n\n  const contextManager = {\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      if (getType(newContext) === 'object') {\n        context = sanitize(newContext)\n        customerDataTracker.updateCustomerData(context)\n      } else {\n        contextManager.clearContext()\n      }\n      changeObservable.notify()\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = sanitize(property)\n      customerDataTracker.updateCustomerData(context)\n      changeObservable.notify()\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n      customerDataTracker.updateCustomerData(context)\n      changeObservable.notify()\n    },\n\n    clearContext: () => {\n      context = {}\n      customerDataTracker.resetCustomerData()\n      changeObservable.notify()\n    },\n\n    changeObservable,\n  }\n  return contextManager\n}\n","import { Observable } from '../tools/observable'\n\nexport const TrackingConsent = {\n  GRANTED: 'granted',\n  NOT_GRANTED: 'not-granted',\n} as const\nexport type TrackingConsent = (typeof TrackingConsent)[keyof typeof TrackingConsent]\n\nexport interface TrackingConsentState {\n  tryToInit: (trackingConsent: TrackingConsent) => void\n  update: (trackingConsent: TrackingConsent) => void\n  isGranted: () => boolean\n  observable: Observable<void>\n}\n\nexport function createTrackingConsentState(currentConsent?: TrackingConsent): TrackingConsentState {\n  const observable = new Observable<void>()\n\n  return {\n    tryToInit(trackingConsent: TrackingConsent) {\n      if (!currentConsent) {\n        currentConsent = trackingConsent\n      }\n    },\n    update(trackingConsent: TrackingConsent) {\n      currentConsent = trackingConsent\n      observable.notify()\n    },\n    isGranted() {\n      return currentConsent === TrackingConsent.GRANTED\n    },\n    observable,\n  }\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\n\nimport { objectHasValue } from './utils/objectUtils'\n\n// eslint-disable-next-line no-restricted-syntax\nexport enum ExperimentalFeature {\n  WRITABLE_RESOURCE_GRAPHQL = 'writable_resource_graphql',\n  CUSTOM_VITALS = 'custom_vitals',\n  TOLERANT_RESOURCE_TIMINGS = 'tolerant_resource_timings',\n  REMOTE_CONFIGURATION = 'remote_configuration',\n  PLUGINS = 'plugins',\n}\n\nconst enabledExperimentalFeatures: Set<ExperimentalFeature> = new Set()\n\nexport function initFeatureFlags(enableExperimentalFeatures?: string[] | undefined) {\n  if (Array.isArray(enableExperimentalFeatures)) {\n    addExperimentalFeatures(\n      enableExperimentalFeatures.filter((flag): flag is ExperimentalFeature =>\n        objectHasValue(ExperimentalFeature, flag)\n      )\n    )\n  }\n}\n\nexport function addExperimentalFeatures(enabledFeatures: ExperimentalFeature[]): void {\n  enabledFeatures.forEach((flag) => {\n    enabledExperimentalFeatures.add(flag)\n  })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: ExperimentalFeature): boolean {\n  return enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures.clear()\n}\n\nexport function getExperimentalFeatures(): Set<ExperimentalFeature> {\n  return enabledExperimentalFeatures\n}\n","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n","import { isNumber, round } from './numberUtils'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nexport function timeStampToClocks(timeStamp: TimeStamp) {\n  return { relative: getRelativeTime(timeStamp), timeStamp }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","/**\n * Cross-browser stack trace computation.\n *\n * Reference implementation: https://github.com/csnover/TraceKit/blob/04530298073c3823de72deb0b97e7b38ca7bcb59/tracekit.js\n */\n\nimport { startsWith } from '../utils/polyfills'\n\nexport interface StackFrame {\n  url?: string\n  func?: string\n  /** The arguments passed to the function, if known. */\n  args?: string[]\n  line?: number\n  column?: number\n  /** An array of source code lines; the middle element corresponds to the correct line. */\n  context?: string[]\n}\n\nexport interface StackTrace {\n  name?: string\n  message?: string\n  url?: string\n  stack: StackFrame[]\n  incomplete?: boolean\n  partial?: boolean\n}\n\nconst UNKNOWN_FUNCTION = '?'\n\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function computeStackTraceFromOnErrorMessage(messageObj: unknown, url?: string, line?: number, column?: number) {\n  const stack = [{ url, column, line }]\n  const { name, message } = tryToParseMessage(messageObj)\n  return {\n    name,\n    message,\n    stack,\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/\n\nfunction tryToParseMessage(messageObj: unknown) {\n  let name\n  let message\n  if ({}.toString.call(messageObj) === '[object String]') {\n    ;[, name, message] = ERROR_TYPES_RE.exec(messageObj as string)!\n  }\n  return { name, message }\n}\n","import { callMonitored } from '../monitor'\nimport { noop } from '../utils/functionUtils'\nimport type { StackTrace } from './computeStackTrace'\nimport { computeStackTrace } from './computeStackTrace'\n\n/**\n * Creates a stacktrace without SDK internal frames.\n * Constraints:\n * - Has to be called at the utmost position of the call stack.\n * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n","import { sanitize } from '../../tools/serialisation/sanitize'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport type { ErrorSource, ErrorHandling, RawError, RawErrorCause, ErrorWithCause, NonErrorPrefix } from './error.types'\n\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error'\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: NonErrorPrefix\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  const isErrorInstance = originalError instanceof Error\n\n  const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError)\n  const stack = hasUsableStack(isErrorInstance, stackTrace)\n    ? toStackTraceString(stackTrace)\n    : NO_ERROR_STACK_PRESENT_MESSAGE\n  const causes = isErrorInstance ? flattenErrorCauses(originalError as ErrorWithCause, source) : undefined\n  const type = stackTrace?.name\n  const fingerprint = tryToGetFingerprint(originalError)\n\n  return {\n    startClocks,\n    source,\n    handling,\n    handlingStack,\n    originalError,\n    type,\n    message,\n    stack,\n    causes,\n    fingerprint,\n  }\n}\n\nfunction computeMessage(\n  stackTrace: StackTrace | undefined,\n  isErrorInstance: boolean,\n  nonErrorPrefix: NonErrorPrefix,\n  originalError: unknown\n) {\n  // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n  // TODO rework tracekit integration to avoid scattering error building logic\n  return stackTrace?.message && stackTrace?.name\n    ? stackTrace.message\n    : !isErrorInstance\n      ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))!}`\n      : 'Empty message'\n}\n\nfunction hasUsableStack(isErrorInstance: boolean, stackTrace?: StackTrace): stackTrace is StackTrace {\n  if (stackTrace === undefined) {\n    return false\n  }\n  if (isErrorInstance) {\n    return true\n  }\n  // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n  // TODO rework tracekit integration to avoid generating those unusable stack\n  return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined)\n}\n\nexport function tryToGetFingerprint(originalError: unknown) {\n  return originalError instanceof Error && 'dd_fingerprint' in originalError\n    ? String(originalError.dd_fingerprint)\n    : undefined\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_FED_STAGING = 'dd0g-gov.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n\nexport const PCI_INTAKE_HOST_US1 = 'pci.browser-intake-datadoghq.com'\n","interface BrowserWindow {\n  __ddBrowserSdkExtensionCallback?: (message: unknown) => void\n}\n\ntype ExtensionMessageType = 'logs' | 'record' | 'rum' | 'telemetry'\n\nexport function sendToExtension(type: ExtensionMessageType, payload: unknown) {\n  const callback = (window as BrowserWindow).__ddBrowserSdkExtensionCallback\n  if (callback) {\n    callback({ type, payload })\n  }\n}\n","export type NetworkInterface = 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown'\nexport type EffectiveType = 'slow-2g' | '2g' | '3g' | '4g'\n\ninterface BrowserNavigator extends Navigator {\n  connection?: NetworkInformation\n}\n\nexport interface NetworkInformation {\n  type?: NetworkInterface\n  effectiveType?: EffectiveType\n}\n\nexport interface Connectivity {\n  status: 'connected' | 'not_connected'\n  interfaces?: NetworkInterface[]\n  effective_type?: EffectiveType\n  [key: string]: unknown\n}\n\nexport function getConnectivity(): Connectivity {\n  const navigator = window.navigator as BrowserNavigator\n  return {\n    status: navigator.onLine ? 'connected' : 'not_connected',\n    interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n    effective_type: navigator.connection?.effectiveType,\n  }\n}\n","import { arrayFrom } from './polyfills'\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n\nexport function removeItem<T>(array: T[], item: T) {\n  const index = array.indexOf(item)\n  if (index >= 0) {\n    array.splice(index, 1)\n  }\n}\n","import { removeItem } from './utils/arrayUtils'\n\nconst BUFFER_LIMIT = 500\n\nexport class BoundedBuffer<T = void> {\n  private buffer: Array<(arg: T) => void> = []\n\n  add(callback: (arg: T) => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  remove(callback: (arg: T) => void) {\n    removeItem(this.buffer, callback)\n  }\n\n  drain(arg: T) {\n    this.buffer.forEach((callback) => callback(arg))\n    this.buffer.length = 0\n  }\n}\n","import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { CookieStore, CookieStoreEventMap, VisualViewport, VisualViewportEventMap } from './types'\n\nexport type TrustableEvent<E extends Event = Event> = E & { __ddIsTrusted?: boolean }\n\n// We want to use a real enum (i.e. not a const enum) here, to be able to iterate over it to automatically add _ddIsTrusted in e2e tests\n// eslint-disable-next-line no-restricted-syntax\nexport enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n  STORAGE = 'storage',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n    ? DocumentEventMap\n    : T extends HTMLElement\n      ? HTMLElementEventMap\n      : T extends VisualViewport\n        ? VisualViewportEventMap\n        : T extends ShadowRoot\n          ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n            // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n            // through the ShadowRoot like \"change\" or \"input\"\n            GlobalEventHandlersEventMap\n          : T extends XMLHttpRequest\n            ? XMLHttpRequestEventMap\n            : T extends Performance\n              ? PerformanceEventMap\n              : T extends Worker\n                ? WorkerEventMap\n                : T extends CookieStore\n                  ? CookieStoreEventMap\n                  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: { allowUntrustedEvents?: boolean | undefined },\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: { allowUntrustedEvents?: boolean | undefined },\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const listenerWithMonitor = monitor((event: TrustableEvent) => {\n    if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n      return\n    }\n    if (once) {\n      stop()\n    }\n    listener(event as unknown as EventMapFor<Target>[EventName] & { type: EventName })\n  })\n\n  const options = passive ? { capture, passive } : capture\n\n  const add = getZoneJsOriginalValue(eventTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options))\n  }\n\n  return {\n    stop,\n  }\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent, TelemetryUsageEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n  usage: 'usage',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport interface RuntimeEnvInfo {\n  is_local_file: boolean\n  is_worker: boolean\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\nexport type RawTelemetryUsage = TelemetryUsageEvent['telemetry']['usage']\n","import type { Context } from '../../tools/serialisation/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { NO_ERROR_STACK_PRESENT_MESSAGE } from '../error/error'\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Configuration } from '../configuration'\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport { sendToExtension } from '../../tools/sendToExtension'\nimport { startsWith, arrayFrom, includes, assign } from '../../tools/utils/polyfills'\nimport { performDraw } from '../../tools/utils/numberUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { combine } from '../../tools/mergeInto'\nimport { NonErrorPrefix } from '../error/error.types'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { getConnectivity } from '../connectivity'\nimport { BoundedBuffer } from '../../tools/boundedBuffer'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type {\n  RawTelemetryConfiguration,\n  RawTelemetryEvent,\n  RuntimeEnvInfo,\n  RawTelemetryUsage,\n} from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'https://d3uc069fcn7uxw.cloudfront.net',\n  'https://d20xtzwzcl0ceb.cloudfront.net',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n  enabled: boolean\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\n// eslint-disable-next-line local-rules/disallow-side-effects\nlet preStartTelemetryBuffer = new BoundedBuffer()\nlet onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n  preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event))\n}\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n  const alreadySentEvents = new Set<string>()\n\n  const telemetryEnabled =\n    !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate)\n\n  const telemetryEnabledPerType = {\n    [TelemetryType.log]: telemetryEnabled,\n    [TelemetryType.configuration]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n    [TelemetryType.usage]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n  }\n\n  const runtimeEnvInfo = getRuntimeEnvInfo()\n  onRawTelemetryEventCollected = (rawEvent: RawTelemetryEvent) => {\n    const stringifiedEvent = jsonStringify(rawEvent)!\n    if (\n      telemetryEnabledPerType[rawEvent.type!] &&\n      alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&\n      !alreadySentEvents.has(stringifiedEvent)\n    ) {\n      const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo)\n      observable.notify(event)\n      sendToExtension('telemetry', event)\n      alreadySentEvents.add(stringifiedEvent)\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  function toTelemetryEvent(\n    telemetryService: TelemetryService,\n    event: RawTelemetryEvent,\n    runtimeEnvInfo: RuntimeEnvInfo\n  ): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: combine(event, {\n          runtime_env: runtimeEnvInfo,\n          connectivity: getConnectivity(),\n        }),\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    ) as TelemetryEvent & Context\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n    enabled: telemetryEnabled,\n  }\n}\nfunction getRuntimeEnvInfo(): RuntimeEnvInfo {\n  return {\n    is_local_file: window.location.protocol === 'file:',\n    is_worker: 'WorkerGlobalScope' in self,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\n// need to be called after telemetry context is provided and observers are registered\nexport function drainPreStartTelemetry() {\n  preStartTelemetryBuffer.drain()\n}\n\nexport function resetTelemetry() {\n  preStartTelemetryBuffer = new BoundedBuffer()\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event))\n  }\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  onRawTelemetryEventCollected(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown, context?: Context) {\n  onRawTelemetryEventCollected(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e),\n      context\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.configuration,\n    configuration,\n  })\n}\n\nexport function addTelemetryUsage(usage: RawTelemetryUsage) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.usage,\n    usage,\n  })\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n    },\n    message: `${NonErrorPrefix.UNCAUGHT} ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport type { Context } from '../../tools/serialisation/context'\nimport type { Configuration } from '../configuration'\nimport { combine } from '../../tools/mergeInto'\nimport type { ContextManager } from './contextManager'\nimport type { CustomerDataType } from './contextConstants'\n\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c'\n\nconst storageListeners: Array<{ stop: () => void }> = []\n\nexport function storeContextManager(\n  configuration: Configuration,\n  contextManager: ContextManager,\n  productKey: string,\n  customerDataType: CustomerDataType\n) {\n  const storageKey = buildStorageKey(productKey, customerDataType)\n\n  storageListeners.push(\n    addEventListener(configuration, window, DOM_EVENT.STORAGE, ({ key }) => {\n      if (storageKey === key) {\n        synchronizeWithStorage()\n      }\n    })\n  )\n  contextManager.changeObservable.subscribe(dumpToStorage)\n\n  contextManager.setContext(combine(getFromStorage(), contextManager.getContext()))\n\n  function synchronizeWithStorage() {\n    contextManager.setContext(getFromStorage())\n  }\n\n  function dumpToStorage() {\n    localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()))\n  }\n\n  function getFromStorage() {\n    const rawContext = localStorage.getItem(storageKey)\n    return rawContext !== null ? (JSON.parse(rawContext) as Context) : {}\n  }\n}\n\nexport function buildStorageKey(productKey: string, customerDataType: CustomerDataType) {\n  return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`\n}\n\nexport function removeStorageListeners() {\n  storageListeners.map((listener) => listener.stop())\n}\n","import { computeBytesCount } from './utils/byteUtils'\n\nexport interface Encoder<Output extends string | Uint8Array = string | Uint8Array> {\n  /**\n   * Whether this encoder might call the provided callbacks asynchronously\n   */\n  isAsync: boolean\n\n  /**\n   * Whether some data has been written since the last finish() or finishSync() call\n   */\n  isEmpty: boolean\n\n  /**\n   * Write a string to be encoded.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * If specified, the callback will be invoked when the operation finishes, unless the operation is\n   * asynchronous and finish() or finishSync() is called in the meantime.\n   */\n  write(data: string, callback?: (additionalEncodedBytesCount: number) => void): void\n\n  /**\n   * Waits for pending data to be encoded and resets the encoder state.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * The callback will be invoked when the operation finishes, unless the operation is asynchronous\n   * and another call to finish() or finishSync() occurs in the meantime.\n   */\n  finish(callback: (result: EncoderResult<Output>) => void): void\n\n  /**\n   * Resets the encoder state then returns the encoded data and any potential pending data directly,\n   * discarding all pending write operations and finish() callbacks.\n   */\n  finishSync(): EncoderResult<Output> & { pendingData: string }\n\n  /**\n   * Returns a rough estimation of the bytes count if the data was encoded.\n   */\n  estimateEncodedBytesCount(data: string): number\n}\n\nexport interface EncoderResult<Output extends string | Uint8Array = string | Uint8Array> {\n  output: Output\n  outputBytesCount: number\n\n  /**\n   * An encoding type supported by HTTP Content-Encoding, if applicable.\n   * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding#directives\n   */\n  encoding?: 'deflate'\n\n  /**\n   * Total bytes count of the input strings encoded to UTF-8.\n   */\n  rawBytesCount: number\n}\n\nexport function createIdentityEncoder(): Encoder<string> {\n  let output = ''\n  let outputBytesCount = 0\n\n  return {\n    isAsync: false,\n\n    get isEmpty() {\n      return !output\n    },\n\n    write(data, callback) {\n      const additionalEncodedBytesCount = computeBytesCount(data)\n      outputBytesCount += additionalEncodedBytesCount\n      output += data\n      if (callback) {\n        callback(additionalEncodedBytesCount)\n      }\n    },\n\n    finish(callback) {\n      callback(this.finishSync())\n    },\n\n    finishSync() {\n      const result = {\n        output,\n        outputBytesCount,\n        rawBytesCount: outputBytesCount,\n        pendingData: '',\n      }\n      output = ''\n      outputBytesCount = 0\n      return result\n    },\n\n    estimateEncodedBytesCount(data) {\n      return data.length\n    },\n  }\n}\n","import type { Context } from '../../tools/serialisation/context'\nimport { display } from '../../tools/display'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { User } from './user.types'\n\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser: Context): Context {\n  // We shallow clone only to prevent mutation of user data.\n  const user = assign({}, newUser)\n  const keys = ['id', 'name', 'email']\n  keys.forEach((key) => {\n    if (key in user) {\n      user[key] = String(user[key])\n    }\n  })\n  return user\n}\n\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser: User): boolean {\n  const isValid = getType(newUser) === 'object'\n  if (!isValid) {\n    display.error('Unsupported user:', newUser)\n  }\n  return isValid\n}\n","import type { InitConfiguration } from '../domain/configuration'\nimport { display } from '../tools/display'\n\nexport function displayAlreadyInitializedError(sdkName: 'DD_RUM' | 'DD_LOGS', initConfiguration: InitConfiguration) {\n  if (!initConfiguration.silentMultipleInit) {\n    display.error(`${sdkName} is already initialized.`)\n  }\n}\n","import { endsWith, includes } from '../tools/utils/polyfills'\nimport { getGlobalObject } from '../tools/getGlobalObject'\nimport type { DefaultPrivacyLevel } from '../domain/configuration'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getCapabilities?(): string\n  getPrivacyLevel?(): DefaultPrivacyLevel\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport const enum BridgeCapability {\n  RECORDS = 'records',\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getCapabilities() {\n      return JSON.parse(eventBridgeGlobal.getCapabilities?.() || '[]') as BridgeCapability[]\n    },\n    getPrivacyLevel() {\n      return eventBridgeGlobal.getPrivacyLevel?.()\n    },\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E, viewId?: string) {\n      const view = viewId ? { id: viewId } : undefined\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event, view }))\n    },\n  }\n}\n\nexport function bridgeSupports(capability: BridgeCapability): boolean {\n  const bridge = getEventBridge()\n  return !!bridge && includes(bridge.getCapabilities(), capability)\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\nconst COMMA_SEPARATED_KEY_VALUE = /([\\w-]+)\\s*=\\s*([^;]+)/g\n\nexport function findCommaSeparatedValue(rawString: string, name: string): string | undefined {\n  COMMA_SEPARATED_KEY_VALUE.lastIndex = 0\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString)\n    if (match) {\n      if (match[1] === name) {\n        return match[2]\n      }\n    } else {\n      break\n    }\n  }\n}\n\nexport function findCommaSeparatedValues(rawString: string): Map<string, string> {\n  const result = new Map<string, string>()\n  COMMA_SEPARATED_KEY_VALUE.lastIndex = 0\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString)\n    if (match) {\n      result.set(match[1], match[2])\n    } else {\n      break\n    }\n  }\n  return result\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) {\n    return candidate\n  }\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n","import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  partitioned?: boolean\n  domain?: string\n}\n\nexport function setCookie(name: string, value: string, _expireDelay: number, _options?: CookieOptions) {\n  sessionStorage.setItem(name, value)\n}\n\nexport function getCookie(name: string) {\n  return sessionStorage.getItem(name)\n}\n\nlet initCookieParsed: Map<string, string> | undefined\n\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name: string) {\n  if (!initCookieParsed) {\n    initCookieParsed = findCommaSeparatedValues(document.cookie)\n  }\n  return initCookieParsed.get(name)\n}\n\nexport function resetInitCookies() {\n  initCookieParsed = undefined\n}\n\nexport function deleteCookie(name: string, _options?: CookieOptions) {\n  sessionStorage.removeItem(name)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","import { getInitCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value =\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","// Exported only for tests\nexport const enum Browser {\n  IE,\n  CHROMIUM,\n  SAFARI,\n  OTHER,\n}\n\nexport function isIE() {\n  return detectBrowserCached() === Browser.IE\n}\n\nexport function isChromium() {\n  return detectBrowserCached() === Browser.CHROMIUM\n}\n\nexport function isSafari() {\n  return detectBrowserCached() === Browser.SAFARI\n}\n\nlet browserCache: Browser | undefined\nfunction detectBrowserCached() {\n  return browserCache ?? (browserCache = detectBrowser())\n}\n\n// Exported only for tests\nexport function detectBrowser(browserWindow: Window = window) {\n  const userAgent = browserWindow.navigator.userAgent\n  if ((browserWindow as any).chrome || /HeadlessChrome/.test(userAgent)) {\n    return Browser.CHROMIUM\n  }\n\n  if (\n    // navigator.vendor is deprecated, but it is the most resilient way we found to detect\n    // \"Apple maintained browsers\" (AKA Safari). If one day it gets removed, we still have the\n    // useragent test as a semi-working fallback.\n    browserWindow.navigator.vendor?.indexOf('Apple') === 0 ||\n    (/safari/i.test(userAgent) && !/chrome|android/i.test(userAgent))\n  ) {\n    return Browser.SAFARI\n  }\n\n  if ((browserWindow.document as any).documentMode) {\n    return Browser.IE\n  }\n\n  return Browser.OTHER\n}\n","import type { CookieOptions } from '../../../browser/cookie'\nimport type { SessionState } from '../sessionState'\n\nexport const SESSION_STORE_KEY = '_dd_s'\n\nexport type SessionStoreStrategyType = { type: 'Cookie'; cookieOptions: CookieOptions } | { type: 'LocalStorage' }\n\nexport interface SessionStoreStrategy {\n  isLockEnabled: boolean\n  persistSession: (session: SessionState) => void\n  retrieveSession: () => SessionState\n  expireSession: () => void\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils/timeUtils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { objectEntries } from '../../tools/utils/polyfills'\nimport { dateNow } from '../../tools/utils/timeUtils'\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from './sessionConstants'\n\nconst SESSION_ENTRY_REGEXP = /^([a-zA-Z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport const EXPIRED = '1'\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  isExpired?: typeof EXPIRED\n\n  [key: string]: string | undefined\n}\n\nexport function getExpiredSessionState(): SessionState {\n  return {\n    isExpired: EXPIRED,\n  }\n}\n\nexport function isSessionInNotStartedState(session: SessionState) {\n  return isEmptyObject(session)\n}\n\nexport function isSessionStarted(session: SessionState) {\n  return !isSessionInNotStartedState(session)\n}\n\nexport function isSessionInExpiredState(session: SessionState) {\n  return session.isExpired !== undefined || !isActiveSession(session)\n}\n\n// An active session is a session in either `Tracked` or `NotTracked` state\nfunction isActiveSession(sessionState: SessionState) {\n  // created and expire can be undefined for versions which was not storing them\n  // these checks could be removed when older versions will not be available/live anymore\n  return (\n    (sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n    (sessionState.expire === undefined || dateNow() < Number(sessionState.expire))\n  )\n}\n\nexport function expandSessionState(session: SessionState) {\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n}\n\nexport function toSessionString(session: SessionState) {\n  return objectEntries(session)\n    .map(([key, value]) => `${key}=${value}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function toSessionState(sessionString: string | undefined | null) {\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined | null): sessionString is string {\n  return (\n    !!sessionString &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n","import { getInitCookie } from '../../browser/cookie'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionStarted } from './sessionState'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy: SessionStoreStrategy) {\n  const sessionString = getInitCookie(SESSION_STORE_KEY)\n  if (!sessionString) {\n    const oldSessionId = getInitCookie(OLD_SESSION_COOKIE_NAME)\n    const oldRumType = getInitCookie(OLD_RUM_COOKIE_NAME)\n    const oldLogsType = getInitCookie(OLD_LOGS_COOKIE_NAME)\n    const session: SessionState = {}\n\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n\n    if (isSessionStarted(session)) {\n      expandSessionState(session)\n      cookieStoreStrategy.persistSession(session)\n    }\n  }\n}\n","import { isChromium } from '../../../tools/utils/browserDetection'\nimport type { CookieOptions } from '../../../browser/cookie'\nimport { getCurrentSite, areCookiesAuthorized, getCookie, setCookie } from '../../../browser/cookie'\nimport type { InitConfiguration } from '../../configuration'\nimport { tryOldCookiesMigration } from '../oldCookiesMigration'\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nexport function selectCookieStrategy(initConfiguration: InitConfiguration): SessionStoreStrategyType | undefined {\n  const cookieOptions = buildCookieOptions(initConfiguration)\n  return areCookiesAuthorized(cookieOptions) ? { type: 'Cookie', cookieOptions } : undefined\n}\n\nexport function initCookieStrategy(cookieOptions: CookieOptions): SessionStoreStrategy {\n  const cookieStore = {\n    /**\n     * Lock strategy allows mitigating issues due to concurrent access to cookie.\n     * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n     */\n    isLockEnabled: isChromium(),\n    persistSession: persistSessionCookie(cookieOptions),\n    retrieveSession: retrieveSessionCookie,\n    expireSession: () => expireSessionCookie(cookieOptions),\n  }\n\n  tryOldCookiesMigration(cookieStore)\n\n  return cookieStore\n}\n\nfunction persistSessionCookie(options: CookieOptions) {\n  return (session: SessionState) => {\n    setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n  }\n}\n\nfunction expireSessionCookie(options: CookieOptions) {\n  setCookie(SESSION_STORE_KEY, toSessionString(getExpiredSessionState()), SESSION_TIME_OUT_DELAY, options)\n}\n\nfunction retrieveSessionCookie(): SessionState {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  cookieOptions.secure =\n    !!initConfiguration.useSecureSessionCookie ||\n    !!initConfiguration.usePartitionedCrossSiteSessionCookie ||\n    !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.crossSite =\n    !!initConfiguration.usePartitionedCrossSiteSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n","import { generateUUID } from '../../../tools/utils/stringUtils'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_'\n\nexport function selectLocalStorageStrategy(): SessionStoreStrategyType | undefined {\n  try {\n    const id = generateUUID()\n    const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`\n    localStorage.setItem(testKey, id)\n    const retrievedId = localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n    return id === retrievedId ? { type: 'LocalStorage' } : undefined\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function initLocalStorageStrategy(): SessionStoreStrategy {\n  return {\n    isLockEnabled: false,\n    persistSession: persistInLocalStorage,\n    retrieveSession: retrieveSessionFromLocalStorage,\n    expireSession: expireSessionFromLocalStorage,\n  }\n}\n\nfunction persistInLocalStorage(sessionState: SessionState) {\n  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState))\n}\n\nfunction retrieveSessionFromLocalStorage(): SessionState {\n  const sessionString = localStorage.getItem(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction expireSessionFromLocalStorage() {\n  persistInLocalStorage(getExpiredSessionState())\n}\n","import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { isLockEnabled, persistSession, expireSession } = sessionStoreStrategy\n  const persistWithLock = (session: SessionState) => persistSession(assign({}, session, { lock: currentLock }))\n  const retrieveStore = () => {\n    const session = sessionStoreStrategy.retrieveSession()\n    const lock = session.lock\n\n    if (session.lock) {\n      delete session.lock\n    }\n\n    return {\n      session,\n      lock,\n    }\n  }\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentStore = retrieveStore()\n  if (isLockEnabled) {\n    // if someone has lock, retry later\n    if (currentStore.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = generateUUID()\n    persistWithLock(currentStore.session)\n    // if lock is not acquired, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentStore.session)\n  if (isLockEnabled) {\n    // if lock corrupted after process, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      expireSession()\n    } else {\n      expandSessionState(processedSession)\n      isLockEnabled ? persistWithLock(processedSession) : persistSession(processedSession)\n    }\n  }\n  if (isLockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentStore = retrieveStore()\n      if (currentStore.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      persistSession(currentStore.session)\n      processedSession = currentStore.session\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentStore.session)\n  next(sessionStoreStrategy)\n}\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n","import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from '../configuration'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport {\n  getExpiredSessionState,\n  isSessionInExpiredState,\n  isSessionInNotStartedState,\n  isSessionStarted,\n} from './sessionState'\nimport type { SessionState } from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  restartSession: () => void\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  sessionStateUpdateObservable: Observable<{ previousState: SessionState; newState: SessionState }>\n  expire: () => void\n  stop: () => void\n  updateSessionState: (state: Partial<SessionState>) => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy()\n  }\n  return sessionStoreStrategyType\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n  const sessionStateUpdateObservable = new Observable<{ previousState: SessionState; newState: SessionState }>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === 'Cookie'\n      ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy()\n  const { expireSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState\n\n  startSession()\n\n  const { throttled: throttledExpandOrRenewSession, cancel: cancelExpandOrRenewSession } = throttle(() => {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return\n          }\n\n          const synchronizedSession = synchronizeSession(sessionState)\n          expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isSessionStarted(sessionState) && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }, STORAGE_POLL_DELAY)\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (isSessionInExpiredState(sessionState) ? getExpiredSessionState() : undefined),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (isSessionInExpiredState(sessionState)) {\n      sessionState = getExpiredSessionState()\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionStateUpdateObservable.notify({ previousState: sessionCache, newState: sessionState })\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function startSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return getExpiredSessionState()\n          }\n        },\n        after: (sessionState) => {\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    if (isSessionInNotStartedState(sessionState)) {\n      return false\n    }\n\n    const { trackingType, isTracked } = computeSessionState(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    delete sessionState.isExpired\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = getExpiredSessionState()\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  function updateSessionState(partialSessionState: Partial<SessionState>) {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => assign({}, sessionState, partialSessionState),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  return {\n    expandOrRenewSession: throttledExpandOrRenewSession,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    sessionStateUpdateObservable,\n    restartSession: startSession,\n    expire: () => {\n      cancelExpandOrRenewSession()\n      expireSession()\n      synchronizeSession(getExpiredSessionState())\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n    updateSessionState,\n  }\n}\n","import { jsonStringify } from '../serialisation/jsonStringify'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, location.href).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function buildUrl(url: string, base?: string) {\n  const supportedURL = getSupportedUrl()\n  if (supportedURL) {\n    try {\n      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url)\n    } catch (error) {\n      throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })!}`)\n    }\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nconst originalURL = URL\nlet isURLSupported: boolean | undefined\nfunction getSupportedUrl(): typeof URL | undefined {\n  if (isURLSupported === undefined) {\n    try {\n      const url = new originalURL('http://test/path')\n      isURLSupported = url.href === 'http://test/path'\n    } catch {\n      isURLSupported = false\n    }\n  }\n  return isURLSupported ? originalURL : undefined\n}\n","import type { Payload } from '../../transport'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_US1, INTAKE_SITE_FED_STAGING, PCI_INTAKE_HOST_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport type TrackType = 'logs' | 'rum' | 'replay'\nexport type ApiType =\n  | 'xhr'\n  | 'fetch'\n  | 'beacon'\n  // 'manual' reflects that the request have been sent manually, outside of the SDK (ex: via curl or\n  // a Node.js script).\n  | 'manual'\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  trackType: TrackType,\n  configurationTags: string[]\n) {\n  const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, trackType)\n\n  return {\n    build(api: ApiType, payload: Payload) {\n      const parameters = buildEndpointParameters(initConfiguration, trackType, configurationTags, api, payload)\n      return buildUrlWithParameters(parameters)\n    },\n    urlPrefix: buildUrlWithParameters(''),\n    trackType,\n  }\n}\n\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(\n  initConfiguration: InitConfiguration,\n  trackType: TrackType\n): (parameters: string) => string {\n  const path = `/api/v2/${trackType}`\n  const proxy = initConfiguration.proxy\n  if (typeof proxy === 'string') {\n    const normalizedProxyUrl = normalizeUrl(proxy)\n    return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`\n  }\n  if (typeof proxy === 'function') {\n    return (parameters) => proxy({ path, parameters })\n  }\n  const host = buildEndpointHost(trackType, initConfiguration)\n  return (parameters) => `https://${host}${path}?${parameters}`\n}\n\nfunction buildEndpointHost(trackType: TrackType, initConfiguration: InitConfiguration & { usePciIntake?: boolean }) {\n  const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration\n\n  if (trackType === 'logs' && initConfiguration.usePciIntake && site === INTAKE_SITE_US1) {\n    return PCI_INTAKE_HOST_US1\n  }\n\n  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n    return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`\n  }\n\n  if (site === INTAKE_SITE_FED_STAGING) {\n    return `http-intake.logs.${site}`\n  }\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  return `browser-intake-${domainParts.join('-')}.${extension!}`\n}\n\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(\n  { clientToken, internalAnalyticsSubdomain }: InitConfiguration,\n  trackType: TrackType,\n  configurationTags: string[],\n  api: ApiType,\n  { retry, encoding }: Payload\n) {\n  const tags = [`sdk_version:${__BUILD_ENV__SDK_VERSION__}`, `api:${api}`].concat(configurationTags)\n  if (retry) {\n    tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`)\n  }\n\n  const parameters = [\n    'ddsource=browser',\n    `ddtags=${encodeURIComponent(tags.join(','))}`,\n    `dd-api-key=${clientToken}`,\n    `dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}`,\n    'dd-evp-origin=browser',\n    `dd-request-id=${generateUUID()}`,\n  ]\n\n  if (encoding) {\n    parameters.push(`dd-evp-encoding=${encoding}`)\n  }\n\n  if (trackType === 'rum') {\n    parameters.push(`batch_time=${timeStampNow()}`)\n  }\n\n  if (internalAnalyticsSubdomain) {\n    parameters.reverse()\n  }\n\n  return parameters.join('&')\n}\n","import { DOCS_ORIGIN, display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(\n      `${key} value doesn't meet tag requirements and will be sanitized. More details: ${DOCS_ORIGIN}/getting_started/tagging/#defining-tags`\n    )\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { objectValues, assign } from '../../tools/utils/polyfills'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1, PCI_INTAKE_HOST_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const site = initConfiguration.site || INTAKE_SITE_US1\n\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeUrlPrefixes = computeIntakeUrlPrefixes(endpointBuilders, site)\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeUrlPrefixes.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'replay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeUrlPrefixes: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeUrlPrefixes.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.urlPrefix))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n\nfunction computeIntakeUrlPrefixes(\n  endpointBuilders: ReturnType<typeof computeEndpointBuilders>,\n  site: string\n): string[] {\n  const intakeUrlPrefixes = objectValues(endpointBuilders).map((builder) => builder.urlPrefix)\n\n  if (site === INTAKE_SITE_US1) {\n    intakeUrlPrefixes.push(`https://${PCI_INTAKE_HOST_US1}/`)\n  }\n\n  return intakeUrlPrefixes\n}\n","import { catchUserErrors } from '../../tools/catchUserErrors'\nimport { DOCS_ORIGIN, display } from '../../tools/display'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport type { Duration } from '../../tools/utils/timeUtils'\nimport { ONE_SECOND } from '../../tools/utils/timeUtils'\nimport { isPercentage } from '../../tools/utils/numberUtils'\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { objectHasValue } from '../../tools/utils/objectUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectSessionStoreStrategyType } from '../session/sessionStore'\nimport type { SessionStoreStrategyType } from '../session/storeStrategies/sessionStoreStrategy'\nimport { TrackingConsent } from '../trackingConsent'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = (typeof DefaultPrivacyLevel)[keyof typeof DefaultPrivacyLevel]\n\nexport const TraceContextInjection = {\n  ALL: 'all',\n  SAMPLED: 'sampled',\n} as const\n\nexport type TraceContextInjection = (typeof TraceContextInjection)[keyof typeof TraceContextInjection]\n\nexport interface InitConfiguration {\n  /**\n   * The client token for Datadog. Required for authenticating your application with Datadog.\n   */\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  /**\n   * The percentage of sessions tracked. A value between 0 and 100.\n   * @default 100\n   */\n  sessionSampleRate?: number | undefined\n  /**\n   * The percentage of telemetry events sent. A value between 0 and 100.\n   * @default 20\n   */\n  telemetrySampleRate?: number | undefined\n  /**\n   * Initialization fails silently if the RUM Browser SDK is already initialized on the page.\n   * @default false\n   */\n  silentMultipleInit?: boolean | undefined\n  /**\n   * Allows the use of localStorage when cookies cannot be set. This enables the RUM Browser SDK to run in environments that do not provide cookie support.\n   * See [Monitor Electron Applications Using the Browser SDK](https://docs.datadoghq.com/real_user_monitoring/guide/monitor-electron-applications-using-browser-sdk) for further information.\n   * @default false\n   */\n  allowFallbackToLocalStorage?: boolean | undefined\n  /**\n   * Allow listening to DOM events dispatched programmatically ([untrusted events](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted)). Enabling this option can be useful if you heavily rely on programmatic events, such as in an automated UI test environment.\n   * @default false\n   */\n  allowUntrustedEvents?: boolean | undefined\n  /**\n   * Store global context and user context in localStorage to preserve them along the user navigation.\n   * See [Contexts life cycle](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#contexts-life-cycle) for further information.\n   * @default false\n   */\n  storeContextsAcrossPages?: boolean | undefined\n  /**\n   * Set the initial user tracking consent state.\n   * See [User tracking consent](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#user-tracking-consent) for further information.\n   * @default granted\n   */\n  trackingConsent?: TrackingConsent | undefined\n\n  // transport options\n  /**\n   * Optional proxy URL, for example: https://www.proxy.com/path.\n   * See [Proxy Your Browser RUM Data](https://docs.datadoghq.com/real_user_monitoring/guide/proxy-rum-data) for further information.\n   */\n  proxy?: string | ProxyFn | undefined\n  /**\n   * The Datadog [site](https://docs.datadoghq.com/getting_started/site) parameter of your organization.\n   * @default datadoghq.com\n   */\n  site?: string | undefined\n\n  // tag and context options\n  /**\n   * The service name for your application. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  service?: string | undefined | null\n  /**\n   * The application’s environment, for example: prod, pre-prod, and staging. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  env?: string | undefined | null\n  /**\n   * The application’s version, for example: 1.2.3, 6c44da20, and 2020.02.13. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  version?: string | undefined | null\n\n  // cookie options\n  /**\n   * Whether a secure cross-site session cookie is used\n   * @default false\n   * @deprecated use usePartitionedCrossSiteSessionCookie instead\n   */\n  useCrossSiteSessionCookie?: boolean | undefined\n  /**\n   * Use a partitioned secure cross-site session cookie. This allows the RUM Browser SDK to run when the site is loaded from another one (iframe). Implies `useSecureSessionCookie`.\n   * @default false\n   */\n  usePartitionedCrossSiteSessionCookie?: boolean | undefined\n  /**\n   * Use a secure session cookie. This disables RUM events sent on insecure (non-HTTPS) connections.\n   * @default false\n   */\n  useSecureSessionCookie?: boolean | undefined\n  /**\n   * Preserve the session across subdomains for the same site.\n   * @default false\n   */\n  trackSessionAcrossSubdomains?: boolean | undefined\n\n  // internal options\n  /**\n   * [Internal option] Enable experimental features\n   */\n  enableExperimentalFeatures?: string[] | undefined\n  /**\n   * [Internal option] Configure the dual chipping to another datacenter\n   */\n  replica?: ReplicaUserConfiguration | undefined\n  /**\n   * [Internal option] Set the datacenter from where the data is dual chipped\n   */\n  datacenter?: string\n  /**\n   * [Internal option] Datadog internal analytics subdomain\n   */\n  // TODO next major: remove this option and replace usages by proxyFn\n  internalAnalyticsSubdomain?: string\n  /**\n   * [Internal option] The percentage of telemetry configuration sent. A value between 0 and 100.\n   * @default 5\n   */\n  telemetryConfigurationSampleRate?: number\n  /**\n   * [Internal option] The percentage of telemetry usage sent. A value between 0 and 100.\n   * @default 5\n   */\n  telemetryUsageSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\n/**\n * path: /api/vX/product\n * parameters: xxx=yyy&zzz=aaa\n */\ntype ProxyFn = (options: { path: string; parameters: string }) => string\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  sessionStoreStrategyType: SessionStoreStrategyType | undefined\n  sessionSampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  telemetryUsageSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n  allowUntrustedEvents: boolean\n  trackingConsent: TrackingConsent\n  storeContextsAcrossPages: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: Duration\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nfunction checkIfString(tag: unknown, tagName: string): tag is string | undefined | null {\n  if (tag !== undefined && tag !== null && typeof tag !== 'string') {\n    display.error(`${tagName} must be defined as a string`)\n    return false\n  }\n  return true\n}\n\nfunction isDatadogSite(site: string) {\n  return /(datadog|ddog|datad0g|dd0g)/.test(site)\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  if (initConfiguration.sessionSampleRate !== undefined && !isPercentage(initConfiguration.sessionSampleRate)) {\n    display.error('Session Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryUsageSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryUsageSampleRate)\n  ) {\n    display.error('Telemetry Usage Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (!checkIfString(initConfiguration.version, 'Version')) {\n    return\n  }\n\n  if (!checkIfString(initConfiguration.env, 'Env')) {\n    return\n  }\n\n  if (!checkIfString(initConfiguration.service, 'Service')) {\n    return\n  }\n\n  if (\n    initConfiguration.trackingConsent !== undefined &&\n    !objectHasValue(TrackingConsent, initConfiguration.trackingConsent)\n  ) {\n    display.error('Tracking Consent should be either \"granted\" or \"not-granted\"')\n    return\n  }\n\n  if (initConfiguration.site && !isDatadogSite(initConfiguration.site)) {\n    display.error(`Site should be a valid Datadog site. Learn more here: ${DOCS_ORIGIN}/getting_started/site/.`)\n    return\n  }\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n      sessionSampleRate: initConfiguration.sessionSampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      telemetryUsageSampleRate: initConfiguration.telemetryUsageSampleRate ?? 5,\n      service: initConfiguration.service || undefined,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n      allowUntrustedEvents: !!initConfiguration.allowUntrustedEvents,\n      trackingConsent: initConfiguration.trackingConsent ?? TrackingConsent.GRANTED,\n      storeContextsAcrossPages: !!initConfiguration.storeContextsAcrossPages,\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: (30 * ONE_SECOND) as Duration,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function serializeConfiguration(initConfiguration: InitConfiguration) {\n  return {\n    session_sample_rate: initConfiguration.sessionSampleRate,\n    telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n    telemetry_usage_sample_rate: initConfiguration.telemetryUsageSampleRate,\n    use_before_send: !!initConfiguration.beforeSend,\n    use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,\n    use_partitioned_cross_site_session_cookie: initConfiguration.usePartitionedCrossSiteSessionCookie,\n    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n    use_proxy: !!initConfiguration.proxy,\n    silent_multiple_init: initConfiguration.silentMultipleInit,\n    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n    store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n    allow_untrusted_events: !!initConfiguration.allowUntrustedEvents,\n    tracking_consent: initConfiguration.trackingConsent,\n  } satisfies RawTelemetryConfiguration\n}\n","import { startsWith } from './utils/polyfills'\nimport { display } from './display'\nimport { getType } from './utils/typeUtils'\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\n\nexport function isMatchOption(item: unknown): item is MatchOption {\n  const itemType = getType(item)\n  return itemType === 'string' || itemType === 'function' || item instanceof RegExp\n}\n\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list: MatchOption[], value: string, useStartsWith = false): boolean {\n  return list.some((item) => {\n    try {\n      if (typeof item === 'function') {\n        return item(value)\n      } else if (item instanceof RegExp) {\n        return item.test(value)\n      } else if (typeof item === 'string') {\n        return useStartsWith ? startsWith(value, item) : item === value\n      }\n    } catch (e) {\n      display.error(e)\n    }\n    return false\n  })\n}\n","import {\n  objectEntries,\n  shallowClone,\n  performDraw,\n  isNumber,\n  assign,\n  find,\n  getType,\n  isMatchOption,\n  matchList,\n  TraceContextInjection,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchResolveContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { PropagatorType, TracingOption } from './tracer.types'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchResolveContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\nexport function isTracingOption(item: unknown): item is TracingOption {\n  const expectedItem = item as TracingOption\n  return (\n    getType(expectedItem) === 'object' &&\n    isMatchOption(expectedItem.match) &&\n    Array.isArray(expectedItem.propagatorTypes)\n  )\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchResolveContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(configuration: RumConfiguration, sessionManager: RumSessionManager): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        if (context.input instanceof Request && !context.init?.headers) {\n          context.input = new Request(context.input)\n          Object.keys(tracingHeaders).forEach((key) => {\n            ;(context.input as Request).headers.append(key, tracingHeaders[key])\n          })\n        } else {\n          context.init = shallowClone(context.init)\n          const headers: Array<[string, string]> = []\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach((value, key) => {\n              headers.push([key, value])\n            })\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach((header) => {\n              headers.push(header)\n            })\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach((key) => {\n              headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n            })\n          }\n          context.init.headers = headers.concat(objectEntries(tracingHeaders))\n        }\n      }),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        Object.keys(tracingHeaders).forEach((name) => {\n          xhr.setRequestHeader(name, tracingHeaders[name])\n        })\n      }),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  if (!isTracingSupported() || !sessionManager.findTrackedSession()) {\n    return\n  }\n\n  const tracingOption = find(configuration.allowedTracingUrls, (tracingOption: TracingOption) =>\n    matchList([tracingOption.match], context.url!, true)\n  )\n  if (!tracingOption) {\n    return\n  }\n  context.traceSampled = !isNumber(configuration.traceSampleRate) || performDraw(configuration.traceSampleRate)\n\n  if (!context.traceSampled && configuration.traceContextInjection !== TraceContextInjection.ALL) {\n    return\n  }\n\n  context.traceId = new TraceIdentifier()\n  context.spanId = new TraceIdentifier()\n\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes))\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined\n}\n\nfunction getCrypto() {\n  return window.crypto || (window as any).msCrypto\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(\n  traceId: TraceIdentifier,\n  spanId: TraceIdentifier,\n  traceSampled: boolean,\n  propagatorTypes: PropagatorType[]\n): TracingHeaders {\n  const tracingHeaders: TracingHeaders = {}\n\n  propagatorTypes.forEach((propagatorType) => {\n    switch (propagatorType) {\n      case 'datadog': {\n        assign(tracingHeaders, {\n          'x-datadog-origin': 'rum',\n          'x-datadog-parent-id': spanId.toDecimalString(),\n          'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n          'x-datadog-trace-id': traceId.toDecimalString(),\n        })\n        break\n      }\n      // https://www.w3.org/TR/trace-context/\n      case 'tracecontext': {\n        assign(tracingHeaders, {\n          traceparent: `00-0000000000000000${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-0${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      // https://github.com/openzipkin/b3-propagation\n      case 'b3': {\n        assign(tracingHeaders, {\n          b3: `${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      case 'b3multi': {\n        assign(tracingHeaders, {\n          'X-B3-TraceId': traceId.toPaddedHexadecimalString(),\n          'X-B3-SpanId': spanId.toPaddedHexadecimalString(),\n          'X-B3-Sampled': traceSampled ? '1' : '0',\n        })\n        break\n      }\n    }\n  })\n  return tracingHeaders\n}\n\n/* eslint-disable no-bitwise */\nexport class TraceIdentifier {\n  private buffer: Uint8Array = new Uint8Array(8)\n\n  constructor() {\n    getCrypto().getRandomValues(this.buffer)\n    this.buffer[0] = this.buffer[0] & 0x7f // force 63-bit\n  }\n\n  toString(radix: number) {\n    let high = this.readInt32(0)\n    let low = this.readInt32(4)\n    let str = ''\n\n    do {\n      const mod = (high % radix) * 4294967296 + low\n      high = Math.floor(high / radix)\n      low = Math.floor(mod / radix)\n      str = (mod % radix).toString(radix) + str\n    } while (high || low)\n\n    return str\n  }\n\n  /**\n   * Format used everywhere except the trace intake\n   */\n  toDecimalString() {\n    return this.toString(10)\n  }\n\n  /**\n   * Format used by OTel headers\n   */\n  toPaddedHexadecimalString() {\n    const traceId = this.toString(16)\n    return Array(17 - traceId.length).join('0') + traceId\n  }\n\n  private readInt32(offset: number) {\n    return (\n      this.buffer[offset] * 16777216 +\n      (this.buffer[offset + 1] << 16) +\n      (this.buffer[offset + 2] << 8) +\n      this.buffer[offset + 3]\n    )\n  }\n}\n/* eslint-enable no-bitwise */\n","import type { Configuration, InitConfiguration, MatchOption, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  getType,\n  arrayFrom,\n  isMatchOption,\n  serializeConfiguration,\n  assign,\n  DefaultPrivacyLevel,\n  TraceContextInjection,\n  display,\n  isPercentage,\n  objectHasValue,\n  validateAndBuildConfiguration,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../../domainContext.types'\nimport type { RumEvent } from '../../rumEvent.types'\nimport type { RumPlugin } from '../plugins'\nimport { isTracingOption } from '../tracing/tracer'\nimport type { PropagatorType, TracingOption } from '../tracing/tracer.types'\n\nexport const DEFAULT_PROPAGATOR_TYPES: PropagatorType[] = ['tracecontext', 'datadog']\n\nexport interface RumInitConfiguration extends InitConfiguration {\n  // global options\n  /**\n   * The RUM application ID.\n   */\n  applicationId: string\n  /**\n   * Access to every event collected by the RUM SDK before they are sent to Datadog.\n   * It allows:\n   * - Enrich your RUM events with additional context attributes\n   * - Modify your RUM events to modify their content, or redact sensitive sequences (see the list of editable properties)\n   * - Discard selected RUM events\n   *\n   * See [Enrich And Control Browser RUM Data With beforeSend](https://docs.datadoghq.com/real_user_monitoring/guide/enrich-and-control-rum-data) for further information.\n   */\n  beforeSend?: ((event: RumEvent, context: RumEventDomainContext) => boolean) | undefined\n  /**\n   * A list of request origins ignored when computing the page activity.\n   * See [How page activity is calculated](https://docs.datadoghq.com/real_user_monitoring/browser/monitoring_page_performance/#how-page-activity-is-calculated) for further information.\n   */\n  excludedActivityUrls?: MatchOption[] | undefined\n  /**\n   * URL pointing to the Datadog Browser SDK Worker JavaScript file. The URL can be relative or absolute, but is required to have the same origin as the web application.\n   * See [Content Security Policy guidelines](https://docs.datadoghq.com/integrations/content_security_policy_logs/?tab=firefox#use-csp-with-real-user-monitoring-and-session-replay) for further information.\n   */\n  workerUrl?: string\n  /**\n   * Compress requests sent to the Datadog intake to reduce bandwidth usage when sending large amounts of data. The compression is done in a Worker thread.\n   * See [Content Security Policy guidelines](https://docs.datadoghq.com/integrations/content_security_policy_logs/?tab=firefox#use-csp-with-real-user-monitoring-and-session-replay) for further information.\n   */\n  compressIntakeRequests?: boolean | undefined\n  remoteConfigurationId?: string | undefined\n\n  // tracing options\n  /**\n   * A list of request URLs used to inject tracing headers.\n   * See [Connect RUM and Traces](https://docs.datadoghq.com/real_user_monitoring/platform/connect_rum_and_traces/?tab=browserrum) for further information.\n   */\n  allowedTracingUrls?: Array<MatchOption | TracingOption> | undefined\n\n  /**\n   * The percentage of requests to trace: 100 for all, 0 for none.\n   * See [Connect RUM and Traces](https://docs.datadoghq.com/real_user_monitoring/platform/connect_rum_and_traces/?tab=browserrum) for further information.\n   */\n  traceSampleRate?: number | undefined\n  /**\n   * If you set a `traceSampleRate`, to ensure backend services' sampling decisions are still applied, configure the `traceContextInjection` initialization parameter to sampled.\n   * @default all\n   * See [Connect RUM and Traces](https://docs.datadoghq.com/real_user_monitoring/platform/connect_rum_and_traces/?tab=browserrum) for further information.\n   */\n  traceContextInjection?: TraceContextInjection | undefined\n\n  // replay options\n  /**\n   * Allow to protect end user privacy and prevent sensitive organizational information from being collected.\n   * @default mask\n   * See [Replay Privacy Options](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser/privacy_options) for further information.\n   */\n  defaultPrivacyLevel?: DefaultPrivacyLevel | undefined\n  /**\n   * If you are accessing Datadog through a custom subdomain, you can set `subdomain` to include your custom domain in the `getSessionReplayLink()` returned URL .\n   * See [Connect Session Replay To Your Third-Party Tools](https://docs.datadoghq.com/real_user_monitoring/guide/connect-session-replay-to-your-third-party-tools) for further information.\n   */\n  subdomain?: string\n  /**\n   * The percentage of tracked sessions with [Browser RUM & Session Replay pricing](https://www.datadoghq.com/pricing/?product=real-user-monitoring--session-replay#real-user-monitoring--session-replay) features: 100 for all, 0 for none.\n   * See [Configure Your Setup For Browser RUM and Browser RUM & Session Replay Sampling](https://docs.datadoghq.com/real_user_monitoring/guide/sampling-browser-plans) for further information.\n   */\n  sessionReplaySampleRate?: number | undefined\n  /**\n   * If the session is sampled for Session Replay, only start the recording when `startSessionReplayRecording()` is called, instead of at the beginning of the session.\n   * See [Session Replay Usage](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser/#usage) for further information.\n   */\n  startSessionReplayRecordingManually?: boolean | undefined\n\n  /**\n   * Enables privacy control for action names.\n   */\n  enablePrivacyForActionName?: boolean | undefined // TODO next major: remove this option and make privacy for action name the default behavior\n  /**\n   * Enables automatic collection of users actions.\n   * See [Tracking User Actions](https://docs.datadoghq.com/real_user_monitoring/browser/tracking_user_actions) for further information.\n   */\n  trackUserInteractions?: boolean | undefined\n  /**\n   * Specify your own attribute to use to name actions.\n   * See [Declare a name for click actions](https://docs.datadoghq.com/real_user_monitoring/browser/tracking_user_actions/#declare-a-name-for-click-actions) for further information.\n   */\n  actionNameAttribute?: string | undefined\n\n  // view options\n  /**\n   * Allows you to control RUM views creation. See [Override default RUM view names](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#override-default-rum-view-names) for further information.\n   */\n  trackViewsManually?: boolean | undefined\n  /**\n   * Enables collection of resource events.\n   */\n  trackResources?: boolean | undefined\n  /**\n   * Enables collection of long task events.\n   */\n  trackLongTasks?: boolean | undefined\n\n  /**\n   * List of plugins to enable. The plugins API is unstable and experimental, and may change without\n   * notice. Please use only plugins provided by Datadog matching the version of the SDK you are\n   * using.\n   */\n  plugins?: RumPlugin[] | undefined\n}\n\nexport type HybridInitConfiguration = Omit<RumInitConfiguration, 'applicationId' | 'clientToken'>\n\nexport interface RumConfiguration extends Configuration {\n  // Built from init configuration\n  actionNameAttribute: string | undefined\n  traceSampleRate: number | undefined\n  allowedTracingUrls: TracingOption[]\n  excludedActivityUrls: MatchOption[]\n  workerUrl: string | undefined\n  compressIntakeRequests: boolean\n  applicationId: string\n  defaultPrivacyLevel: DefaultPrivacyLevel\n  enablePrivacyForActionName: boolean\n  sessionReplaySampleRate: number\n  startSessionReplayRecordingManually: boolean\n  trackUserInteractions: boolean\n  trackViewsManually: boolean\n  trackResources: boolean\n  trackLongTasks: boolean\n  version?: string\n  subdomain?: string\n  customerDataTelemetrySampleRate: number\n  traceContextInjection: TraceContextInjection\n  plugins: RumPlugin[]\n}\n\nexport function validateAndBuildRumConfiguration(\n  initConfiguration: RumInitConfiguration\n): RumConfiguration | undefined {\n  if (!initConfiguration.applicationId) {\n    display.error('Application ID is not configured, no RUM data will be collected.')\n    return\n  }\n\n  if (\n    initConfiguration.sessionReplaySampleRate !== undefined &&\n    !isPercentage(initConfiguration.sessionReplaySampleRate)\n  ) {\n    display.error('Session Replay Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.traceSampleRate !== undefined && !isPercentage(initConfiguration.traceSampleRate)) {\n    display.error('Trace Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n    display.error('Excluded Activity Urls should be an array')\n    return\n  }\n\n  const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration)\n  if (!allowedTracingUrls) {\n    return\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n  if (!baseConfiguration) {\n    return\n  }\n\n  return assign(\n    {\n      applicationId: initConfiguration.applicationId,\n      version: initConfiguration.version || undefined,\n      actionNameAttribute: initConfiguration.actionNameAttribute,\n      sessionReplaySampleRate: initConfiguration.sessionReplaySampleRate ?? 0,\n      startSessionReplayRecordingManually: !!initConfiguration.startSessionReplayRecordingManually,\n      traceSampleRate: initConfiguration.traceSampleRate,\n      allowedTracingUrls,\n      excludedActivityUrls: initConfiguration.excludedActivityUrls ?? [],\n      workerUrl: initConfiguration.workerUrl,\n      compressIntakeRequests: !!initConfiguration.compressIntakeRequests,\n      trackUserInteractions: !!initConfiguration.trackUserInteractions,\n      trackViewsManually: !!initConfiguration.trackViewsManually,\n      trackResources: !!initConfiguration.trackResources,\n      trackLongTasks: !!initConfiguration.trackLongTasks,\n      subdomain: initConfiguration.subdomain,\n      defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n        ? initConfiguration.defaultPrivacyLevel\n        : DefaultPrivacyLevel.MASK,\n      enablePrivacyForActionName: !!initConfiguration.enablePrivacyForActionName,\n      customerDataTelemetrySampleRate: 1,\n      traceContextInjection: objectHasValue(TraceContextInjection, initConfiguration.traceContextInjection)\n        ? initConfiguration.traceContextInjection\n        : TraceContextInjection.ALL,\n      plugins: (isExperimentalFeatureEnabled(ExperimentalFeature.PLUGINS) && initConfiguration.plugins) || [],\n    },\n    baseConfiguration\n  )\n}\n\n/**\n * Validates allowedTracingUrls and converts match options to tracing options\n */\nfunction validateAndBuildTracingOptions(initConfiguration: RumInitConfiguration): TracingOption[] | undefined {\n  if (initConfiguration.allowedTracingUrls !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {\n      display.error('Allowed Tracing URLs should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service needs to be configured when tracing is enabled')\n      return\n    }\n    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties\n    const tracingOptions: TracingOption[] = []\n    initConfiguration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        tracingOptions.push({ match: option, propagatorTypes: DEFAULT_PROPAGATOR_TYPES })\n      } else if (isTracingOption(option)) {\n        tracingOptions.push(option)\n      } else {\n        display.warn(\n          'Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter',\n          option\n        )\n      }\n    })\n\n    return tracingOptions\n  }\n\n  return []\n}\n\n/**\n * Combines the selected tracing propagators from the different options in allowedTracingUrls\n */\nfunction getSelectedTracingPropagators(configuration: RumInitConfiguration): PropagatorType[] {\n  const usedTracingPropagators = new Set<PropagatorType>()\n\n  if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {\n    configuration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        DEFAULT_PROPAGATOR_TYPES.forEach((propagatorType) => usedTracingPropagators.add(propagatorType))\n      } else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {\n        // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)\n        option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType))\n      }\n    })\n  }\n\n  return arrayFrom(usedTracingPropagators)\n}\n\nexport function serializeRumConfiguration(configuration: RumInitConfiguration) {\n  const baseSerializedConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      session_replay_sample_rate: configuration.sessionReplaySampleRate,\n      start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n      trace_sample_rate: configuration.traceSampleRate,\n      trace_context_injection: configuration.traceContextInjection,\n      action_name_attribute: configuration.actionNameAttribute,\n      use_allowed_tracing_urls:\n        Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,\n      selected_tracing_propagators: getSelectedTracingPropagators(configuration),\n      default_privacy_level: configuration.defaultPrivacyLevel,\n      enable_privacy_for_action_name: configuration.enablePrivacyForActionName,\n      use_excluded_activity_urls:\n        Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,\n      use_worker_url: !!configuration.workerUrl,\n      compress_intake_requests: configuration.compressIntakeRequests,\n      track_views_manually: configuration.trackViewsManually,\n      track_user_interactions: configuration.trackUserInteractions,\n      track_resources: configuration.trackResources,\n      track_long_task: configuration.trackLongTasks,\n      plugins: configuration.plugins?.map((plugin) =>\n        assign({ name: plugin.name }, plugin.getConfigurationTelemetry?.())\n      ),\n    },\n    baseSerializedConfiguration\n  ) satisfies RawTelemetryConfiguration\n}\n","import type { DefaultPrivacyLevel } from '@datadog/browser-core'\nimport { display, addEventListener, assign } from '@datadog/browser-core'\nimport type { RumInitConfiguration } from './configuration'\n\nexport const REMOTE_CONFIGURATION_URL = 'https://d3uc069fcn7uxw.cloudfront.net/configuration'\n\nexport interface RumRemoteConfiguration {\n  sessionSampleRate?: number\n  sessionReplaySampleRate?: number\n  defaultPrivacyLevel?: DefaultPrivacyLevel\n}\n\nexport function fetchAndApplyRemoteConfiguration(\n  initConfiguration: RumInitConfiguration,\n  callback: (initConfiguration: RumInitConfiguration) => void\n) {\n  fetchRemoteConfiguration(initConfiguration, (remoteInitConfiguration) => {\n    callback(applyRemoteConfiguration(initConfiguration, remoteInitConfiguration))\n  })\n}\n\nexport function applyRemoteConfiguration(\n  initConfiguration: RumInitConfiguration,\n  remoteInitConfiguration: RumRemoteConfiguration\n) {\n  return assign({}, initConfiguration, remoteInitConfiguration)\n}\n\nexport function fetchRemoteConfiguration(\n  configuration: RumInitConfiguration,\n  callback: (remoteConfiguration: RumRemoteConfiguration) => void\n) {\n  const xhr = new XMLHttpRequest()\n\n  addEventListener(configuration, xhr, 'load', function () {\n    if (xhr.status === 200) {\n      callback(JSON.parse(xhr.responseText))\n    } else {\n      displayRemoteConfigurationFetchingError()\n    }\n  })\n\n  addEventListener(configuration, xhr, 'error', function () {\n    displayRemoteConfigurationFetchingError()\n  })\n\n  xhr.open('GET', `${REMOTE_CONFIGURATION_URL}/${encodeURIComponent(configuration.remoteConfigurationId!)}.json`)\n  xhr.send()\n}\n\nfunction displayRemoteConfigurationFetchingError() {\n  display.error('Error fetching the remote configuration.')\n}\n","import {\n  BoundedBuffer,\n  display,\n  canUseEventBridge,\n  displayAlreadyInitializedError,\n  willSyntheticsInjectRum,\n  noop,\n  timeStampNow,\n  clocksNow,\n  assign,\n  getEventBridge,\n  ExperimentalFeature,\n  isExperimentalFeatureEnabled,\n  initFeatureFlags,\n  addTelemetryConfiguration,\n} from '@datadog/browser-core'\nimport type { TrackingConsentState, DeflateWorker } from '@datadog/browser-core'\nimport {\n  validateAndBuildRumConfiguration,\n  type RumConfiguration,\n  type RumInitConfiguration,\n} from '../domain/configuration'\nimport type { CommonContext } from '../domain/contexts/commonContext'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport { fetchAndApplyRemoteConfiguration, serializeRumConfiguration } from '../domain/configuration'\nimport { callPluginsMethod } from '../domain/plugins'\nimport type { RumPublicApiOptions, Strategy } from './rumPublicApi'\nimport type { StartRumResult } from './startRum'\n\nexport function createPreStartStrategy(\n  { ignoreInitIfSyntheticsWillInjectRum, startDeflateWorker }: RumPublicApiOptions,\n  getCommonContext: () => CommonContext,\n  trackingConsentState: TrackingConsentState,\n  doStartRum: (\n    configuration: RumConfiguration,\n    deflateWorker: DeflateWorker | undefined,\n    initialViewOptions?: ViewOptions\n  ) => StartRumResult\n): Strategy {\n  const bufferApiCalls = new BoundedBuffer<StartRumResult>()\n  let firstStartViewCall:\n    | { options: ViewOptions | undefined; callback: (startRumResult: StartRumResult) => void }\n    | undefined\n  let deflateWorker: DeflateWorker | undefined\n\n  let cachedInitConfiguration: RumInitConfiguration | undefined\n  let cachedConfiguration: RumConfiguration | undefined\n\n  const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartRum)\n\n  function tryStartRum() {\n    if (!cachedInitConfiguration || !cachedConfiguration || !trackingConsentState.isGranted()) {\n      return\n    }\n\n    trackingConsentStateSubscription.unsubscribe()\n\n    let initialViewOptions: ViewOptions | undefined\n\n    if (cachedConfiguration.trackViewsManually) {\n      if (!firstStartViewCall) {\n        return\n      }\n      // An initial view is always created when starting RUM.\n      // When tracking views automatically, any startView call before RUM start creates an extra\n      // view.\n      // When tracking views manually, we use the ViewOptions from the first startView call as the\n      // initial view options, and we remove the actual startView call so we don't create an extra\n      // view.\n      bufferApiCalls.remove(firstStartViewCall.callback)\n      initialViewOptions = firstStartViewCall.options\n    }\n\n    const startRumResult = doStartRum(cachedConfiguration, deflateWorker, initialViewOptions)\n\n    bufferApiCalls.drain(startRumResult)\n  }\n\n  function doInit(initConfiguration: RumInitConfiguration) {\n    const eventBridgeAvailable = canUseEventBridge()\n    if (eventBridgeAvailable) {\n      initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n    }\n\n    // Update the exposed initConfiguration to reflect the bridge and remote configuration overrides\n    cachedInitConfiguration = initConfiguration\n    addTelemetryConfiguration(serializeRumConfiguration(initConfiguration))\n\n    if (cachedConfiguration) {\n      displayAlreadyInitializedError('DD_RUM', initConfiguration)\n      return\n    }\n\n    const configuration = validateAndBuildRumConfiguration(initConfiguration)\n    if (!configuration) {\n      return\n    }\n\n    if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {\n      display.warn('No storage available for session. We will not send any data.')\n      return\n    }\n\n    if (configuration.compressIntakeRequests && !eventBridgeAvailable && startDeflateWorker) {\n      deflateWorker = startDeflateWorker(\n        configuration,\n        'Datadog RUM',\n        // Worker initialization can fail asynchronously, especially in Firefox where even CSP\n        // issues are reported asynchronously. For now, the SDK will continue its execution even if\n        // data won't be sent to Datadog. We could improve this behavior in the future.\n        noop\n      )\n      if (!deflateWorker) {\n        // `startDeflateWorker` should have logged an error message explaining the issue\n        return\n      }\n    }\n\n    cachedConfiguration = configuration\n    trackingConsentState.tryToInit(configuration.trackingConsent)\n    tryStartRum()\n  }\n\n  return {\n    init(initConfiguration, publicApi) {\n      if (!initConfiguration) {\n        display.error('Missing configuration')\n        return\n      }\n      // Set the experimental feature flags as early as possible, so we can use them in most places\n      initFeatureFlags(initConfiguration.enableExperimentalFeatures)\n\n      // Expose the initial configuration regardless of initialization success.\n      cachedInitConfiguration = initConfiguration\n\n      // If we are in a Synthetics test configured to automatically inject a RUM instance, we want\n      // to completely discard the customer application RUM instance by ignoring their init() call.\n      // But, we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n      // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n      if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n        return\n      }\n\n      if (isExperimentalFeatureEnabled(ExperimentalFeature.PLUGINS)) {\n        callPluginsMethod(initConfiguration.plugins, 'onInit', { initConfiguration, publicApi })\n      }\n\n      if (\n        initConfiguration.remoteConfigurationId &&\n        isExperimentalFeatureEnabled(ExperimentalFeature.REMOTE_CONFIGURATION)\n      ) {\n        fetchAndApplyRemoteConfiguration(initConfiguration, doInit)\n      } else {\n        doInit(initConfiguration)\n      }\n    },\n\n    get initConfiguration() {\n      return cachedInitConfiguration\n    },\n\n    getInternalContext: noop as () => undefined,\n\n    stopSession: noop,\n\n    addTiming(name, time = timeStampNow()) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addTiming(name, time))\n    },\n\n    startView(options, startClocks = clocksNow()) {\n      const callback = (startRumResult: StartRumResult) => {\n        startRumResult.startView(options, startClocks)\n      }\n      bufferApiCalls.add(callback)\n\n      if (!firstStartViewCall) {\n        firstStartViewCall = { options, callback }\n        tryStartRum()\n      }\n    },\n\n    addAction(action, commonContext = getCommonContext()) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addAction(action, commonContext))\n    },\n\n    addError(providedError, commonContext = getCommonContext()) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addError(providedError, commonContext))\n    },\n\n    addFeatureFlagEvaluation(key, value) {\n      bufferApiCalls.add((startRumResult) => startRumResult.addFeatureFlagEvaluation(key, value))\n    },\n\n    startDurationVital(vitalStart) {\n      bufferApiCalls.add((startRumResult) => startRumResult.startDurationVital(vitalStart))\n    },\n\n    stopDurationVital(vitalStart) {\n      bufferApiCalls.add((startRumResult) => startRumResult.stopDurationVital(vitalStart))\n    },\n  }\n}\n\nfunction overrideInitConfigurationForBridge(initConfiguration: RumInitConfiguration): RumInitConfiguration {\n  return assign({}, initConfiguration, {\n    applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n    clientToken: 'empty',\n    sessionSampleRate: 100,\n    defaultPrivacyLevel: initConfiguration.defaultPrivacyLevel ?? getEventBridge()?.getPrivacyLevel(),\n  })\n}\n","import type { RumPublicApi } from '../boot/rumPublicApi'\nimport type { RumInitConfiguration } from './configuration'\n\nexport interface RumPlugin {\n  name: string\n  getConfigurationTelemetry?(): Record<string, unknown>\n  onInit?(options: { initConfiguration: RumInitConfiguration; publicApi: RumPublicApi }): void\n}\n\ntype MethodNames = 'onInit'\ntype MethodParameter<MethodName extends MethodNames> = Parameters<NonNullable<RumPlugin[MethodName]>>[0]\n\nexport function callPluginsMethod<MethodName extends MethodNames>(\n  plugins: RumPlugin[] | undefined,\n  methodName: MethodName,\n  parameter: MethodParameter<MethodName>\n) {\n  if (!plugins) {\n    return\n  }\n  for (const plugin of plugins) {\n    const method = plugin[methodName]\n    if (method) {\n      method(parameter)\n    }\n  }\n}\n","import { Observable } from '../tools/observable'\nimport { objectValues, includes } from '../tools/utils/polyfills'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageExitObservable(configuration: Configuration): Observable<PageExitEvent> {\n  return new Observable<PageExitEvent>((observable) => {\n    const { stop: stopListeners } = addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE],\n      (event) => {\n        if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    const stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, () => {\n      observable.notify({ reason: PageExitReason.UNLOADING })\n    }).stop\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n}\n\nexport function isPageExitReason(reason: string | undefined): reason is PageExitReason {\n  return includes(objectValues(PageExitReason), reason)\n}\n","import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core'\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  return new Observable<void>((observable) => {\n    if (!MutationObserver) {\n      return\n    }\n    const observer = new MutationObserver(monitor(() => observable.notify()))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n}\n\ntype MutationObserverConstructor = new (callback: MutationCallback) => MutationObserver\n\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: unknown\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow: BrowserWindow = window\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver')\n\n    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as {\n        originalInstance?: { constructor: MutationObserverConstructor }\n      }\n\n      const originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance')\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n","import type { Configuration } from '../domain/configuration'\nimport { DOM_EVENT, addEventListener } from './addEventListener'\n\nexport function runOnReadyState(\n  configuration: Configuration,\n  expectedReadyState: 'complete' | 'interactive',\n  callback: () => void\n) {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n  } else {\n    const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n    addEventListener(configuration, window, eventName, callback, { once: true })\n  }\n}\n","import type { RelativeTime, ServerDuration } from '@datadog/browser-core'\nimport {\n  addTelemetryDebug,\n  elapsed,\n  ExperimentalFeature,\n  getPathName,\n  includes,\n  isExperimentalFeatureEnabled,\n  isValidUrl,\n  ResourceType,\n  toServerDuration,\n} from '@datadog/browser-core'\n\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceCollection'\n\nimport type { PerformanceResourceDetailsElement } from '../../rawRumEvent.types'\nimport type { RumConfiguration } from '../configuration'\n\nexport interface PerformanceResourceDetails {\n  redirect?: PerformanceResourceDetailsElement\n  dns?: PerformanceResourceDetailsElement\n  connect?: PerformanceResourceDetailsElement\n  ssl?: PerformanceResourceDetailsElement\n  first_byte?: PerformanceResourceDetailsElement\n  download?: PerformanceResourceDetailsElement\n}\n\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document'\n\nconst RESOURCE_TYPES: Array<[ResourceType, (initiatorType: string, path: string) => boolean]> = [\n  [ResourceType.DOCUMENT, (initiatorType: string) => FAKE_INITIAL_DOCUMENT === initiatorType],\n  [ResourceType.XHR, (initiatorType: string) => 'xmlhttprequest' === initiatorType],\n  [ResourceType.FETCH, (initiatorType: string) => 'fetch' === initiatorType],\n  [ResourceType.BEACON, (initiatorType: string) => 'beacon' === initiatorType],\n  [ResourceType.CSS, (_: string, path: string) => /\\.css$/i.test(path)],\n  [ResourceType.JS, (_: string, path: string) => /\\.js$/i.test(path)],\n  [\n    ResourceType.IMAGE,\n    (initiatorType: string, path: string) =>\n      includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n  ],\n  [ResourceType.FONT, (_: string, path: string) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n  [\n    ResourceType.MEDIA,\n    (initiatorType: string, path: string) =>\n      includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n  ],\n]\n\nexport function computeResourceKind(timing: RumPerformanceResourceTiming) {\n  const url = timing.name\n  if (!isValidUrl(url)) {\n    addTelemetryDebug(`Failed to construct URL for \"${timing.name}\"`)\n    return ResourceType.OTHER\n  }\n  const path = getPathName(url)\n  for (const [type, isType] of RESOURCE_TYPES) {\n    if (isType(timing.initiatorType, path)) {\n      return type\n    }\n  }\n  return ResourceType.OTHER\n}\n\nfunction areInOrder(...numbers: number[]) {\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isRequestKind(timing: RumPerformanceResourceTiming) {\n  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch'\n}\n\nexport function computePerformanceResourceDuration(entry: RumPerformanceResourceTiming): ServerDuration {\n  const { duration, startTime, responseEnd } = entry\n\n  // Safari duration is always 0 on timings blocked by cross origin policies.\n  if (duration === 0 && startTime < responseEnd) {\n    return toServerDuration(elapsed(startTime, responseEnd))\n  }\n\n  return toServerDuration(duration)\n}\n\nexport function computePerformanceResourceDetails(\n  entry: RumPerformanceResourceTiming\n): PerformanceResourceDetails | undefined {\n  if (!isValidEntry(entry)) {\n    return undefined\n  }\n  const {\n    startTime,\n    fetchStart,\n    redirectStart,\n    redirectEnd,\n    domainLookupStart,\n    domainLookupEnd,\n    connectStart,\n    secureConnectionStart,\n    connectEnd,\n    requestStart,\n    responseStart,\n    responseEnd,\n  } = entry\n\n  const details: PerformanceResourceDetails = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart),\n  }\n\n  // Make sure a connection occurred\n  if (fetchStart < connectEnd) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd)\n\n    // Make sure a secure connection occurred\n    if (connectStart <= secureConnectionStart && secureConnectionStart <= connectEnd) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd)\n    }\n  }\n\n  // Make sure a domain lookup occurred\n  if (fetchStart < domainLookupEnd) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd)\n  }\n\n  // Make sure a redirection occurred\n  if (startTime < redirectEnd) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd)\n  }\n\n  return details\n}\n\nexport function isValidEntry(entry: RumPerformanceResourceTiming) {\n  if (isExperimentalFeatureEnabled(ExperimentalFeature.TOLERANT_RESOURCE_TIMINGS)) {\n    return true\n  }\n\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  const areCommonTimingsInOrder = areInOrder(\n    entry.startTime,\n    entry.fetchStart,\n    entry.domainLookupStart,\n    entry.domainLookupEnd,\n    entry.connectStart,\n    entry.connectEnd,\n    entry.requestStart,\n    entry.responseStart,\n    entry.responseEnd\n  )\n\n  const areRedirectionTimingsInOrder = hasRedirection(entry)\n    ? areInOrder(entry.startTime, entry.redirectStart, entry.redirectEnd, entry.fetchStart)\n    : true\n\n  return areCommonTimingsInOrder && areRedirectionTimingsInOrder\n}\n\nfunction hasRedirection(entry: RumPerformanceResourceTiming) {\n  return entry.redirectEnd > entry.startTime\n}\nfunction formatTiming(origin: RelativeTime, start: RelativeTime, end: RelativeTime) {\n  if (origin <= start && start <= end) {\n    return {\n      duration: toServerDuration(elapsed(start, end)),\n      start: toServerDuration(elapsed(origin, start)),\n    }\n  }\n}\n\nexport function computeSize(entry: RumPerformanceResourceTiming) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    const { encodedBodySize, decodedBodySize, transferSize } = entry\n    return {\n      size: decodedBodySize,\n      encoded_body_size: encodedBodySize,\n      decoded_body_size: decodedBodySize,\n      transfer_size: transferSize,\n    }\n  }\n  return {\n    size: undefined,\n    encoded_body_size: undefined,\n    decoded_body_size: undefined,\n    transfer_size: undefined,\n  }\n}\n\nexport function isAllowedRequestUrl(configuration: RumConfiguration, url: string) {\n  return url && !configuration.isIntakeUrl(url)\n}\n\nconst DATA_URL_REGEX = /data:(.+)?(;base64)?,/g\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 24_000\n\nexport function isLongDataUrl(url: string): boolean {\n  if (url.length <= MAX_ATTRIBUTE_VALUE_CHAR_LENGTH) {\n    return false\n  } else if (url.substring(0, 5) === 'data:') {\n    // Avoid String.match RangeError: Maximum call stack size exceeded\n    url = url.substring(0, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH)\n    return true\n  }\n  return false\n}\n\nexport function sanitizeDataUrl(url: string): string {\n  return `${url.match(DATA_URL_REGEX)![0]}[...]`\n}\n","export function isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE\n}\n\nexport function isCommentNode(node: Node): node is Comment {\n  return node.nodeType === Node.COMMENT_NODE\n}\n\nexport function isElementNode(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE\n}\n\nexport function isNodeShadowHost(node: Node): node is Element & { shadowRoot: ShadowRoot } {\n  return isElementNode(node) && Boolean(node.shadowRoot)\n}\n\nexport function isNodeShadowRoot(node: Node): node is ShadowRoot {\n  const shadowRoot = node as ShadowRoot\n  return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host)\n}\n\nexport function hasChildNodes(node: Node) {\n  return node.childNodes.length > 0 || isNodeShadowHost(node)\n}\n\nexport function forEachChildNodes(node: Node, callback: (child: Node) => void) {\n  let child = node.firstChild\n\n  while (child) {\n    callback(child)\n\n    child = child.nextSibling\n  }\n\n  if (isNodeShadowHost(node)) {\n    callback(node.shadowRoot)\n  }\n}\n\n/**\n * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`\n */\nexport function getParentNode(node: Node): Node | null {\n  return isNodeShadowRoot(node) ? node.host : node.parentNode\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n","import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  dateNow,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  getRelativeTime,\n  isNumber,\n  monitor,\n  setTimeout,\n  relativeNow,\n  runOnReadyState,\n  addEventListener,\n  objectHasValue,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/resource/resourceUtils'\n\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId'\n\ntype RumPerformanceObserverConstructor = new (callback: PerformanceObserverCallback) => RumPerformanceObserver\n\nexport interface BrowserWindow extends Window {\n  PerformanceObserver: RumPerformanceObserverConstructor\n  performance: Performance & { interactionCount?: number }\n}\n\nexport interface RumPerformanceObserver extends PerformanceObserver {\n  observe(options?: PerformanceObserverInit & { durationThreshold: number }): void\n}\n\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected performance entry\n// eslint-disable-next-line no-restricted-syntax\nexport enum RumPerformanceEntryType {\n  EVENT = 'event',\n  FIRST_INPUT = 'first-input',\n  LARGEST_CONTENTFUL_PAINT = 'largest-contentful-paint',\n  LAYOUT_SHIFT = 'layout-shift',\n  LONG_TASK = 'longtask',\n  NAVIGATION = 'navigation',\n  PAINT = 'paint',\n  RESOURCE = 'resource',\n}\n\nexport interface RumPerformanceResourceTiming {\n  entryType: RumPerformanceEntryType.RESOURCE\n  initiatorType: string\n  responseStatus?: number\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  encodedBodySize: number\n  transferSize: number\n  renderBlockingStatus?: string\n  traceId?: string\n  toJSON(): Omit<PerformanceEntry, 'toJSON'>\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  name: string\n  entryType: RumPerformanceEntryType.LONG_TASK\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): Omit<PerformanceEntry, 'toJSON'>\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: RumPerformanceEntryType.PAINT\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n}\n\nexport interface RumPerformanceNavigationTiming {\n  entryType: RumPerformanceEntryType.NAVIGATION\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n  responseStart: RelativeTime\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT\n  startTime: RelativeTime\n  size: number\n  element?: Element\n  toJSON(): Omit<RumLargestContentfulPaintTiming, 'toJSON'>\n}\n\nexport interface RumFirstInputTiming {\n  entryType: RumPerformanceEntryType.FIRST_INPUT\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  processingEnd: RelativeTime\n  duration: Duration\n  target?: Node\n  interactionId?: number\n  name: string\n}\n\nexport interface RumPerformanceEventTiming {\n  entryType: RumPerformanceEntryType.EVENT\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  processingEnd: RelativeTime\n  duration: Duration\n  interactionId?: number\n  target?: Node\n  name: string\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: RumPerformanceEntryType.LAYOUT_SHIFT\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n  sources?: Array<{\n    node?: Node\n  }>\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumPerformanceEventTiming\n  | RumLayoutShiftTiming\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: RumPerformanceEntryType) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nexport function startPerformanceCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  const cleanupTasks: Array<() => void> = []\n  retrieveInitialDocumentResourceTiming(configuration, (timing) => {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n  })\n\n  if (supportPerformanceObject()) {\n    const performanceEntries = performance.getEntries()\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(() => handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries))\n  }\n\n  if (window.PerformanceObserver) {\n    const handlePerformanceEntryList = monitor((entries: PerformanceObserverEntryList) =>\n      handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries())\n    )\n    const mainEntries = [\n      RumPerformanceEntryType.RESOURCE,\n      RumPerformanceEntryType.NAVIGATION,\n      RumPerformanceEntryType.LONG_TASK,\n      RumPerformanceEntryType.PAINT,\n    ]\n    const experimentalEntries = [\n      RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,\n      RumPerformanceEntryType.FIRST_INPUT,\n      RumPerformanceEntryType.LAYOUT_SHIFT,\n      RumPerformanceEntryType.EVENT,\n    ]\n\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach((type) => {\n        const observer = new (window as BrowserWindow).PerformanceObserver(handlePerformanceEntryList)\n        observer.observe({\n          type,\n          buffered: true,\n          // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)\n          // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L209\n          durationThreshold: 40,\n        })\n        cleanupTasks.push(() => observer.disconnect())\n      })\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push(...experimentalEntries)\n    }\n\n    const mainObserver = new PerformanceObserver(handlePerformanceEntryList)\n    mainObserver.observe({ entryTypes: mainEntries })\n    cleanupTasks.push(() => mainObserver.disconnect())\n\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      const { stop: removePerformanceListener } = addEventListener(\n        configuration,\n        performance,\n        'resourcetimingbufferfull',\n        () => {\n          performance.clearResourceTimings()\n        }\n      )\n      cleanupTasks.push(removePerformanceListener)\n    }\n  }\n  if (!supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {\n    retrieveNavigationTiming(configuration, (timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n  if (!supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT)) {\n    const { stop: stopFirstInputTiming } = retrieveFirstInputTiming(configuration, (timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n    cleanupTasks.push(stopFirstInputTiming)\n  }\n  return {\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n\nexport function retrieveInitialDocumentResourceTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceResourceTiming) => void\n) {\n  runOnReadyState(configuration, 'interactive', () => {\n    let timing: RumPerformanceResourceTiming\n\n    const forcedAttributes = {\n      entryType: RumPerformanceEntryType.RESOURCE as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n      toJSON: () => assign({}, timing, { toJSON: undefined }),\n    }\n    if (\n      supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION) &&\n      performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION).length > 0\n    ) {\n      const navigationEntry = performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION)[0]\n      timing = assign(navigationEntry.toJSON() as RumPerformanceResourceTiming, forcedAttributes)\n    } else {\n      const relativePerformanceTiming = computeRelativePerformanceTiming()\n      timing = assign(\n        relativePerformanceTiming,\n        {\n          decodedBodySize: 0,\n          encodedBodySize: 0,\n          transferSize: 0,\n          renderBlockingStatus: 'non-blocking',\n          duration: relativePerformanceTiming.responseEnd,\n          name: window.location.href,\n          startTime: 0 as RelativeTime,\n        },\n        forcedAttributes\n      )\n    }\n    callback(timing)\n  })\n}\n\nfunction retrieveNavigationTiming(\n  configuration: RumConfiguration,\n  callback: (timing: RumPerformanceNavigationTiming) => void\n) {\n  function sendFakeTiming() {\n    callback(\n      assign(computeRelativePerformanceTiming(), {\n        entryType: RumPerformanceEntryType.NAVIGATION as const,\n      })\n    )\n  }\n\n  runOnReadyState(configuration, 'complete', () => {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(sendFakeTiming)\n  })\n}\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(configuration: RumConfiguration, callback: (timing: RumFirstInputTiming) => void) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: RumFirstInputTiming = {\n        entryType: RumPerformanceEntryType.FIRST_INPUT,\n        processingStart: relativeNow(),\n        processingEnd: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n        duration: 0 as Duration, // arbitrary value to avoid nullable duration and simplify INP logic\n        name: '',\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(configuration, timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  return { stop: removeEventListeners }\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(configuration: RumConfiguration, timing: RumFirstInputTiming) {\n    addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: RumFirstInputTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n\nexport type RelativePerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nfunction computeRelativePerformanceTiming() {\n  const result: Partial<RelativePerformanceTiming> = {}\n  const timing = performance.timing\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof RelativePerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as RelativePerformanceTiming\n}\n\nfunction handleRumPerformanceEntries(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  entries: Array<PerformanceEntry | RumPerformanceEntry>\n) {\n  const rumPerformanceEntries = entries.filter((entry): entry is RumPerformanceEntry =>\n    objectHasValue(RumPerformanceEntryType, entry.entryType)\n  )\n\n  const rumAllowedPerformanceEntries = rumPerformanceEntries.filter(\n    (entry) => !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry)\n  )\n\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, rumAllowedPerformanceEntries)\n  }\n}\n\nfunction isIncompleteNavigation(entry: RumPerformanceEntry) {\n  return entry.entryType === RumPerformanceEntryType.NAVIGATION && entry.loadEventEnd <= 0\n}\n\nfunction isForbiddenResource(configuration: RumConfiguration, entry: RumPerformanceEntry) {\n  return entry.entryType === RumPerformanceEntryType.RESOURCE && !isAllowedRequestUrl(configuration, entry.name)\n}\n","import type { ClocksState } from '../../tools/utils/timeUtils'\n\n// TS v4.6 introduced Error.cause[1] typed as `Error`. TS v4.8 changed Error.cause to be\n// `unknown`[2].\n//\n// Because we still support TS 3.8, we need to declare our own type. We can remove it once we drop\n// support for TS v4.7 and before. The 'cause' property defined by TS needs to be omitted because\n// we define it with a type `unknown` which is incompatible with TS 4.6 and 4.7.\n//\n// [1]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/#target-es2022\n// [2]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#lib-d-ts-updates\nexport interface ErrorWithCause extends Omit<Error, 'cause'> {\n  cause?: unknown\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport type Csp = {\n  disposition: 'enforce' | 'report'\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n  fingerprint?: string\n  csp?: Csp\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum NonErrorPrefix {\n  UNCAUGHT = 'Uncaught',\n  PROVIDED = 'Provided',\n}\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = (typeof ErrorSource)[keyof typeof ErrorSource]\n","import { setTimeout } from '../../tools/timer'\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport type { RawError } from '../error/error.types'\nimport { ErrorSource } from '../error/error.types'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core'\n\nexport function getSyntheticsContext() {\n  const testId = getSyntheticsTestId()\n  const resultId = getSyntheticsResultId()\n\n  if (testId && resultId) {\n    return {\n      test_id: testId,\n      result_id: resultId,\n      injected: willSyntheticsInjectRum(),\n    }\n  }\n}\n","import { sanitize, deepClone, getType, objectEntries } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\n\nexport type ModifiableFieldPaths = Record<string, 'string' | 'object'>\n\n/**\n * Current limitation:\n * - field path do not support array, 'a.b.c' only\n */\nexport function limitModification<T extends Context, Result>(\n  object: T,\n  modifiableFieldPaths: ModifiableFieldPaths,\n  modifier: (object: T) => Result\n): Result | undefined {\n  const clone = deepClone(object)\n  const result = modifier(clone)\n  objectEntries(modifiableFieldPaths).forEach(([fieldPath, fieldType]) => {\n    const newValue = get(clone, fieldPath)\n    const newType = getType(newValue)\n    if (newType === fieldType) {\n      set(object, fieldPath, sanitize(newValue))\n    } else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {\n      set(object, fieldPath, {})\n    }\n  })\n  return result\n}\n\nfunction get(object: unknown, path: string) {\n  let current = object\n  for (const field of path.split('.')) {\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    current = current[field]\n  }\n  return current\n}\n\nfunction set(object: unknown, path: string, value: unknown) {\n  let current = object\n  const fields = path.split('.')\n  for (let i = 0; i < fields.length; i += 1) {\n    const field = fields[i]\n    if (!isValidObject(current)) {\n      return\n    }\n    if (i !== fields.length - 1) {\n      current = current[field]\n    } else {\n      current[field] = value\n    }\n  }\n}\n\nfunction isValidObject(object: unknown): object is Record<string, unknown> {\n  return getType(object) === 'object'\n}\n\nfunction isValidObjectContaining(object: unknown, field: string): object is Record<string, unknown> {\n  return isValidObject(object) && Object.prototype.hasOwnProperty.call(object, field)\n}\n","import type { Context, RawError, EventRateLimiter, User } from '@datadog/browser-core'\nimport {\n  combine,\n  isEmptyObject,\n  timeStampNow,\n  currentDrift,\n  display,\n  createEventRateLimiter,\n  canUseEventBridge,\n  assign,\n  round,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n  getConnectivity,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type {\n  RawRumErrorEvent,\n  RawRumEvent,\n  RawRumLongTaskEvent,\n  RawRumResourceEvent,\n  RumContext,\n} from '../rawRumEvent.types'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { getSyntheticsContext } from './contexts/syntheticsContext'\nimport type { CiVisibilityContext } from './contexts/ciVisibilityContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { ViewContexts } from './contexts/viewContexts'\nimport { SessionReplayState, type RumSessionManager } from './rumSessionManager'\nimport type { UrlContexts } from './contexts/urlContexts'\nimport type { RumConfiguration } from './configuration'\nimport type { ActionContexts } from './action/actionCollection'\nimport type { DisplayContext } from './contexts/displayContext'\nimport type { CommonContext } from './contexts/commonContext'\nimport type { ModifiableFieldPaths } from './limitModification'\nimport { limitModification } from './limitModification'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst enum SessionType {\n  SYNTHETICS = 'synthetics',\n  USER = 'user',\n  CI_TEST = 'ci_test',\n}\n\nconst VIEW_MODIFIABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  'view.name': 'string',\n  'view.url': 'string',\n  'view.referrer': 'string',\n}\n\nconst USER_CUSTOMIZABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  context: 'object',\n}\n\nconst ROOT_MODIFIABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  service: 'string',\n  version: 'string',\n}\n\nlet modifiableFieldPathsByEvent: { [key in RumEventType]: ModifiableFieldPaths }\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport function startRumAssembly(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  urlContexts: UrlContexts,\n  actionContexts: ActionContexts,\n  displayContext: DisplayContext,\n  ciVisibilityContext: CiVisibilityContext,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  modifiableFieldPathsByEvent = {\n    [RumEventType.VIEW]: VIEW_MODIFIABLE_FIELD_PATHS,\n    [RumEventType.ERROR]: assign(\n      {\n        'error.message': 'string',\n        'error.stack': 'string',\n        'error.resource.url': 'string',\n        'error.fingerprint': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS,\n      ROOT_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.RESOURCE]: assign(\n      {\n        'resource.url': 'string',\n      },\n      isExperimentalFeatureEnabled(ExperimentalFeature.WRITABLE_RESOURCE_GRAPHQL)\n        ? {\n            'resource.graphql': 'object',\n          }\n        : {},\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS,\n      ROOT_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.ACTION]: assign(\n      {\n        'action.target.name': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS,\n      ROOT_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.LONG_TASK]: assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n    [RumEventType.VITAL]: assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n  }\n  const eventRateLimiters = {\n    [RumEventType.ERROR]: createEventRateLimiter(\n      RumEventType.ERROR,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.ACTION]: createEventRateLimiter(\n      RumEventType.ACTION,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.VITAL]: createEventRateLimiter(\n      RumEventType.VITAL,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n  }\n\n  const syntheticsContext = getSyntheticsContext()\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    ({ startTime, rawRumEvent, domainContext, savedCommonContext, customerContext }) => {\n      const viewContext = viewContexts.findView(startTime)\n      const urlContext = urlContexts.findUrl(startTime)\n      const session = sessionManager.findTrackedSession(startTime)\n      if (session && viewContext && urlContext) {\n        const commonContext = savedCommonContext || getCommonContext()\n        const actionId = actionContexts.findActionId(startTime)\n\n        const rumContext: RumContext = {\n          _dd: {\n            format_version: 2,\n            drift: currentDrift(),\n            configuration: {\n              session_sample_rate: round(configuration.sessionSampleRate, 3),\n              session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3),\n            },\n            browser_sdk_version: canUseEventBridge() ? __BUILD_ENV__SDK_VERSION__ : undefined,\n          },\n          application: {\n            id: configuration.applicationId,\n          },\n          date: timeStampNow(),\n          service: viewContext.service || configuration.service,\n          version: viewContext.version || configuration.version,\n          source: 'browser',\n          session: {\n            id: session.id,\n            type: syntheticsContext\n              ? SessionType.SYNTHETICS\n              : ciVisibilityContext.get()\n                ? SessionType.CI_TEST\n                : SessionType.USER,\n          },\n          view: {\n            id: viewContext.id,\n            name: viewContext.name,\n            url: urlContext.url,\n            referrer: urlContext.referrer,\n          },\n          action: needToAssembleWithAction(rawRumEvent) && actionId ? { id: actionId } : undefined,\n          synthetics: syntheticsContext,\n          ci_test: ciVisibilityContext.get(),\n          display: displayContext.get(),\n          connectivity: getConnectivity(),\n        }\n\n        const serverRumEvent = combine(rumContext as RumContext & Context, rawRumEvent) as RumEvent & Context\n        serverRumEvent.context = combine(commonContext.context, customerContext)\n\n        if (!('has_replay' in serverRumEvent.session)) {\n          ;(serverRumEvent.session as Mutable<RumEvent['session']>).has_replay = commonContext.hasReplay\n        }\n        if (serverRumEvent.type === 'view') {\n          ;(serverRumEvent.session as Mutable<RumEvent['session']>).sampled_for_replay =\n            session.sessionReplay === SessionReplayState.SAMPLED\n        }\n\n        if (!isEmptyObject(commonContext.user)) {\n          ;(serverRumEvent.usr as Mutable<RumEvent['usr']>) = commonContext.user as User & Context\n        }\n\n        if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n          if (isEmptyObject(serverRumEvent.context)) {\n            delete serverRumEvent.context\n          }\n          lifeCycle.notify(LifeCycleEventType.RUM_EVENT_COLLECTED, serverRumEvent)\n        }\n      }\n    }\n  )\n}\n\nfunction shouldSend(\n  event: RumEvent & Context,\n  beforeSend: RumConfiguration['beforeSend'],\n  domainContext: RumEventDomainContext,\n  eventRateLimiters: { [key in RumEventType]?: EventRateLimiter }\n) {\n  if (beforeSend) {\n    const result = limitModification(event, modifiableFieldPathsByEvent[event.type], (event) =>\n      beforeSend(event, domainContext)\n    )\n    if (result === false && event.type !== RumEventType.VIEW) {\n      return false\n    }\n    if (result === false) {\n      display.warn(\"Can't dismiss view events using beforeSend!\")\n    }\n  }\n\n  const rateLimitReached = eventRateLimiters[event.type]?.isLimitReached()\n  return !rateLimitReached\n}\n\nfunction needToAssembleWithAction(\n  event: RawRumEvent\n): event is RawRumErrorEvent | RawRumResourceEvent | RawRumLongTaskEvent {\n  return [RumEventType.ERROR, RumEventType.RESOURCE, RumEventType.LONG_TASK].indexOf(event.type) !== -1\n}\n","import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n","import type { InstrumentedMethodCall } from '../tools/instrumentMethod'\nimport { instrumentMethod } from '../tools/instrumentMethod'\nimport { Observable } from '../tools/observable'\nimport type { Duration, ClocksState } from '../tools/utils/timeUtils'\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\nimport { shallowClone } from '../tools/utils/objectUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListener } from './addEventListener'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n  handlingStack?: string\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable(configuration: Configuration) {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable(configuration)\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable(configuration: Configuration) {\n  return new Observable<XhrContext>((observable) => {\n    const { stop: stopInstrumentingStart } = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr)\n\n    const { stop: stopInstrumentingSend } = instrumentMethod(\n      XMLHttpRequest.prototype,\n      'send',\n      (call) => {\n        sendXhr(call, configuration, observable)\n      },\n      { computeHandlingStack: true }\n    )\n\n    const { stop: stopInstrumentingAbort } = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr)\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n}\n\nfunction openXhr({ target: xhr, parameters: [method, url] }: InstrumentedMethodCall<XMLHttpRequest, 'open'>) {\n  xhrContexts.set(xhr, {\n    state: 'open',\n    method: String(method).toUpperCase(),\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(\n  { target: xhr, handlingStack }: InstrumentedMethodCall<XMLHttpRequest, 'send'>,\n  configuration: Configuration,\n  observable: Observable<XhrContext>\n) {\n  const context = xhrContexts.get(xhr)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = xhr\n  startContext.handlingStack = handlingStack\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethod(xhr, 'onreadystatechange', () => {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n      // application during a future event. For example, Angular is calling .abort() on\n      // completed requests during an onreadystatechange event, so the status becomes '0'\n      // before the request is collected.\n      onEnd()\n    }\n  })\n\n  const onEnd = () => {\n    unsubscribeLoadEndListener()\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = xhr.status\n    observable.notify(shallowClone(completeContext))\n  }\n\n  const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, xhr, 'loadend', onEnd)\n\n  observable.notify(startContext)\n}\n\nfunction abortXhr({ target: xhr }: InstrumentedMethodCall<XMLHttpRequest, 'abort'>) {\n  const context = xhrContexts.get(xhr) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import type { Context, PageExitEvent, RawError, RelativeTime } from '@datadog/browser-core'\nimport { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { RumPerformanceEntry } from '../browser/performanceCollection'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RawRumEvent } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { CommonContext } from './contexts/commonContext'\nimport type { RequestCompleteEvent, RequestStartEvent } from './requestCollection'\nimport type { AutoAction } from './action/actionCollection'\nimport type { ViewEvent, ViewCreatedEvent, ViewEndedEvent } from './view/trackViews'\n\nexport const enum LifeCycleEventType {\n  // Contexts (like viewContexts) should be opened using prefixed BEFORE_XXX events and closed using prefixed AFTER_XXX events\n  // It ensures the context is available during the non prefixed event callbacks\n  PERFORMANCE_ENTRIES_COLLECTED,\n  AUTO_ACTION_COMPLETED,\n  BEFORE_VIEW_CREATED,\n  VIEW_CREATED,\n  VIEW_UPDATED,\n  VIEW_ENDED,\n  AFTER_VIEW_ENDED,\n  REQUEST_STARTED,\n  REQUEST_COMPLETED,\n\n  // The SESSION_EXPIRED lifecycle event has been introduced to represent when a session has expired\n  // and trigger cleanup tasks related to this, prior to renewing the session. Its implementation is\n  // slightly naive: it is not triggered as soon as the session is expired, but rather just before\n  // notifying that the session is renewed. Thus, the session id is already set to the newly renewed\n  // session.\n  //\n  // This implementation is \"good enough\" for our use-cases. Improving this is not trivial,\n  // primarily because multiple instances of the SDK may be managing the same session cookie at\n  // the same time, for example when using Logs and RUM on the same page, or opening multiple tabs\n  // on the same domain.\n  SESSION_EXPIRED,\n  SESSION_RENEWED,\n  PAGE_EXITED,\n  RAW_RUM_EVENT_COLLECTED,\n  RUM_EVENT_COLLECTED,\n  RAW_ERROR_COLLECTED,\n}\n\n// This is a workaround for an issue occurring when the Browser SDK is included in a TypeScript\n// project configured with `isolatedModules: true`. Even if the const enum is declared in this\n// module, we cannot use it directly to define the EventMap interface keys (TS error: \"Cannot access\n// ambient const enums when the '--isolatedModules' flag is provided.\").\n//\n// Using a plain enum would fix the issue, but would also add 2KB to the minified bundle. By using\n// this workaround, we can keep using a const enum without impacting the bundle size (since it is a\n// \"declare\" statement, it will only be used during typecheck and completely ignored when building\n// JavaScript).\n//\n// See issues:\n// * https://github.com/DataDog/browser-sdk/issues/2208\n// * https://github.com/microsoft/TypeScript/issues/54152\ndeclare const LifeCycleEventTypeAsConst: {\n  PERFORMANCE_ENTRIES_COLLECTED: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED\n  AUTO_ACTION_COMPLETED: LifeCycleEventType.AUTO_ACTION_COMPLETED\n  BEFORE_VIEW_CREATED: LifeCycleEventType.BEFORE_VIEW_CREATED\n  VIEW_CREATED: LifeCycleEventType.VIEW_CREATED\n  VIEW_UPDATED: LifeCycleEventType.VIEW_UPDATED\n  VIEW_ENDED: LifeCycleEventType.VIEW_ENDED\n  AFTER_VIEW_ENDED: LifeCycleEventType.AFTER_VIEW_ENDED\n  REQUEST_STARTED: LifeCycleEventType.REQUEST_STARTED\n  REQUEST_COMPLETED: LifeCycleEventType.REQUEST_COMPLETED\n  SESSION_EXPIRED: LifeCycleEventType.SESSION_EXPIRED\n  SESSION_RENEWED: LifeCycleEventType.SESSION_RENEWED\n  PAGE_EXITED: LifeCycleEventType.PAGE_EXITED\n  RAW_RUM_EVENT_COLLECTED: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED\n  RUM_EVENT_COLLECTED: LifeCycleEventType.RUM_EVENT_COLLECTED\n  RAW_ERROR_COLLECTED: LifeCycleEventType.RAW_ERROR_COLLECTED\n}\n\n// Note: this interface needs to be exported even if it is not used outside of this module, else TS\n// fails to build the rum-core package with error TS4058\nexport interface LifeCycleEventMap {\n  [LifeCycleEventTypeAsConst.PERFORMANCE_ENTRIES_COLLECTED]: RumPerformanceEntry[]\n  [LifeCycleEventTypeAsConst.AUTO_ACTION_COMPLETED]: AutoAction\n  [LifeCycleEventTypeAsConst.BEFORE_VIEW_CREATED]: ViewCreatedEvent\n  [LifeCycleEventTypeAsConst.VIEW_CREATED]: ViewCreatedEvent\n  [LifeCycleEventTypeAsConst.VIEW_UPDATED]: ViewEvent\n  [LifeCycleEventTypeAsConst.VIEW_ENDED]: ViewEndedEvent\n  [LifeCycleEventTypeAsConst.AFTER_VIEW_ENDED]: ViewEndedEvent\n  [LifeCycleEventTypeAsConst.REQUEST_STARTED]: RequestStartEvent\n  [LifeCycleEventTypeAsConst.REQUEST_COMPLETED]: RequestCompleteEvent\n  [LifeCycleEventTypeAsConst.SESSION_EXPIRED]: void\n  [LifeCycleEventTypeAsConst.SESSION_RENEWED]: void\n  [LifeCycleEventTypeAsConst.PAGE_EXITED]: PageExitEvent\n  [LifeCycleEventTypeAsConst.RAW_RUM_EVENT_COLLECTED]: RawRumEventCollectedData\n  [LifeCycleEventTypeAsConst.RUM_EVENT_COLLECTED]: RumEvent & Context\n  [LifeCycleEventTypeAsConst.RAW_ERROR_COLLECTED]: {\n    error: RawError\n    savedCommonContext?: CommonContext\n    customerContext?: Context\n  }\n}\n\nexport interface RawRumEventCollectedData<E extends RawRumEvent = RawRumEvent> {\n  startTime: RelativeTime\n  savedCommonContext?: CommonContext\n  customerContext?: Context\n  rawRumEvent: E\n  domainContext: RumEventDomainContext<E['type']>\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n","import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport { removeItem } from './utils/arrayUtils'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ValueHistory<Value> {\n  private entries: Array<ValueHistoryEntry<Value>> = []\n  private clearOldValuesInterval: TimeoutId\n\n  constructor(\n    private expireDelay: number,\n    private maxEntries?: number\n  ) {\n    this.clearOldValuesInterval = setInterval(() => this.clearOldValues(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        removeItem(this.entries, entry)\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop()\n    }\n\n    this.entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   *\n   * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n   */\n  find(\n    startTime: RelativeTime = END_OF_TIMES,\n    options: { returnInactive: boolean } = { returnInactive: false }\n  ): Value | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (options.returnInactive || startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return this.entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldValuesInterval)\n  }\n\n  private clearOldValues() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import type { RelativeTime, ClocksState } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, ValueHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { ViewCreatedEvent } from '../view/trackViews'\n\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface ViewContext {\n  service?: string\n  version?: string\n  id: string\n  name?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewContexts {\n  findView: (startTime?: RelativeTime) => ViewContext | undefined\n  stop: () => void\n}\n\nexport function startViewContexts(lifeCycle: LifeCycle): ViewContexts {\n  const viewContextHistory = new ValueHistory<ViewContext>(VIEW_CONTEXT_TIME_OUT_DELAY)\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_CREATED, (view) => {\n    viewContextHistory.add(buildViewContext(view), view.startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.AFTER_VIEW_ENDED, ({ endClocks }) => {\n    viewContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    viewContextHistory.reset()\n  })\n\n  function buildViewContext(view: ViewCreatedEvent) {\n    return {\n      service: view.service,\n      version: view.version,\n      id: view.id,\n      name: view.name,\n      startClocks: view.startClocks,\n    }\n  }\n\n  return {\n    findView: (startTime) => viewContextHistory.find(startTime),\n    stop: () => {\n      viewContextHistory.stop()\n    },\n  }\n}\n","import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\nimport { arrayFrom, startsWith } from './utils/polyfills'\nimport { createHandlingStack } from './stackTrace/handlingStack'\n\n/**\n * Object passed to the callback of an instrumented method call. See `instrumentMethod` for more\n * info.\n */\nexport type InstrumentedMethodCall<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = {\n  /**\n   * The target object on which the method was called.\n   */\n  target: TARGET\n\n  /**\n   * The parameters with which the method was called.\n   *\n   * Note: if needed, parameters can be mutated by the instrumentation\n   */\n  parameters: Parameters<TARGET[METHOD]>\n\n  /**\n   * Registers a callback that will be called after the original method is called, with the method\n   * result passed as argument.\n   */\n  onPostCall: (callback: PostCallCallback<TARGET, METHOD>) => void\n\n  /**\n   * The stack trace of the method call.\n   */\n  handlingStack?: string\n}\n\ntype PostCallCallback<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = (\n  result: ReturnType<TARGET[METHOD]>\n) => void\n\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET & string>(\n  targetPrototype: TARGET,\n  method: METHOD,\n  onPreCall: (this: null, callInfos: InstrumentedMethodCall<TARGET, METHOD>) => void,\n  { computeHandlingStack }: { computeHandlingStack?: boolean } = {}\n) {\n  let original = targetPrototype[method]\n\n  if (typeof original !== 'function') {\n    if (startsWith(method, 'on')) {\n      original = noop as TARGET[METHOD]\n    } else {\n      return { stop: noop }\n    }\n  }\n\n  let stopped = false\n\n  const instrumentation = function (this: TARGET): ReturnType<TARGET[METHOD]> | undefined {\n    if (stopped) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n      return original.apply(this, arguments as unknown as Parameters<TARGET[METHOD]>)\n    }\n\n    const parameters = arrayFrom(arguments) as Parameters<TARGET[METHOD]>\n\n    let postCallCallback: PostCallCallback<TARGET, METHOD> | undefined\n\n    callMonitored(onPreCall, null, [\n      {\n        target: this,\n        parameters,\n        onPostCall: (callback) => {\n          postCallCallback = callback\n        },\n        handlingStack: computeHandlingStack ? createHandlingStack() : undefined,\n      },\n    ])\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const result = original.apply(this, parameters)\n\n    if (postCallCallback) {\n      callMonitored(postCallCallback, null, [result])\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return result\n  }\n\n  targetPrototype[method] = instrumentation as TARGET[METHOD]\n\n  return {\n    stop: () => {\n      stopped = true\n      // If the instrumentation has been removed by a third party, keep the last one\n      if (targetPrototype[method] === instrumentation) {\n        targetPrototype[method] = original\n      }\n    },\n  }\n}\n\nexport function instrumentSetter<TARGET extends { [key: string]: any }, PROPERTY extends keyof TARGET>(\n  targetPrototype: TARGET,\n  property: PROPERTY,\n  after: (target: TARGET, value: TARGET[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  const stoppedInstrumentation = noop\n  let instrumentation = (target: TARGET, value: TARGET[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      if (instrumentation !== stoppedInstrumentation) {\n        after(target, value)\n      }\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: TARGET, value: TARGET[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(targetPrototype, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(targetPrototype, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(targetPrototype, property, originalDescriptor)\n      }\n      instrumentation = stoppedInstrumentation\n    },\n  }\n}\n","import type { InstrumentedMethodCall } from '../tools/instrumentMethod'\nimport { instrumentMethod } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { ClocksState } from '../tools/utils/timeUtils'\nimport { clocksNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: unknown\n  init?: RequestInit\n  url: string\n  handlingStack?: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchResolveContext extends FetchContextBase {\n  state: 'resolve'\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchResolveContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  return new Observable<FetchContext>((observable) => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(window, 'fetch', (call) => beforeSend(call, observable), {\n      computeHandlingStack: true,\n    })\n\n    return stop\n  })\n}\n\nfunction beforeSend(\n  { parameters, onPostCall, handlingStack }: InstrumentedMethodCall<Window, 'fetch'>,\n  observable: Observable<FetchContext>\n) {\n  const [input, init] = parameters\n  let methodFromParams = init && init.method\n\n  if (methodFromParams === undefined && input instanceof Request) {\n    methodFromParams = input.method\n  }\n\n  const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET'\n  const url = input instanceof Request ? input.url : normalizeUrl(String(input))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n    handlingStack,\n  }\n\n  observable.notify(context)\n\n  // Those properties can be changed by observable subscribers\n  parameters[0] = context.input as RequestInfo | URL\n  parameters[1] = context.init\n\n  onPostCall((responsePromise) => afterSend(observable, responsePromise, context))\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchResolveContext\n    context.state = 'resolve'\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n    }\n    observable.notify(context)\n  }\n\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchResolveContext,\n} from '@datadog/browser-core'\nimport {\n  RequestType,\n  initFetchObservable,\n  initXhrObservable,\n  readBytesFromStream,\n  elapsed,\n  timeStampNow,\n  tryToClone,\n} from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './resource/resourceUtils'\nimport type { TraceIdentifier, Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchResolveContext extends FetchResolveContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: unknown\n  init?: RequestInit\n  error?: Error\n  isAborted: boolean\n  handlingStack?: string\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  const tracer = startTracer(configuration, sessionManager)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, configuration, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable(configuration).subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n          isAborted: context.isAborted,\n          handlingStack: context.handlingStack,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchResolveContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'resolve':\n        waitForResponseToComplete(context, (duration: Duration) => {\n          tracer.clearTracingIfNeeded(context)\n          lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n            duration,\n            method: context.method,\n            requestIndex: context.requestIndex,\n            responseType: context.responseType,\n            spanId: context.spanId,\n            startClocks: context.startClocks,\n            status: context.status,\n            traceId: context.traceId,\n            traceSampled: context.traceSampled,\n            type: RequestType.FETCH,\n            url: context.url,\n            response: context.response,\n            init: context.init,\n            input: context.input,\n            isAborted: context.isAborted,\n            handlingStack: context.handlingStack,\n          })\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n\nfunction waitForResponseToComplete(context: RumFetchResolveContext, callback: (duration: Duration) => void) {\n  const clonedResponse = context.response && tryToClone(context.response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // do not try to wait for the response if the clone failed, fetch error or null body\n    callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n  } else {\n    readBytesFromStream(\n      clonedResponse.body,\n      () => {\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n      },\n      {\n        bytesLimit: Number.POSITIVE_INFINITY,\n        collectStreamBody: false,\n      }\n    )\n  }\n}\n","export function isServerError(status: number) {\n  return status >= 500\n}\n\nexport function tryToClone(response: Response): Response | undefined {\n  try {\n    return response.clone()\n  } catch (e) {\n    // clone can throw if the response has already been used by another instrumentation or is disturbed\n    return\n  }\n}\n","import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n","import type { ServerDuration } from '@datadog/browser-core'\nimport { isNumber } from '@datadog/browser-core'\n\nexport function discardNegativeDuration(duration: ServerDuration | undefined): ServerDuration | undefined {\n  return isNumber(duration) && duration < 0 ? undefined : duration\n}\n","import { noop } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumActionEvent, RumErrorEvent, RumLongTaskEvent, RumResourceEvent } from '../rumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport interface EventCounts {\n  errorCount: number\n  actionCount: number\n  longTaskCount: number\n  resourceCount: number\n  frustrationCount: number\n}\n\nexport function trackEventCounts({\n  lifeCycle,\n  isChildEvent,\n  onChange: callback = noop,\n}: {\n  lifeCycle: LifeCycle\n  isChildEvent: (event: RumActionEvent | RumErrorEvent | RumLongTaskEvent | RumResourceEvent) => boolean\n  onChange?: () => void\n}) {\n  const eventCounts: EventCounts = {\n    errorCount: 0,\n    longTaskCount: 0,\n    resourceCount: 0,\n    actionCount: 0,\n    frustrationCount: 0,\n  }\n\n  const subscription = lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event): void => {\n    if (event.type === 'view' || event.type === 'vital' || !isChildEvent(event)) {\n      return\n    }\n    switch (event.type) {\n      case RumEventType.ERROR:\n        eventCounts.errorCount += 1\n        callback()\n        break\n      case RumEventType.ACTION:\n        eventCounts.actionCount += 1\n        if (event.action.frustration) {\n          eventCounts.frustrationCount += event.action.frustration.type.length\n        }\n        callback()\n        break\n      case RumEventType.LONG_TASK:\n        eventCounts.longTaskCount += 1\n        callback()\n        break\n      case RumEventType.RESOURCE:\n        if (!event._dd?.discarded) {\n          eventCounts.resourceCount += 1\n          callback()\n        }\n        break\n    }\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n    eventCounts,\n  }\n}\n","import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport {\n  instrumentMethod,\n  matchList,\n  monitor,\n  Observable,\n  timeStampNow,\n  setTimeout,\n  clearTimeout,\n} from '@datadog/browser-core'\nimport { RumPerformanceEntryType } from '../browser/performanceCollection'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration !== undefined\n      ? setTimeout(\n          monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n          maxDuration\n        )\n      : undefined\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  return new Observable<PageActivityEvent>((observable) => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (\n          entries.some(\n            (entry) => entry.entryType === RumPerformanceEntryType.RESOURCE && !isExcludedUrl(configuration, entry.name)\n          )\n        ) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethod(window, 'open', callback)\n}\n","// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\n/**\n * Return the parentElement of an node\n *\n * In cases where parentElement is not supported, such as in IE11 for SVG nodes, we fallback to parentNode\n */\nexport function getParentElement(node: Node): HTMLElement | null {\n  if (node.parentElement) {\n    return node.parentElement\n  }\n\n  while (node.parentNode) {\n    if (node.parentNode.nodeType === Node.ELEMENT_NODE) {\n      return node.parentNode as HTMLElement\n    }\n    node = node.parentNode\n  }\n\n  return null\n}\n\n/**\n * Return the classList of an element or an array of classes if classList is not supported\n *\n * In cases where classList is not supported, such as in IE11 for SVG and MathML elements,\n * we fallback to using element.getAttribute('class').\n * We opt for element.getAttribute('class') over element.className because className returns an SVGAnimatedString for SVG elements.\n */\nexport function getClassList(element: Element): DOMTokenList | string[] {\n  if (element.classList) {\n    return element.classList\n  }\n\n  const classes = element.getAttribute('class')?.trim()\n  return classes ? classes.split(/\\s+/) : []\n}\n\n// ie11 supports WeakMap but not WeakSet\nconst PLACEHOLDER = 1\nexport class WeakSet<T extends object> {\n  private map = new WeakMap<T, typeof PLACEHOLDER>()\n\n  constructor(initialValues?: T[]) {\n    if (initialValues) {\n      initialValues.forEach((value) => this.map.set(value, PLACEHOLDER))\n    }\n  }\n\n  add(value: T) {\n    this.map.set(value, PLACEHOLDER)\n\n    return this\n  }\n\n  delete(value: T) {\n    return this.map.delete(value)\n  }\n\n  has(value: T) {\n    return this.map.has(value)\n  }\n}\n","import { DefaultPrivacyLevel } from '@datadog/browser-core'\nimport { isElementNode, getParentNode, isTextNode } from '../browser/htmlDomUtils'\nimport { elementMatches } from '../browser/polyfills'\n\nexport const NodePrivacyLevel = {\n  IGNORE: 'ignore',\n  HIDDEN: 'hidden',\n  ALLOW: DefaultPrivacyLevel.ALLOW,\n  MASK: DefaultPrivacyLevel.MASK,\n  MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n} as const\nexport type NodePrivacyLevel = (typeof NodePrivacyLevel)[keyof typeof NodePrivacyLevel]\n\nexport const PRIVACY_ATTR_NAME = 'data-dd-privacy'\n\n// Privacy Attrs\nexport const PRIVACY_ATTR_VALUE_ALLOW = 'allow'\nexport const PRIVACY_ATTR_VALUE_MASK = 'mask'\nexport const PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input'\nexport const PRIVACY_ATTR_VALUE_HIDDEN = 'hidden'\n\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport const PRIVACY_CLASS_PREFIX = 'dd-privacy-'\n\n// Private Replacement Templates\nexport const CENSORED_STRING_MARK = '***'\nexport const CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=='\n\nexport const FORM_PRIVATE_TAG_NAMES: { [tagName: string]: true } = {\n  INPUT: true,\n  OUTPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n  OPTION: true,\n  DATALIST: true,\n  OPTGROUP: true,\n}\n\nconst TEXT_MASKING_CHAR = 'x'\n\nexport type NodePrivacyLevelCache = Map<Node, NodePrivacyLevel>\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(\n  node: Node,\n  defaultPrivacyLevel: NodePrivacyLevel,\n  cache?: NodePrivacyLevelCache\n): NodePrivacyLevel {\n  if (cache && cache.has(node)) {\n    return cache.get(node)!\n  }\n  const parentNode = getParentNode(node)\n  const parentNodePrivacyLevel = parentNode\n    ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache)\n    : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  const nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n  if (cache) {\n    cache.set(node, nodePrivacyLevel)\n  }\n  return nodePrivacyLevel\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return\n  }\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.HIDDEN))) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.MASK))) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.MASK_USER_INPUT))) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (elementMatches(node, getPrivacySelector(NodePrivacyLevel.ALLOW))) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n\nexport function getPrivacySelector(privacyLevel: string) {\n  return `[${PRIVACY_ATTR_NAME}=\"${privacyLevel}\"], .${PRIVACY_CLASS_PREFIX}${privacyLevel}`\n}\n","import { safeTruncate, isIE, find } from '@datadog/browser-core'\nimport { getParentElement } from '../../browser/polyfills'\nimport { NodePrivacyLevel, getPrivacySelector } from '../privacy'\nimport type { RumConfiguration } from '../configuration'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\nexport const ACTION_NAME_PLACEHOLDER = 'Masked Element'\nexport function getActionNameFromElement(\n  element: Element,\n  { enablePrivacyForActionName, actionNameAttribute: userProgrammaticAttribute }: RumConfiguration,\n  nodePrivacyLevel?: NodePrivacyLevel\n): string {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  const defaultActionName =\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute))\n\n  if (nodePrivacyLevel === NodePrivacyLevel.MASK) {\n    return defaultActionName || ACTION_NAME_PLACEHOLDER\n  }\n\n  return (\n    defaultActionName ||\n    getActionNameFromElementForStrategies(\n      element,\n      userProgrammaticAttribute,\n      priorityStrategies,\n      enablePrivacyForActionName\n    ) ||\n    getActionNameFromElementForStrategies(\n      element,\n      userProgrammaticAttribute,\n      fallbackStrategies,\n      enablePrivacyForActionName\n    ) ||\n    ''\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  let elementWithAttribute\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n  } else {\n    let element: Element | null = targetElement\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element\n        break\n      }\n      element = getParentElement(element)\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined,\n  privacyEnabledActionName?: boolean\n) => string | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute, privacy) => {\n    // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n    // instead\n    if (supportsLabelProperty()) {\n      if ('labels' in element && element.labels && element.labels.length > 0) {\n        return getTextualContent(element.labels[0], userProgrammaticAttribute)\n      }\n    } else if (element.id) {\n      const label =\n        element.ownerDocument &&\n        find(element.ownerDocument.querySelectorAll('label'), (label) => label.htmlFor === element.id)\n      return label && getTextualContent(label, userProgrammaticAttribute, privacy)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return input.value\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute, privacyEnabledActionName) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName)\n    }\n  },\n  (element) => element.getAttribute('aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute, privacyEnabledActionName) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return labelledByAttribute\n        .split(/\\s+/)\n        .map((id) => getElementById(element, id))\n        .filter((label): label is HTMLElement => Boolean(label))\n        .map((element) => getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName))\n        .join(' ')\n    }\n  },\n  (element) => element.getAttribute('alt'),\n  (element) => element.getAttribute('name'),\n  (element) => element.getAttribute('title'),\n  (element) => element.getAttribute('placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute, privacyEnabledActionName) =>\n    getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[],\n  privacyEnabledActionName?: boolean\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const name = strategy(element, userProgrammaticAttribute, privacyEnabledActionName)\n      if (typeof name === 'string') {\n        const trimmedName = name.trim()\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName))\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = getParentElement(element)\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getTextualContent(\n  element: Element | HTMLElement,\n  userProgrammaticAttribute: string | undefined,\n  privacyEnabledActionName?: boolean\n) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style')\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    if (privacyEnabledActionName) {\n      // remove the text of elements with privacy override\n      removeTextFromElements(\n        `${getPrivacySelector(NodePrivacyLevel.HIDDEN)}, ${getPrivacySelector(NodePrivacyLevel.MASK)}`\n      )\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE()\n}\n\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsLabelPropertyResult: boolean | undefined\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype\n  }\n  return supportsLabelPropertyResult\n}\n\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsElementClosestResult: boolean | undefined\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype\n  }\n  return supportsElementClosestResult\n}\n","import { cssEscape, elementMatches, getClassList, getParentElement } from '../browser/polyfills'\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './action/getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\ntype SelectorGetter = (element: Element, actionNameAttribute: string | undefined) => string | undefined\n\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nconst GLOBALLY_UNIQUE_SELECTOR_GETTERS: SelectorGetter[] = [getStableAttributeSelector, getIDSelector]\n\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nconst UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS: SelectorGetter[] = [\n  getStableAttributeSelector,\n  getClassSelector,\n  getTagNameSelector,\n]\n\nexport function getSelectorFromElement(\n  targetElement: Element,\n  actionNameAttribute: string | undefined\n): string | undefined {\n  if (!isConnected(targetElement)) {\n    // We cannot compute a selector for a detached element, as we don't have access to all of its\n    // parents, and we cannot determine if it's unique in the document.\n    return\n  }\n  let targetElementSelector: string | undefined\n  let currentElement: Element | null = targetElement\n\n  while (currentElement && currentElement.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      currentElement,\n      GLOBALLY_UNIQUE_SELECTOR_GETTERS,\n      isSelectorUniqueGlobally,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    if (globallyUniqueSelector) {\n      return globallyUniqueSelector\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      currentElement,\n      UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS,\n      isSelectorUniqueAmongSiblings,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    targetElementSelector =\n      uniqueSelectorAmongChildren || combineSelector(getPositionSelector(currentElement), targetElementSelector)\n\n    currentElement = getParentElement(currentElement)\n  }\n\n  return targetElementSelector\n}\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time.\n  return /[0-9]/.test(value)\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${cssEscape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  const classList = getClassList(element)\n  for (let i = 0; i < classList.length; i += 1) {\n    const className = classList[i]\n    if (isGeneratedValue(className)) {\n      continue\n    }\n\n    return `${cssEscape(element.tagName)}.${cssEscape(className)}`\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return cssEscape(element.tagName)\n}\n\nfunction getStableAttributeSelector(element: Element, actionNameAttribute: string | undefined): string | undefined {\n  if (actionNameAttribute) {\n    const selector = getAttributeSelector(actionNameAttribute)\n    if (selector) {\n      return selector\n    }\n  }\n\n  for (const attributeName of STABLE_ATTRIBUTES) {\n    const selector = getAttributeSelector(attributeName)\n    if (selector) {\n      return selector\n    }\n  }\n\n  function getAttributeSelector(attributeName: string) {\n    if (element.hasAttribute(attributeName)) {\n      return `${cssEscape(element.tagName)}[${attributeName}=\"${cssEscape(element.getAttribute(attributeName)!)}\"]`\n    }\n  }\n}\n\nfunction getPositionSelector(element: Element): string {\n  let sibling = getParentElement(element)!.firstElementChild\n  let elementIndex = 1\n\n  while (sibling && sibling !== element) {\n    if (sibling.tagName === element.tagName) {\n      elementIndex += 1\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return `${cssEscape(element.tagName)}:nth-of-type(${elementIndex})`\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: SelectorGetter[],\n  predicate: (element: Element, elementSelector: string, childSelector: string | undefined) => boolean,\n  actionNameAttribute: string | undefined,\n  childSelector: string | undefined\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element, actionNameAttribute)\n    if (!elementSelector) {\n      continue\n    }\n    if (predicate(element, elementSelector, childSelector)) {\n      return combineSelector(elementSelector, childSelector)\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(\n  element: Element,\n  elementSelector: string,\n  childSelector: string | undefined\n): boolean {\n  return element.ownerDocument.querySelectorAll(combineSelector(elementSelector, childSelector)).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > CHILD_SELECTOR\" returns a single element.\n *\n * @param {Element} currentElement - the element being considered while iterating over the target\n * element ancestors.\n *\n * @param {string} currentElementSelector - a selector that matches the current element. That\n * selector is not a composed selector (i.e. it might be a single tag name, class name...).\n *\n * @param {string|undefined} childSelector - child selector is a selector that targets a descendant\n * of the current element. When undefined, the current element is the target element.\n *\n * # Scope selector usage\n *\n * When composed together, the final selector will be joined with `>` operators to make sure we\n * target direct descendants at each level. In this function, we'll use `querySelector` to check if\n * a selector matches descendants of the current element. But by default, the query selector match\n * elements at any level. Example:\n *\n * ```html\n * <main>\n *   <div>\n *     <span></span>\n *   </div>\n *   <marquee>\n *     <div>\n *       <span></span>\n *     </div>\n *   </marquee>\n * </main>\n * ```\n *\n * `sibling.querySelector('DIV > SPAN')` will match both span elements, so we would consider the\n * selector to be not unique, even if it is unique when we'll compose it with the parent with a `>`\n * operator (`MAIN > DIV > SPAN`).\n *\n * To avoid this, we can use the `:scope` selector to make sure the selector starts from the current\n * sibling (i.e. `sibling.querySelector('DIV:scope > SPAN')` will only match the first span).\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT CHILD_SELECTOR\" returns a single element), regardless of whether the selector is\n * a direct descendant of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n *\n * [1]: https://developer.mozilla.org/fr/docs/Web/CSS/:scope\n *\n * # Performance considerations\n *\n * We compute selectors in performance-critical operations (ex: during a click), so we need to make\n * sure the function is as fast as possible. We observed that naively using `querySelectorAll` to\n * check if the selector matches more than 1 element is quite expensive, so we want to avoid it.\n *\n * Because we are iterating the DOM upward and we use that function at every level, we know the\n * child selector is already unique among the current element children, so we don't need to check\n * for the current element subtree.\n *\n * Instead, we can focus on the current element siblings. If we find a single element matching the\n * selector within a sibling, we know that it's not unique. This allows us to use `querySelector`\n * (or `matches`, when the current element is the target element) instead of `querySelectorAll`.\n */\nexport function isSelectorUniqueAmongSiblings(\n  currentElement: Element,\n  currentElementSelector: string,\n  childSelector: string | undefined\n): boolean {\n  let isSiblingMatching: (sibling: Element) => boolean\n\n  if (childSelector === undefined) {\n    // If the child selector is undefined (meaning `currentElement` is the target element, not one\n    // of its ancestor), we need to use `matches` to check if the sibling is matching the selector,\n    // as `querySelector` only returns a descendant of the element.\n    isSiblingMatching = (sibling) => elementMatches(sibling, currentElementSelector)\n  } else {\n    const scopedSelector = supportScopeSelector()\n      ? combineSelector(`${currentElementSelector}:scope`, childSelector)\n      : combineSelector(currentElementSelector, childSelector)\n    isSiblingMatching = (sibling) => sibling.querySelector(scopedSelector) !== null\n  }\n\n  const parent = getParentElement(currentElement)!\n  let sibling = parent.firstElementChild\n  while (sibling) {\n    if (sibling !== currentElement && isSiblingMatching(sibling)) {\n      return false\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return true\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n\nlet supportScopeSelectorCache: boolean | undefined\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope')\n      supportScopeSelectorCache = true\n    } catch {\n      supportScopeSelectorCache = false\n    }\n  }\n  return supportScopeSelectorCache\n}\n\n/**\n * Polyfill-utility for the `isConnected` property not supported in IE11\n */\nfunction isConnected(element: Element): boolean {\n  if (\n    'isConnected' in\n    // cast is to make sure `element` is not inferred as `never` after the check\n    (element as { isConnected?: boolean })\n  ) {\n    return element.isConnected\n  }\n\n  return element.ownerDocument.documentElement.contains(element)\n}\n","import type { TimeoutId } from '@datadog/browser-core'\nimport { ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { Click } from './trackClickActions'\n\nexport interface ClickChain {\n  tryAppend: (click: Click) => boolean\n  stop: () => void\n}\n\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100\n\nconst enum ClickChainStatus {\n  WaitingForMoreClicks,\n  WaitingForClicksToStop,\n  Finalized,\n}\n\nexport function createClickChain(firstClick: Click, onFinalize: (clicks: Click[]) => void): ClickChain {\n  const bufferedClicks: Click[] = []\n  let status = ClickChainStatus.WaitingForMoreClicks\n  let maxDurationBetweenClicksTimeoutId: TimeoutId | undefined\n  appendClick(firstClick)\n\n  function appendClick(click: Click) {\n    click.stopObservable.subscribe(tryFinalize)\n    bufferedClicks.push(click)\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS)\n  }\n\n  function tryFinalize() {\n    if (status === ClickChainStatus.WaitingForClicksToStop && bufferedClicks.every((click) => click.isStopped())) {\n      status = ClickChainStatus.Finalized\n      onFinalize(bufferedClicks)\n    }\n  }\n\n  function dontAcceptMoreClick() {\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    if (status === ClickChainStatus.WaitingForMoreClicks) {\n      status = ClickChainStatus.WaitingForClicksToStop\n      tryFinalize()\n    }\n  }\n\n  return {\n    tryAppend: (click) => {\n      if (status !== ClickChainStatus.WaitingForMoreClicks) {\n        return false\n      }\n\n      if (\n        bufferedClicks.length > 0 &&\n        !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)\n      ) {\n        dontAcceptMoreClick()\n        return false\n      }\n\n      appendClick(click)\n      return true\n    },\n    stop: () => {\n      dontAcceptMoreClick()\n    },\n  }\n}\n\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first: MouseEvent, second: MouseEvent) {\n  return (\n    first.target === second.target &&\n    mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n    first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS\n  )\n}\n\nfunction mouseEventDistance(origin: MouseEvent, other: MouseEvent) {\n  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2))\n}\n","import { addEventListener, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\n\nexport type MouseEventOnElement = PointerEvent & { target: Element }\n\nexport interface UserActivity {\n  selection: boolean\n  input: boolean\n  scroll: boolean\n}\nexport interface ActionEventsHooks<ClickContext> {\n  onPointerDown: (event: MouseEventOnElement) => ClickContext | undefined\n  onPointerUp: (context: ClickContext, event: MouseEventOnElement, getUserActivity: () => UserActivity) => void\n}\n\nexport function listenActionEvents<ClickContext>(\n  configuration: RumConfiguration,\n  { onPointerDown, onPointerUp }: ActionEventsHooks<ClickContext>\n) {\n  let selectionEmptyAtPointerDown: boolean\n  let userActivity: UserActivity = {\n    selection: false,\n    input: false,\n    scroll: false,\n  }\n  let clickContext: ClickContext | undefined\n\n  const listeners = [\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.POINTER_DOWN,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event)) {\n          selectionEmptyAtPointerDown = isSelectionEmpty()\n          userActivity = {\n            selection: false,\n            input: false,\n            scroll: false,\n          }\n          clickContext = onPointerDown(event)\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.SELECTION_CHANGE,\n      () => {\n        if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n          userActivity.selection = true\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.SCROLL,\n      () => {\n        userActivity.scroll = true\n      },\n      { capture: true, passive: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.POINTER_UP,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event) && clickContext) {\n          // Use a scoped variable to make sure the value is not changed by other clicks\n          const localUserActivity = userActivity\n          onPointerUp(clickContext, event, () => localUserActivity)\n          clickContext = undefined\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      configuration,\n      window,\n      DOM_EVENT.INPUT,\n      () => {\n        userActivity.input = true\n      },\n      { capture: true }\n    ),\n  ]\n\n  return {\n    stop: () => {\n      listeners.forEach((listener) => listener.stop())\n    },\n  }\n}\n\nfunction isSelectionEmpty(): boolean {\n  const selection = window.getSelection()\n  return !selection || selection.isCollapsed\n}\n\nfunction isValidPointerEvent(event: PointerEvent): event is MouseEventOnElement {\n  return (\n    event.target instanceof Element &&\n    // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in\n    // the future.\n    event.isPrimary !== false\n  )\n}\n","import { ONE_SECOND } from '@datadog/browser-core'\nimport { FrustrationType } from '../../rawRumEvent.types'\nimport { elementMatches } from '../../browser/polyfills'\nimport type { Click } from './trackClickActions'\n\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3\n\nexport function computeFrustration(clicks: Click[], rageClick: Click) {\n  if (isRage(clicks)) {\n    rageClick.addFrustration(FrustrationType.RAGE_CLICK)\n    if (clicks.some(isDead)) {\n      rageClick.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n    if (rageClick.hasError) {\n      rageClick.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    return { isRage: true }\n  }\n\n  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection)\n  clicks.forEach((click) => {\n    if (click.hasError) {\n      click.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    if (\n      isDead(click) &&\n      // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n      !hasSelectionChanged\n    ) {\n      click.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n  })\n  return { isRage: false }\n}\n\nexport function isRage(clicks: Click[]) {\n  if (clicks.some((click) => click.getUserActivity().selection || click.getUserActivity().scroll)) {\n    return false\n  }\n  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n    if (\n      clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n      ONE_SECOND\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst DEAD_CLICK_EXCLUDE_SELECTOR =\n  // inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n  // inputs (using a negative selector is shorter here)\n  'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n  'textarea,' +\n  'select,' +\n  // contenteditable and their descendants don't always trigger meaningful changes when manipulated\n  '[contenteditable],' +\n  '[contenteditable] *,' +\n  // canvas, as there is no good way to detect activity occurring on them\n  'canvas,' +\n  // links that are interactive (have an href attribute) or any of their descendants, as they can\n  // open a new tab or navigate to a hash without triggering a meaningful event\n  'a[href],' +\n  'a[href] *'\n\nexport function isDead(click: Click) {\n  if (click.hasPageActivity || click.getUserActivity().input || click.getUserActivity().scroll) {\n    return false\n  }\n  return !elementMatches(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR)\n}\n","import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  includes,\n  timeStampNow,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ValueHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../rawRumEvent.types'\nimport { ActionType } from '../../rawRumEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { trackEventCounts } from '../trackEventCounts'\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../waitPageActivityEnd'\nimport { getSelectorFromElement } from '../getSelectorFromElement'\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '../privacy'\nimport type { RumConfiguration } from '../configuration'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport type { MouseEventOnElement, UserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string | undefined\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ValueHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ValueHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<{\n    clickActionBase: ClickActionBase\n    hadActivityOnPointerDown: () => boolean\n  }>(configuration, {\n    onPointerDown: (pointerDownEvent) =>\n      processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent),\n    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) => {\n      startClickAction(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        startEvent,\n        getUserActivity,\n        hadActivityOnPointerDown\n      )\n    },\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) => history.findAll(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  pointerDownEvent: MouseEventOnElement\n) {\n  const nodePrivacyLevel = configuration.enablePrivacyForActionName\n    ? getNodePrivacyLevel(pointerDownEvent.target, configuration.defaultPrivacyLevel)\n    : NodePrivacyLevel.ALLOW\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return undefined\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, nodePrivacyLevel, configuration)\n\n  let hadActivityOnPointerDown = false\n\n  waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity\n    },\n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n\n  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown }\n}\n\nfunction startClickAction(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement,\n  getUserActivity: () => UserActivity,\n  hadActivityOnPointerDown: () => boolean\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent)\n  appendClickToClickChain(click)\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        if (pageActivityEndEvent.hadActivity) {\n          click.stop(pageActivityEndEvent.end)\n        } else if (hadActivityOnPointerDown()) {\n          click.stop(\n            // using the click start as activity end, so the click will have some activity but its\n            // duration will be 0 (as the activity started before the click start)\n            click.startClocks.timeStamp\n          )\n        } else {\n          click.stop()\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(\n  event: MouseEventOnElement,\n  nodePrivacyLevel: NodePrivacyLevel,\n  configuration: RumConfiguration\n): ClickActionBase {\n  const rect = event.target.getBoundingClientRect()\n\n  return {\n    type: ActionType.CLICK,\n    target: {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, configuration.actionNameAttribute),\n    },\n    position: {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    },\n    name: getActionNameFromElement(event.target, configuration, nodePrivacyLevel),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: () => UserActivity,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) =>\n      event.action !== undefined &&\n      (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id),\n  })\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: startEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [startEvent],\n          event: startEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n","import type { ClocksState, Context, Observable } from '@datadog/browser-core'\nimport { noop, assign, combine, toServerDuration, generateUUID } from '@datadog/browser-core'\n\nimport { discardNegativeDuration } from '../discardNegativeDuration'\nimport type { RawRumActionEvent } from '../../rawRumEvent.types'\nimport { ActionType, RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RumConfiguration } from '../configuration'\nimport type { CommonContext } from '../contexts/commonContext'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport { PageState } from '../contexts/pageStateHistory'\nimport type { RumActionEventDomainContext } from '../../domainContext.types'\nimport type { ActionContexts, ClickAction } from './trackClickActions'\nimport { trackClickActions } from './trackClickActions'\n\nexport type { ActionContexts }\n\nexport interface CustomAction {\n  type: ActionType.CUSTOM\n  name: string\n  startClocks: ClocksState\n  context?: Context\n  handlingStack?: string\n}\n\nexport type AutoAction = ClickAction\n\nexport function startActionCollection(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory\n) {\n  lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, (action) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action, pageStateHistory))\n  )\n\n  let actionContexts: ActionContexts = { findActionId: noop as () => undefined }\n  if (configuration.trackUserInteractions) {\n    actionContexts = trackClickActions(lifeCycle, domMutationObservable, configuration).actionContexts\n  }\n\n  return {\n    addAction: (action: CustomAction, savedCommonContext?: CommonContext) => {\n      lifeCycle.notify(\n        LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n        assign(\n          {\n            savedCommonContext,\n          },\n          processAction(action, pageStateHistory)\n        )\n      )\n    },\n    actionContexts,\n  }\n}\n\nfunction processAction(\n  action: AutoAction | CustomAction,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumActionEvent> {\n  const autoActionProperties = isAutoAction(action)\n    ? {\n        action: {\n          id: action.id,\n          loading_time: discardNegativeDuration(toServerDuration(action.duration)),\n          frustration: {\n            type: action.frustrationTypes,\n          },\n          error: {\n            count: action.counts.errorCount,\n          },\n          long_task: {\n            count: action.counts.longTaskCount,\n          },\n          resource: {\n            count: action.counts.resourceCount,\n          },\n        },\n        _dd: {\n          action: {\n            target: action.target,\n            position: action.position,\n          },\n        },\n      }\n    : undefined\n  const customerContext = !isAutoAction(action) ? action.context : undefined\n  const actionEvent: RawRumActionEvent = combine(\n    {\n      action: {\n        id: generateUUID(),\n        target: {\n          name: action.name,\n        },\n        type: action.type,\n      },\n      date: action.startClocks.timeStamp,\n      type: RumEventType.ACTION as const,\n      view: { in_foreground: pageStateHistory.wasInPageStateAt(PageState.ACTIVE, action.startClocks.relative) },\n    },\n    autoActionProperties\n  )\n\n  const domainContext: RumActionEventDomainContext = isAutoAction(action) ? { events: action.events } : {}\n\n  if (!isAutoAction(action) && action.handlingStack) {\n    domainContext.handlingStack = action.handlingStack\n  }\n\n  return {\n    customerContext,\n    rawRumEvent: actionEvent,\n    startTime: action.startClocks.relative,\n    domainContext,\n  }\n}\n\nfunction isAutoAction(action: AutoAction | CustomAction): action is AutoAction {\n  return action.type !== ActionType.CUSTOM\n}\n","import { instrumentMethod } from '../../tools/instrumentMethod'\nimport type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace, computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace'\nimport { computeRawError } from './error'\nimport type { RawError } from './error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from './error.types'\n\nexport type UnhandledErrorCallback = (stackTrace: StackTrace, originalError?: any) => any\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  const handleRuntimeError = (stackTrace: StackTrace, originalError?: any) => {\n    const rawError = computeRawError({\n      stackTrace,\n      originalError,\n      startClocks: clocksNow(),\n      nonErrorPrefix: NonErrorPrefix.UNCAUGHT,\n      source: ErrorSource.SOURCE,\n      handling: ErrorHandling.UNHANDLED,\n    })\n    errorObservable.notify(rawError)\n  }\n  const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\nexport function instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethod(window, 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {\n    let stackTrace\n    if (errorObj instanceof Error) {\n      stackTrace = computeStackTrace(errorObj)\n    } else {\n      stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column)\n    }\n    callback(stackTrace, errorObj ?? messageObj)\n  })\n}\n\nexport function instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethod(window, 'onunhandledrejection', ({ parameters: [e] }) => {\n    const reason = e.reason || 'Empty reason'\n    const stack = computeStackTrace(reason)\n    callback(stack, reason)\n  })\n}\n","import { flattenErrorCauses, tryToGetFingerprint } from '../error/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { ConsoleApiName, globalConsole } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport { find } from '../../tools/utils/polyfills'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { RawErrorCause } from '../error/error.types'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { createHandlingStack, toStackTraceString, formatErrorMessage } from '../../tools/stackTrace/handlingStack'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack: string\n  fingerprint?: string\n  causes?: RawErrorCause[]\n}\n\nlet consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\nexport function resetConsoleObservable() {\n  consoleObservablesByApi = {}\n}\n\nfunction createConsoleObservable(api: ConsoleApiName) {\n  return new Observable<ConsoleLog>((observable) => {\n    const originalConsoleApi = globalConsole[api]\n\n    globalConsole[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      globalConsole[api] = originalConsoleApi\n    }\n  })\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  const message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n  let fingerprint\n  let causes\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    fingerprint = tryToGetFingerprint(firstErrorParam)\n    causes = firstErrorParam ? flattenErrorCauses(firstErrorParam, 'console') : undefined\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n    fingerprint,\n    causes,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return sanitize(param)\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(sanitize(param), undefined, 2)\n}\n","import { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport { includes } from '../../tools/utils/polyfills'\nimport { safeTruncate } from '../../tools/utils/stringUtils'\nimport type { Configuration } from '../configuration'\nimport type { ReportType, InterventionReport, DeprecationReport } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = (typeof RawReportType)[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  originalReport: SecurityPolicyViolationEvent | DeprecationReport | InterventionReport\n  stack?: string\n}\n\nexport function initReportObservable(configuration: Configuration, apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable(configuration))\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  return new Observable<RawReport>((observable) => {\n    if (!window.ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Array<DeprecationReport | InterventionReport>, _: ReportingObserver) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    ) as ReportingObserverCallback\n\n    const observer = new window.ReportingObserver(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n}\n\nfunction createCspViolationReportObservable(configuration: Configuration) {\n  return new Observable<RawReport>((observable) => {\n    const { stop } = addEventListener(configuration, document, DOM_EVENT.SECURITY_POLICY_VIOLATION, (event) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    return stop\n  })\n}\n\nfunction buildRawReportFromReport(report: DeprecationReport | InterventionReport): RawReport {\n  const { type, body } = report\n\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    originalReport: report,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n    originalReport: event,\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | null,\n  lineNumber: number | null,\n  columnNumber: number | null\n): string | undefined {\n  return sourceFile\n    ? toStackTraceString({\n        name,\n        message,\n        stack: [\n          {\n            func: '?',\n            url: sourceFile,\n            line: lineNumber ?? undefined,\n            column: columnNumber ?? undefined,\n          },\n        ],\n      })\n    : undefined\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport {\n  isEmptyObject,\n  assign,\n  ErrorSource,\n  generateUUID,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  Observable,\n  trackRuntimeError,\n  NonErrorPrefix,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { RawRumErrorEvent } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { FeatureFlagContexts } from '../contexts/featureFlagContext'\nimport type { CommonContext } from '../contexts/commonContext'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport { PageState } from '../contexts/pageStateHistory'\nimport type { RumErrorEventDomainContext } from '../../domainContext.types'\nimport { trackConsoleError } from './trackConsoleError'\nimport { trackReportError } from './trackReportError'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startErrorCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n) {\n  const errorObservable = new Observable<RawError>()\n\n  trackConsoleError(errorObservable)\n  trackRuntimeError(errorObservable)\n  trackReportError(configuration, errorObservable)\n\n  errorObservable.subscribe((error) => lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error }))\n\n  return doStartErrorCollection(lifeCycle, pageStateHistory, featureFlagContexts)\n}\n\nexport function doStartErrorCollection(\n  lifeCycle: LifeCycle,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n) {\n  lifeCycle.subscribe(LifeCycleEventType.RAW_ERROR_COLLECTED, ({ error, customerContext, savedCommonContext }) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      assign(\n        {\n          customerContext,\n          savedCommonContext,\n        },\n        processError(error, pageStateHistory, featureFlagContexts)\n      )\n    )\n  })\n\n  return {\n    addError: (\n      { error, handlingStack, startClocks, context: customerContext }: ProvidedError,\n      savedCommonContext?: CommonContext\n    ) => {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        handlingStack,\n        startClocks,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n      })\n\n      lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, {\n        customerContext,\n        savedCommonContext,\n        error: rawError,\n      })\n    },\n  }\n}\n\nfunction processError(\n  error: RawError,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n): RawRumEventCollectedData<RawRumErrorEvent> {\n  const rawRumEvent: RawRumErrorEvent = {\n    date: error.startClocks.timeStamp,\n    error: {\n      id: generateUUID(),\n      message: error.message,\n      source: error.source,\n      stack: error.stack,\n      handling_stack: error.handlingStack,\n      type: error.type,\n      handling: error.handling,\n      causes: error.causes,\n      source_type: 'browser',\n      fingerprint: error.fingerprint,\n      csp: error.csp,\n    },\n    type: RumEventType.ERROR as const,\n    view: { in_foreground: pageStateHistory.wasInPageStateAt(PageState.ACTIVE, error.startClocks.relative) },\n  }\n\n  const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(error.startClocks.relative)\n  if (featureFlagContext && !isEmptyObject(featureFlagContext)) {\n    rawRumEvent.feature_flags = featureFlagContext\n  }\n\n  const domainContext: RumErrorEventDomainContext = {\n    error: error.originalError,\n    handlingStack: error.handlingStack,\n  }\n\n  return {\n    rawRumEvent,\n    startTime: error.startClocks.relative,\n    domainContext,\n  }\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, initConsoleObservable, ErrorSource, ConsoleApiName } from '@datadog/browser-core'\n\nexport function trackConsoleError(errorObservable: Observable<RawError>) {\n  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleError) =>\n    errorObservable.notify({\n      startClocks: clocksNow(),\n      message: consoleError.message,\n      stack: consoleError.stack,\n      fingerprint: consoleError.fingerprint,\n      source: ErrorSource.CONSOLE,\n      handling: ErrorHandling.HANDLED,\n      handlingStack: consoleError.handlingStack,\n    })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, ErrorSource, initReportObservable, RawReportType } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\n\nexport function trackReportError(configuration: RumConfiguration, errorObservable: Observable<RawError>) {\n  const subscription = initReportObservable(configuration, [\n    RawReportType.cspViolation,\n    RawReportType.intervention,\n  ]).subscribe((reportError) => {\n    const rawError: RawError = {\n      startClocks: clocksNow(),\n      message: reportError.message,\n      stack: reportError.stack,\n      type: reportError.subtype,\n      source: ErrorSource.REPORT,\n      handling: ErrorHandling.UNHANDLED,\n      originalError: reportError.originalReport,\n    }\n\n    if (reportError.originalReport.type === 'securitypolicyviolation') {\n      rawError.csp = {\n        disposition: reportError.originalReport.disposition,\n      }\n    }\n\n    return errorObservable.notify(rawError)\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceCollection'\nimport type { RequestCompleteEvent } from '../requestCollection'\nimport { WeakSet } from '../../browser/polyfills'\nimport { isValidEntry } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\nconst alreadyMatchedEntries = new WeakSet<PerformanceEntry>()\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - filter out timing that were already matched to a request\n * - then, if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource') as RumPerformanceResourceTiming[]\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .filter((entry) => !alreadyMatchedEntries.has(entry))\n    .filter((entry) => isValidEntry(entry))\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    alreadyMatchedEntries.add(candidates[0])\n\n    return candidates[0].toJSON() as RumPerformanceResourceTiming\n  }\n\n  return\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n","import type { ClocksState, Duration } from '@datadog/browser-core'\nimport {\n  combine,\n  generateUUID,\n  RequestType,\n  ResourceType,\n  toServerDuration,\n  relativeToClocks,\n  assign,\n  isNumber,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { RumPerformanceResourceTiming } from '../../browser/performanceCollection'\nimport { RumPerformanceEntryType } from '../../browser/performanceCollection'\nimport type { RumXhrResourceEventDomainContext, RumFetchResourceEventDomainContext } from '../../domainContext.types'\nimport type { RawRumResourceEvent } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RawRumEventCollectedData, LifeCycle } from '../lifeCycle'\nimport type { RequestCompleteEvent } from '../requestCollection'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport { PageState } from '../contexts/pageStateHistory'\nimport { matchRequestTiming } from './matchRequestTiming'\nimport {\n  computePerformanceResourceDetails,\n  computePerformanceResourceDuration,\n  computeResourceKind,\n  computeSize,\n  isRequestKind,\n  isLongDataUrl,\n  sanitizeDataUrl,\n} from './resourceUtils'\n\nexport function startResourceCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory\n) {\n  lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request: RequestCompleteEvent) => {\n    const rawEvent = processRequest(request, configuration, pageStateHistory)\n    if (rawEvent) {\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, rawEvent)\n    }\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === RumPerformanceEntryType.RESOURCE && !isRequestKind(entry)) {\n        const rawEvent = processResourceEntry(entry, configuration)\n        if (rawEvent) {\n          lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, rawEvent)\n        }\n      }\n    }\n  })\n}\n\nfunction processRequest(\n  request: RequestCompleteEvent,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumResourceEvent> | undefined {\n  const matchingTiming = matchRequestTiming(request)\n  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks\n  const tracingInfo = computeRequestTracingInfo(request, configuration)\n  if (!configuration.trackResources && !tracingInfo) {\n    return\n  }\n\n  const type = request.type === RequestType.XHR ? ResourceType.XHR : ResourceType.FETCH\n\n  const correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined\n\n  const duration = computeRequestDuration(pageStateHistory, startClocks, request.duration)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration,\n        method: request.method,\n        status_code: request.status,\n        url: isLongDataUrl(request.url) ? sanitizeDataUrl(request.url) : request.url,\n      },\n      type: RumEventType.RESOURCE as const,\n      _dd: {\n        discarded: !configuration.trackResources,\n      },\n    },\n    tracingInfo,\n    correspondingTimingOverrides\n  )\n\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: matchingTiming,\n      xhr: request.xhr,\n      response: request.response,\n      requestInput: request.input,\n      requestInit: request.init,\n      error: request.error,\n      isAborted: request.isAborted,\n      handlingStack: request.handlingStack,\n    } as RumFetchResourceEventDomainContext | RumXhrResourceEventDomainContext,\n  }\n}\n\nfunction processResourceEntry(\n  entry: RumPerformanceResourceTiming,\n  configuration: RumConfiguration\n): RawRumEventCollectedData<RawRumResourceEvent> | undefined {\n  const startClocks = relativeToClocks(entry.startTime)\n  const tracingInfo = computeEntryTracingInfo(entry, configuration)\n  if (!configuration.trackResources && !tracingInfo) {\n    return\n  }\n\n  const type = computeResourceKind(entry)\n  const entryMetrics = computePerformanceEntryMetrics(entry)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        url: entry.name,\n        status_code: discardZeroStatus(entry.responseStatus),\n      },\n      type: RumEventType.RESOURCE as const,\n      _dd: {\n        discarded: !configuration.trackResources,\n      },\n    },\n    tracingInfo,\n    entryMetrics\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: entry,\n    },\n  }\n}\n\nfunction computePerformanceEntryMetrics(timing: RumPerformanceResourceTiming) {\n  const { renderBlockingStatus } = timing\n  return {\n    resource: assign(\n      {\n        duration: computePerformanceResourceDuration(timing),\n        render_blocking_status: renderBlockingStatus,\n      },\n      computeSize(timing),\n      computePerformanceResourceDetails(timing)\n    ),\n  }\n}\n\nfunction computeRequestTracingInfo(request: RequestCompleteEvent, configuration: RumConfiguration) {\n  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      span_id: request.spanId!.toDecimalString(),\n      trace_id: request.traceId!.toDecimalString(),\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\nfunction computeEntryTracingInfo(entry: RumPerformanceResourceTiming, configuration: RumConfiguration) {\n  const hasBeenTraced = entry.traceId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      trace_id: entry.traceId,\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\n/**\n * @returns number between 0 and 1 which represents trace sample rate\n */\nfunction getRulePsr(configuration: RumConfiguration) {\n  return isNumber(configuration.traceSampleRate) ? configuration.traceSampleRate / 100 : undefined\n}\n\nfunction computeRequestDuration(pageStateHistory: PageStateHistory, startClocks: ClocksState, duration: Duration) {\n  return !pageStateHistory.wasInPageStateDuringPeriod(PageState.FROZEN, startClocks.relative, duration)\n    ? toServerDuration(duration)\n    : undefined\n}\n\n/**\n * The status is 0 for cross-origin resources without CORS headers, so the status is meaningless, and we shouldn't report it\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStatus#cross-origin_response_status_codes\n */\nfunction discardZeroStatus(statusCode: number | undefined): number | undefined {\n  return statusCode === 0 ? undefined : statusCode\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { ONE_MINUTE, find } from '@datadog/browser-core'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumPerformancePaintTiming } from '../../../browser/performanceCollection'\nimport { RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport type { FirstHidden } from './trackFirstHidden'\n\n// Discard FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const FCP_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport function trackFirstContentfulPaint(\n  lifeCycle: LifeCycle,\n  firstHidden: FirstHidden,\n  callback: (fcpTiming: RelativeTime) => void\n) {\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const fcpEntry = find(\n        entries,\n        (entry): entry is RumPerformancePaintTiming =>\n          entry.entryType === RumPerformanceEntryType.PAINT &&\n          entry.name === 'first-contentful-paint' &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < FCP_MAXIMUM_DELAY\n      )\n      if (fcpEntry) {\n        callback(fcpEntry.startTime)\n      }\n    }\n  )\n  return {\n    stop: unsubscribeLifeCycle,\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { DOM_EVENT, ONE_MINUTE, addEventListeners, findLast } from '@datadog/browser-core'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { LifeCycle } from '../../lifeCycle'\nimport type { RumConfiguration } from '../../configuration'\nimport { RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport type { RumLargestContentfulPaintTiming } from '../../../browser/performanceCollection'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { FirstHidden } from './trackFirstHidden'\n\n// Discard LCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport interface LargestContentfulPaint {\n  value: RelativeTime\n  targetSelector?: string\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts\n */\nexport function trackLargestContentfulPaint(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  firstHidden: FirstHidden,\n  eventTarget: Window,\n  callback: (largestContentfulPaint: LargestContentfulPaint) => void\n) {\n  // Ignore entries that come after the first user interaction. According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    configuration,\n    eventTarget,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  let biggestLcpSize = 0\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < LCP_MAXIMUM_DELAY &&\n          // Ensure to get the LCP entry with the biggest size, see\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655\n          entry.size > biggestLcpSize\n      )\n\n      if (lcpEntry) {\n        let lcpTargetSelector\n        if (lcpEntry.element) {\n          lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute)\n        }\n\n        callback({\n          value: lcpEntry.startTime,\n          targetSelector: lcpTargetSelector,\n        })\n        biggestLcpSize = lcpEntry.size\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n","import type { Duration } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { trackFirstContentfulPaint } from './trackFirstContentfulPaint'\nimport type { FirstInput } from './trackFirstInput'\nimport { trackFirstInput } from './trackFirstInput'\nimport type { NavigationTimings } from './trackNavigationTimings'\nimport { trackNavigationTimings } from './trackNavigationTimings'\nimport type { LargestContentfulPaint } from './trackLargestContentfulPaint'\nimport { trackLargestContentfulPaint } from './trackLargestContentfulPaint'\nimport { trackFirstHidden } from './trackFirstHidden'\n\nexport interface InitialViewMetrics {\n  firstContentfulPaint?: Duration\n  navigationTimings?: NavigationTimings\n  largestContentfulPaint?: LargestContentfulPaint\n  firstInput?: FirstInput\n}\n\nexport function trackInitialViewMetrics(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  setLoadEvent: (loadEnd: Duration) => void,\n  scheduleViewUpdate: () => void\n) {\n  const initialViewMetrics: InitialViewMetrics = {}\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(lifeCycle, (navigationTimings) => {\n    setLoadEvent(navigationTimings.loadEvent)\n    initialViewMetrics.navigationTimings = navigationTimings\n    scheduleViewUpdate()\n  })\n\n  const firstHidden = trackFirstHidden(configuration)\n  const { stop: stopFCPTracking } = trackFirstContentfulPaint(lifeCycle, firstHidden, (firstContentfulPaint) => {\n    initialViewMetrics.firstContentfulPaint = firstContentfulPaint\n    scheduleViewUpdate()\n  })\n\n  const { stop: stopLCPTracking } = trackLargestContentfulPaint(\n    lifeCycle,\n    configuration,\n    firstHidden,\n    window,\n    (largestContentfulPaint) => {\n      initialViewMetrics.largestContentfulPaint = largestContentfulPaint\n      scheduleViewUpdate()\n    }\n  )\n\n  const { stop: stopFIDTracking } = trackFirstInput(lifeCycle, configuration, firstHidden, (firstInput) => {\n    initialViewMetrics.firstInput = firstInput\n    scheduleViewUpdate()\n  })\n\n  function stop() {\n    stopNavigationTracking()\n    stopFCPTracking()\n    stopLCPTracking()\n    stopFIDTracking()\n    firstHidden.stop()\n  }\n\n  return {\n    stop,\n    initialViewMetrics,\n  }\n}\n","import type { Duration } from '@datadog/browser-core'\nimport { relativeNow } from '@datadog/browser-core'\nimport { RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\n\nexport interface NavigationTimings {\n  domComplete: Duration\n  domContentLoaded: Duration\n  domInteractive: Duration\n  loadEvent: Duration\n  firstByte: Duration | undefined\n}\n\nexport function trackNavigationTimings(lifeCycle: LifeCycle, callback: (timings: NavigationTimings) => void) {\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === RumPerformanceEntryType.NAVIGATION) {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n        })\n      }\n    }\n  })\n\n  return { stop }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\n\nexport type FirstHidden = ReturnType<typeof trackFirstHidden>\n\nexport function trackFirstHidden(configuration: RumConfiguration, eventTarget: Window = window) {\n  let timeStamp: RelativeTime\n  let stopListeners: () => void | undefined\n\n  if (document.visibilityState === 'hidden') {\n    timeStamp = 0 as RelativeTime\n  } else {\n    timeStamp = Infinity as RelativeTime\n    ;({ stop: stopListeners } = addEventListeners(\n      configuration,\n      eventTarget,\n      [DOM_EVENT.PAGE_HIDE, DOM_EVENT.VISIBILITY_CHANGE],\n      (event) => {\n        if (event.type === DOM_EVENT.PAGE_HIDE || document.visibilityState === 'hidden') {\n          timeStamp = event.timeStamp as RelativeTime\n          stopListeners()\n        }\n      },\n      { capture: true }\n    ))\n  }\n\n  return {\n    get timeStamp() {\n      return timeStamp\n    },\n    stop() {\n      stopListeners?.()\n    },\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { elapsed, find } from '@datadog/browser-core'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport type { RumFirstInputTiming } from '../../../browser/performanceCollection'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { FirstHidden } from './trackFirstHidden'\n\nexport interface FirstInput {\n  delay: Duration\n  time: RelativeTime\n  targetSelector?: string\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInput(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  firstHidden: FirstHidden,\n  callback: (firstInput: FirstInput) => void\n) {\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const firstInputEntry = find(\n        entries,\n        (entry): entry is RumFirstInputTiming =>\n          entry.entryType === RumPerformanceEntryType.FIRST_INPUT && entry.startTime < firstHidden.timeStamp\n      )\n      if (firstInputEntry) {\n        const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n        let firstInputTargetSelector\n\n        if (firstInputEntry.target && isElementNode(firstInputEntry.target)) {\n          firstInputTargetSelector = getSelectorFromElement(firstInputEntry.target, configuration.actionNameAttribute)\n        }\n\n        callback({\n          // Ensure firstInputDelay to be positive, see\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n          delay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n          time: firstInputEntry.startTime,\n          targetSelector: firstInputTargetSelector,\n        })\n      }\n    }\n  )\n\n  return {\n    stop: unsubscribeLifeCycle,\n  }\n}\n","import { round, find, ONE_SECOND, noop, elapsed } from '@datadog/browser-core'\nimport type { Duration, RelativeTime, WeakRef, WeakRefConstructor } from '@datadog/browser-core'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType } from '../../../browser/performanceCollection'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport type { RumConfiguration } from '../../configuration'\n\nexport interface CumulativeLayoutShift {\n  value: number\n  targetSelector?: string\n  time?: Duration\n}\n\ndeclare const WeakRef: WeakRefConstructor\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nexport function trackCumulativeLayoutShift(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  viewStart: RelativeTime,\n  callback: (cumulativeLayoutShift: CumulativeLayoutShift) => void\n) {\n  if (!isLayoutShiftSupported()) {\n    return {\n      stop: noop,\n    }\n  }\n\n  let maxClsValue = 0\n  // WeakRef is not supported in IE11 and Safari mobile, but so is the layout shift API, so this code won't be executed in these browsers\n  let maxClsTarget: WeakRef<HTMLElement> | undefined\n  let maxClsStartTime: Duration | undefined\n\n  // if no layout shift happen the value should be reported as 0\n  callback({\n    value: 0,\n  })\n\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === RumPerformanceEntryType.LAYOUT_SHIFT && !entry.hadRecentInput) {\n        const { cumulatedValue, isMaxValue } = window.update(entry)\n\n        if (isMaxValue) {\n          const target = getTargetFromSource(entry.sources)\n          maxClsTarget = target ? new WeakRef(target) : undefined\n          maxClsStartTime = elapsed(viewStart, entry.startTime)\n        }\n\n        if (cumulatedValue > maxClsValue) {\n          maxClsValue = cumulatedValue\n          const target = maxClsTarget?.deref()\n\n          callback({\n            value: round(maxClsValue, 4),\n            targetSelector: target && getSelectorFromElement(target, configuration.actionNameAttribute),\n            time: maxClsStartTime,\n          })\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction getTargetFromSource(sources?: Array<{ node?: Node }>) {\n  if (!sources) {\n    return\n  }\n\n  return find(sources, (source): source is { node: HTMLElement } => !!source.node && isElementNode(source.node))?.node\n}\n\nexport const MAX_WINDOW_DURATION = 5 * ONE_SECOND\nconst MAX_UPDATE_GAP = ONE_SECOND\n\nfunction slidingSessionWindow() {\n  let cumulatedValue = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n  let maxValue = 0\n\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= MAX_UPDATE_GAP ||\n        entry.startTime - startTime >= MAX_WINDOW_DURATION\n\n      let isMaxValue: boolean\n\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        maxValue = cumulatedValue = entry.value\n        isMaxValue = true\n      } else {\n        cumulatedValue += entry.value\n        endTime = entry.startTime\n        isMaxValue = entry.value > maxValue\n\n        if (isMaxValue) {\n          maxValue = entry.value\n        }\n      }\n\n      return {\n        cumulatedValue,\n        isMaxValue,\n      }\n    },\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nexport function isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT)\n}\n","/**\n * performance.interactionCount polyfill\n *\n * The interactionCount is an integer which counts the total number of distinct user interactions,\n * for which there was a unique interactionId.\n *\n * The interactionCount polyfill is an estimate based on a convention specific to Chrome. Cf: https://github.com/GoogleChrome/web-vitals/pull/213\n * This is currently not an issue as the polyfill is only used for INP which is currently only supported on Chrome.\n * Hopefully when/if other browsers will support INP, they will also implement performance.interactionCount at the same time, so we won't need that polyfill.\n *\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/lib/polyfills/interactionCountPolyfill.ts\n */\n\nimport { monitor } from '@datadog/browser-core'\nimport type {\n  BrowserWindow,\n  RumPerformanceEventTiming,\n  RumPerformanceObserver,\n} from '../../../browser/performanceCollection'\n\nlet observer: RumPerformanceObserver | undefined\n\nlet interactionCountEstimate = 0\nlet minKnownInteractionId = Infinity\nlet maxKnownInteractionId = 0\n\nexport function initInteractionCountPolyfill() {\n  if ('interactionCount' in performance || observer) {\n    return\n  }\n\n  observer = new (window as BrowserWindow).PerformanceObserver(\n    monitor((entries: PerformanceObserverEntryList) => {\n      entries.getEntries().forEach((e) => {\n        const entry = e as unknown as RumPerformanceEventTiming\n\n        if (entry.interactionId) {\n          minKnownInteractionId = Math.min(minKnownInteractionId, entry.interactionId)\n          maxKnownInteractionId = Math.max(maxKnownInteractionId, entry.interactionId)\n\n          interactionCountEstimate = (maxKnownInteractionId - minKnownInteractionId) / 7 + 1\n        }\n      })\n    })\n  )\n\n  observer.observe({ type: 'event', buffered: true, durationThreshold: 0 })\n}\n\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nexport const getInteractionCount = () =>\n  observer ? interactionCountEstimate : (window as BrowserWindow).performance.interactionCount! || 0\n","import { Observable, throttle, addEventListener, DOM_EVENT } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\nexport interface ViewportDimension {\n  height: number\n  width: number\n}\n\nlet viewportObservable: Observable<ViewportDimension> | undefined\n\nexport function initViewportObservable(configuration: RumConfiguration) {\n  if (!viewportObservable) {\n    viewportObservable = createViewportObservable(configuration)\n  }\n  return viewportObservable\n}\n\nexport function createViewportObservable(configuration: RumConfiguration) {\n  return new Observable<ViewportDimension>((observable) => {\n    const { throttled: updateDimension } = throttle(() => {\n      observable.notify(getViewportDimension())\n    }, 200)\n\n    return addEventListener(configuration, window, DOM_EVENT.RESIZE, updateDimension, { capture: true, passive: true })\n      .stop\n  })\n}\n\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension(): ViewportDimension {\n  const visual = window.visualViewport\n  if (visual) {\n    return {\n      width: Number(visual.width * visual.scale),\n      height: Number(visual.height * visual.scale),\n    }\n  }\n\n  return {\n    width: Number(window.innerWidth || 0),\n    height: Number(window.innerHeight || 0),\n  }\n}\n","import { elapsed, noop, ONE_MINUTE } from '@datadog/browser-core'\nimport type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport type { RumFirstInputTiming, RumPerformanceEventTiming } from '../../../browser/performanceCollection'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport { getSelectorFromElement } from '../../getSelectorFromElement'\nimport { isElementNode } from '../../../browser/htmlDomUtils'\nimport type { RumConfiguration } from '../../configuration'\nimport { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill'\n\n// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.\nconst MAX_INTERACTION_ENTRIES = 10\n// Arbitrary value to cap INP outliers\nexport const MAX_INP_VALUE = (1 * ONE_MINUTE) as Duration\n\nexport interface InteractionToNextPaint {\n  value: Duration\n  targetSelector?: string\n  time?: Duration\n}\n/**\n * Track the interaction to next paint (INP).\n * To avoid outliers, return the p98 worst interaction of the view.\n * Documentation: https://web.dev/inp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts\n */\nexport function trackInteractionToNextPaint(\n  configuration: RumConfiguration,\n  viewStart: RelativeTime,\n  viewLoadingType: ViewLoadingType,\n  lifeCycle: LifeCycle\n) {\n  if (!isInteractionToNextPaintSupported()) {\n    return {\n      getInteractionToNextPaint: () => undefined,\n      setViewEnd: noop,\n      stop: noop,\n    }\n  }\n\n  const { getViewInteractionCount, stopViewInteractionCount } = trackViewInteractionCount(viewLoadingType)\n\n  let viewEnd = Infinity as RelativeTime\n\n  const longestInteractions = trackLongestInteractions(getViewInteractionCount)\n  let interactionToNextPaint = -1 as Duration\n  let interactionToNextPaintTargetSelector: string | undefined\n  let interactionToNextPaintStartTime: Duration | undefined\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (\n        (entry.entryType === RumPerformanceEntryType.EVENT ||\n          entry.entryType === RumPerformanceEntryType.FIRST_INPUT) &&\n        entry.interactionId &&\n        // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).\n        entry.startTime >= viewStart &&\n        entry.startTime <= viewEnd\n      ) {\n        longestInteractions.process(entry)\n      }\n    }\n\n    const newInteraction = longestInteractions.estimateP98Interaction()\n    if (newInteraction && newInteraction.duration !== interactionToNextPaint) {\n      interactionToNextPaint = newInteraction.duration\n      interactionToNextPaintStartTime = elapsed(viewStart, newInteraction.startTime)\n\n      if (newInteraction.target && isElementNode(newInteraction.target)) {\n        interactionToNextPaintTargetSelector = getSelectorFromElement(\n          newInteraction.target,\n          configuration.actionNameAttribute\n        )\n      } else {\n        interactionToNextPaintTargetSelector = undefined\n      }\n    }\n  })\n\n  return {\n    getInteractionToNextPaint: (): InteractionToNextPaint | undefined => {\n      // If no INP duration where captured because of the performanceObserver 40ms threshold\n      // but the view interaction count > 0 then report 0\n      if (interactionToNextPaint >= 0) {\n        return {\n          value: Math.min(interactionToNextPaint, MAX_INP_VALUE) as Duration,\n          targetSelector: interactionToNextPaintTargetSelector,\n          time: interactionToNextPaintStartTime,\n        }\n      } else if (getViewInteractionCount()) {\n        return {\n          value: 0 as Duration,\n        }\n      }\n    },\n    setViewEnd: (viewEndTime: RelativeTime) => {\n      viewEnd = viewEndTime\n      stopViewInteractionCount()\n    },\n    stop,\n  }\n}\n\nfunction trackLongestInteractions(getViewInteractionCount: () => number) {\n  const longestInteractions: Array<RumPerformanceEventTiming | RumFirstInputTiming> = []\n\n  function sortAndTrimLongestInteractions() {\n    longestInteractions.sort((a, b) => b.duration - a.duration).splice(MAX_INTERACTION_ENTRIES)\n  }\n\n  return {\n    /**\n     * Process the performance entry:\n     * - if its duration is long enough, add the performance entry to the list of worst interactions\n     * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions\n     */\n    process(entry: RumPerformanceEventTiming | RumFirstInputTiming) {\n      const interactionIndex = longestInteractions.findIndex(\n        (interaction) => entry.interactionId === interaction.interactionId\n      )\n\n      const minLongestInteraction = longestInteractions[longestInteractions.length - 1]\n\n      if (interactionIndex !== -1) {\n        if (entry.duration > longestInteractions[interactionIndex].duration) {\n          longestInteractions[interactionIndex] = entry\n          sortAndTrimLongestInteractions()\n        }\n      } else if (\n        longestInteractions.length < MAX_INTERACTION_ENTRIES ||\n        entry.duration > minLongestInteraction.duration\n      ) {\n        longestInteractions.push(entry)\n        sortAndTrimLongestInteractions()\n      }\n    },\n    /**\n     * Compute the p98 longest interaction.\n     * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.\n     */\n    estimateP98Interaction(): RumPerformanceEventTiming | RumFirstInputTiming | undefined {\n      const interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50))\n      return longestInteractions[interactionIndex]\n    },\n  }\n}\n\nexport function trackViewInteractionCount(viewLoadingType: ViewLoadingType) {\n  initInteractionCountPolyfill()\n  const previousInteractionCount = viewLoadingType === ViewLoadingType.INITIAL_LOAD ? 0 : getInteractionCount()\n  let state: { stopped: false } | { stopped: true; interactionCount: number } = { stopped: false }\n\n  function computeViewInteractionCount() {\n    return getInteractionCount() - previousInteractionCount\n  }\n\n  return {\n    getViewInteractionCount: () => {\n      if (state.stopped) {\n        return state.interactionCount\n      }\n\n      return computeViewInteractionCount()\n    },\n    stopViewInteractionCount: () => {\n      state = { stopped: true, interactionCount: computeViewInteractionCount() }\n    },\n  }\n}\n\nexport function isInteractionToNextPaintSupported() {\n  return (\n    supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) &&\n    window.PerformanceEventTiming &&\n    'interactionId' in PerformanceEventTiming.prototype\n  )\n}\n","export function getScrollX() {\n  let scrollX\n  const visual = window.visualViewport\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX\n  } else {\n    scrollX = window.pageXOffset || 0\n  }\n  return Math.round(scrollX)\n}\n\nexport function getScrollY() {\n  let scrollY\n  const visual = window.visualViewport\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY\n  } else {\n    scrollY = window.pageYOffset || 0\n  }\n  return Math.round(scrollY)\n}\n","import type { ClocksState, Duration } from '@datadog/browser-core'\nimport {\n  Observable,\n  ONE_SECOND,\n  elapsed,\n  relativeNow,\n  throttle,\n  addEventListener,\n  DOM_EVENT,\n  monitor,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport { getScrollY } from '../../../browser/scroll'\nimport { getViewportDimension } from '../../../browser/viewportObservable'\n\n/** Arbitrary scroll throttle duration */\nexport const THROTTLE_SCROLL_DURATION = ONE_SECOND\n\nexport interface ScrollMetrics {\n  maxDepth: number\n  maxScrollHeight: number\n  maxDepthScrollTop: number\n  maxScrollHeightTime: Duration\n}\n\nexport function trackScrollMetrics(\n  configuration: RumConfiguration,\n  viewStart: ClocksState,\n  callback: (scrollMetrics: ScrollMetrics) => void,\n  scrollValues = createScrollValuesObservable(configuration)\n) {\n  let maxScrollDepth = 0\n  let maxScrollHeight = 0\n  let maxScrollHeightTime = 0 as Duration\n\n  const subscription = scrollValues.subscribe(({ scrollDepth, scrollTop, scrollHeight }) => {\n    let shouldUpdate = false\n\n    if (scrollDepth > maxScrollDepth) {\n      maxScrollDepth = scrollDepth\n      shouldUpdate = true\n    }\n\n    if (scrollHeight > maxScrollHeight) {\n      maxScrollHeight = scrollHeight\n      const now = relativeNow()\n      maxScrollHeightTime = elapsed(viewStart.relative, now)\n      shouldUpdate = true\n    }\n\n    if (shouldUpdate) {\n      callback({\n        maxDepth: Math.min(maxScrollDepth, maxScrollHeight),\n        maxDepthScrollTop: scrollTop,\n        maxScrollHeight,\n        maxScrollHeightTime,\n      })\n    }\n  })\n\n  return {\n    stop: () => subscription.unsubscribe(),\n  }\n}\n\nexport interface ScrollValues {\n  scrollDepth: number\n  scrollTop: number\n  scrollHeight: number\n}\n\nexport function computeScrollValues() {\n  const scrollTop = getScrollY()\n\n  const { height } = getViewportDimension()\n\n  const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight)\n\n  const scrollDepth = Math.round(height + scrollTop)\n\n  return {\n    scrollHeight,\n    scrollDepth,\n    scrollTop,\n  }\n}\n\nexport function createScrollValuesObservable(\n  configuration: RumConfiguration,\n  throttleDuration = THROTTLE_SCROLL_DURATION\n): Observable<ScrollValues> {\n  return new Observable<ScrollValues>((observable) => {\n    function notify() {\n      observable.notify(computeScrollValues())\n    }\n\n    if (window.ResizeObserver) {\n      const throttledNotify = throttle(notify, throttleDuration, {\n        leading: false,\n        trailing: true,\n      })\n\n      const observerTarget = document.scrollingElement || document.documentElement\n      const resizeObserver = new ResizeObserver(monitor(throttledNotify.throttled))\n      resizeObserver.observe(observerTarget)\n      const eventListener = addEventListener(configuration, window, DOM_EVENT.SCROLL, throttledNotify.throttled, {\n        passive: true,\n      })\n\n      return () => {\n        throttledNotify.cancel()\n        resizeObserver.unobserve(observerTarget)\n        eventListener.stop()\n      }\n    }\n  })\n}\n","import type { ClocksState, Duration, Observable } from '@datadog/browser-core'\nimport type { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport type { CumulativeLayoutShift } from './trackCumulativeLayoutShift'\nimport { trackCumulativeLayoutShift } from './trackCumulativeLayoutShift'\nimport type { InteractionToNextPaint } from './trackInteractionToNextPaint'\nimport { trackInteractionToNextPaint } from './trackInteractionToNextPaint'\nimport { trackLoadingTime } from './trackLoadingTime'\nimport type { ScrollMetrics } from './trackScrollMetrics'\nimport { trackScrollMetrics } from './trackScrollMetrics'\n\nexport interface CommonViewMetrics {\n  loadingTime?: Duration\n  cumulativeLayoutShift?: CumulativeLayoutShift\n  interactionToNextPaint?: InteractionToNextPaint\n  scroll?: ScrollMetrics\n}\n\nexport function trackCommonViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState\n) {\n  const commonViewMetrics: CommonViewMetrics = {}\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      commonViewMetrics.loadingTime = newLoadingTime\n      scheduleViewUpdate()\n    }\n  )\n\n  const { stop: stopScrollMetricsTracking } = trackScrollMetrics(configuration, viewStart, (newScrollMetrics) => {\n    commonViewMetrics.scroll = newScrollMetrics\n  })\n\n  const { stop: stopCLSTracking } = trackCumulativeLayoutShift(\n    configuration,\n    lifeCycle,\n    viewStart.relative,\n    (cumulativeLayoutShift) => {\n      commonViewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n      scheduleViewUpdate()\n    }\n  )\n\n  const {\n    stop: stopINPTracking,\n    getInteractionToNextPaint,\n    setViewEnd,\n  } = trackInteractionToNextPaint(configuration, viewStart.relative, loadingType, lifeCycle)\n\n  return {\n    stop: () => {\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n      stopScrollMetricsTracking()\n    },\n    stopINPTracking,\n    setLoadEvent,\n    setViewEnd,\n    getCommonViewMetrics: () => {\n      commonViewMetrics.interactionToNextPaint = getInteractionToNextPaint()\n      return commonViewMetrics\n    },\n  }\n}\n","import type { ClocksState, Duration, Observable } from '@datadog/browser-core'\nimport { elapsed } from '@datadog/browser-core'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\n\nexport function trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max(...loadingTimeCandidates) as Duration)\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, (event) => {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n      }\n      invokeCallbackIfAllCandidatesAreReceived()\n    }\n  })\n\n  return {\n    stop,\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n","import type { Duration, ClocksState, TimeStamp, Subscription, RelativeTime } from '@datadog/browser-core'\nimport {\n  noop,\n  PageExitReason,\n  shallowClone,\n  elapsed,\n  generateUUID,\n  ONE_MINUTE,\n  throttle,\n  clocksNow,\n  clocksOrigin,\n  timeStampNow,\n  display,\n  looksLikeRelativeTime,\n  setInterval,\n  clearInterval,\n  setTimeout,\n  Observable,\n} from '@datadog/browser-core'\n\nimport type { ViewCustomTimings } from '../../rawRumEvent.types'\nimport { ViewLoadingType } from '../../rawRumEvent.types'\n\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { EventCounts } from '../trackEventCounts'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { RumConfiguration, RumInitConfiguration } from '../configuration'\nimport { trackViewEventCounts } from './trackViewEventCounts'\nimport { trackInitialViewMetrics } from './viewMetrics/trackInitialViewMetrics'\nimport type { InitialViewMetrics } from './viewMetrics/trackInitialViewMetrics'\nimport type { CommonViewMetrics } from './viewMetrics/trackCommonViewMetrics'\nimport { trackCommonViewMetrics } from './viewMetrics/trackCommonViewMetrics'\n\nexport interface ViewEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  location: Readonly<Location>\n  commonViewMetrics: CommonViewMetrics\n  initialViewMetrics: InitialViewMetrics\n  customTimings: ViewCustomTimings\n  eventCounts: EventCounts\n  documentVersion: number\n  startClocks: ClocksState\n  duration: Duration\n  isActive: boolean\n  sessionIsActive: boolean\n  loadingType: ViewLoadingType\n}\n\nexport interface ViewCreatedEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewEndedEvent {\n  endClocks: ClocksState\n}\n\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE\n\n// Some events or metrics can be captured after the end of the view. To avoid missing those;\n// an arbitrary delay is added for stopping their tracking after the view ends.\n//\n// Ideally, we would not stop and keep tracking events or metrics until the end of the session.\n// But this might have a small performance impact if there are many many views.\n// So let's have a fairly short delay improving the situation in most cases and avoid impacting performances too much.\nexport const KEEP_TRACKING_AFTER_VIEW_DELAY = 5 * ONE_MINUTE\n\nexport interface ViewOptions {\n  name?: string\n  service?: RumInitConfiguration['service']\n  version?: RumInitConfiguration['version']\n}\n\nexport function trackViews(\n  location: Location,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  locationChangeObservable: Observable<LocationChange>,\n  areViewsTrackedAutomatically: boolean,\n  initialViewOptions?: ViewOptions\n) {\n  const activeViews: Set<ReturnType<typeof newView>> = new Set()\n  let currentView = startNewView(ViewLoadingType.INITIAL_LOAD, clocksOrigin(), initialViewOptions)\n\n  startViewLifeCycle()\n\n  let locationChangeSubscription: Subscription\n  if (areViewsTrackedAutomatically) {\n    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable)\n  }\n\n  function startNewView(loadingType: ViewLoadingType, startClocks?: ClocksState, viewOptions?: ViewOptions) {\n    const newlyCreatedView = newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      loadingType,\n      startClocks,\n      viewOptions\n    )\n    activeViews.add(newlyCreatedView)\n    newlyCreatedView.stopObservable.subscribe(() => {\n      activeViews.delete(newlyCreatedView)\n    })\n    return newlyCreatedView\n  }\n\n  function startViewLifeCycle() {\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n      // Renew view on session renewal\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, undefined, {\n        name: currentView.name,\n        service: currentView.service,\n        version: currentView.version,\n      })\n    })\n\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n      currentView.end({ sessionIsActive: false })\n    })\n\n    // End the current view on page unload\n    lifeCycle.subscribe(LifeCycleEventType.PAGE_EXITED, (pageExitEvent) => {\n      if (pageExitEvent.reason === PageExitReason.UNLOADING) {\n        currentView.end()\n      }\n    })\n  }\n\n  function renewViewOnLocationChange(locationChangeObservable: Observable<LocationChange>) {\n    return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n      if (areDifferentLocation(oldLocation, newLocation)) {\n        currentView.end()\n        currentView = startNewView(ViewLoadingType.ROUTE_CHANGE)\n      }\n    })\n  }\n\n  return {\n    addTiming: (name: string, time: RelativeTime | TimeStamp = timeStampNow()) => {\n      currentView.addTiming(name, time)\n    },\n    startView: (options?: ViewOptions, startClocks?: ClocksState) => {\n      currentView.end({ endClocks: startClocks })\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, startClocks, options)\n    },\n    stop: () => {\n      locationChangeSubscription?.unsubscribe()\n      currentView.end()\n      activeViews.forEach((view) => view.stop())\n    },\n  }\n}\n\nfunction newView(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  initialLocation: Location,\n  loadingType: ViewLoadingType,\n  startClocks: ClocksState = clocksNow(),\n  viewOptions?: ViewOptions\n) {\n  // Setup initial values\n  const id = generateUUID()\n  const stopObservable = new Observable<void>()\n  const customTimings: ViewCustomTimings = {}\n  let documentVersion = 0\n  let endClocks: ClocksState | undefined\n  const location = shallowClone(initialLocation)\n\n  let sessionIsActive = true\n  let name: string | undefined\n  let service: string | undefined\n  let version: string | undefined\n  if (viewOptions) {\n    name = viewOptions.name\n    service = viewOptions.service || undefined\n    version = viewOptions.version || undefined\n  }\n\n  const viewCreatedEvent = {\n    id,\n    name,\n    startClocks,\n    service,\n    version,\n  }\n  lifeCycle.notify(LifeCycleEventType.BEFORE_VIEW_CREATED, viewCreatedEvent)\n  lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, viewCreatedEvent)\n\n  // Update the view every time the measures are changing\n  const { throttled: scheduleViewUpdate, cancel: cancelScheduleViewUpdate } = throttle(\n    triggerViewUpdate,\n    THROTTLE_VIEW_UPDATE_PERIOD,\n    {\n      leading: false,\n    }\n  )\n\n  const {\n    setLoadEvent,\n    setViewEnd,\n    stop: stopCommonViewMetricsTracking,\n    stopINPTracking,\n    getCommonViewMetrics,\n  } = trackCommonViewMetrics(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    scheduleViewUpdate,\n    loadingType,\n    startClocks\n  )\n\n  const { stop: stopInitialViewMetricsTracking, initialViewMetrics } =\n    loadingType === ViewLoadingType.INITIAL_LOAD\n      ? trackInitialViewMetrics(lifeCycle, configuration, setLoadEvent, scheduleViewUpdate)\n      : { stop: noop, initialViewMetrics: {} as InitialViewMetrics }\n\n  const { stop: stopEventCountsTracking, eventCounts } = trackViewEventCounts(lifeCycle, id, scheduleViewUpdate)\n\n  // Session keep alive\n  const keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL)\n\n  // Initial view update\n  triggerViewUpdate()\n\n  function triggerViewUpdate() {\n    cancelScheduleViewUpdate()\n    documentVersion += 1\n    const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp\n\n    lifeCycle.notify(LifeCycleEventType.VIEW_UPDATED, {\n      customTimings,\n      documentVersion,\n      id,\n      name,\n      service,\n      version,\n      loadingType,\n      location,\n      startClocks,\n      commonViewMetrics: getCommonViewMetrics(),\n      initialViewMetrics,\n      duration: elapsed(startClocks.timeStamp, currentEnd),\n      isActive: endClocks === undefined,\n      sessionIsActive,\n      eventCounts,\n    })\n  }\n\n  return {\n    name,\n    service,\n    version,\n    stopObservable,\n    end(options: { endClocks?: ClocksState; sessionIsActive?: boolean } = {}) {\n      if (endClocks) {\n        // view already ended\n        return\n      }\n      endClocks = options.endClocks ?? clocksNow()\n      sessionIsActive = options.sessionIsActive ?? true\n\n      lifeCycle.notify(LifeCycleEventType.VIEW_ENDED, { endClocks })\n      lifeCycle.notify(LifeCycleEventType.AFTER_VIEW_ENDED, { endClocks })\n      clearInterval(keepAliveIntervalId)\n      setViewEnd(endClocks.relative)\n      stopCommonViewMetricsTracking()\n      triggerViewUpdate()\n      setTimeout(() => {\n        this.stop()\n      }, KEEP_TRACKING_AFTER_VIEW_DELAY)\n    },\n    stop() {\n      stopInitialViewMetricsTracking()\n      stopEventCountsTracking()\n      stopINPTracking()\n      stopObservable.notify()\n    },\n    addTiming(name: string, time: RelativeTime | TimeStamp) {\n      if (endClocks) {\n        return\n      }\n      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time)\n      customTimings[sanitizeTiming(name)] = relativeTime\n      scheduleViewUpdate()\n    },\n  }\n}\n\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name: string) {\n  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_')\n  if (sanitized !== name) {\n    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`)\n  }\n  return sanitized\n}\n\nfunction areDifferentLocation(currentLocation: Location, otherLocation: Location) {\n  return (\n    currentLocation.pathname !== otherLocation.pathname ||\n    (!isHashAnAnchor(otherLocation.hash) &&\n      getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash))\n  )\n}\n\nfunction isHashAnAnchor(hash: string) {\n  const correspondingId = hash.substring(1)\n  // check if the correspondingId is empty because on Firefox an empty string passed to getElementById() prints a consol warning\n  return correspondingId !== '' && !!document.getElementById(correspondingId)\n}\n\nfunction getPathFromHash(hash: string) {\n  const index = hash.indexOf('?')\n  return index < 0 ? hash : hash.slice(0, index)\n}\n","import type { LifeCycle } from '../lifeCycle'\nimport { trackEventCounts } from '../trackEventCounts'\n\nexport function trackViewEventCounts(lifeCycle: LifeCycle, viewId: string, onChange: () => void) {\n  const { stop, eventCounts } = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) => event.view.id === viewId,\n    onChange,\n  })\n\n  return {\n    stop,\n    eventCounts,\n  }\n}\n","import type { Duration, ServerDuration, Observable } from '@datadog/browser-core'\nimport { isEmptyObject, mapValues, toServerDuration } from '@datadog/browser-core'\nimport { discardNegativeDuration } from '../discardNegativeDuration'\nimport type { RecorderApi } from '../../boot/rumPublicApi'\nimport type { RawRumViewEvent } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../configuration'\nimport type { FeatureFlagContexts } from '../contexts/featureFlagContext'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport type { ViewEvent, ViewOptions } from './trackViews'\nimport { trackViews } from './trackViews'\n\nexport function startViewCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  domMutationObservable: Observable<void>,\n  locationChangeObservable: Observable<LocationChange>,\n  featureFlagContexts: FeatureFlagContexts,\n  pageStateHistory: PageStateHistory,\n  recorderApi: RecorderApi,\n  initialViewOptions?: ViewOptions\n) {\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, (view) =>\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processViewUpdate(view, configuration, featureFlagContexts, recorderApi, pageStateHistory)\n    )\n  )\n  return trackViews(\n    location,\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    locationChangeObservable,\n    !configuration.trackViewsManually,\n    initialViewOptions\n  )\n}\n\nfunction processViewUpdate(\n  view: ViewEvent,\n  configuration: RumConfiguration,\n  featureFlagContexts: FeatureFlagContexts,\n  recorderApi: RecorderApi,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumViewEvent> {\n  const replayStats = recorderApi.getReplayStats(view.id)\n  const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(view.startClocks.relative)\n  const pageStates = pageStateHistory.findAll(view.startClocks.relative, view.duration)\n  const viewEvent: RawRumViewEvent = {\n    _dd: {\n      document_version: view.documentVersion,\n      replay_stats: replayStats,\n      page_states: pageStates,\n      configuration: {\n        start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n      },\n    },\n    date: view.startClocks.timeStamp,\n    type: RumEventType.VIEW,\n    view: {\n      action: {\n        count: view.eventCounts.actionCount,\n      },\n      frustration: {\n        count: view.eventCounts.frustrationCount,\n      },\n      cumulative_layout_shift: view.commonViewMetrics.cumulativeLayoutShift?.value,\n      cumulative_layout_shift_time: toServerDuration(view.commonViewMetrics.cumulativeLayoutShift?.time),\n      cumulative_layout_shift_target_selector: view.commonViewMetrics.cumulativeLayoutShift?.targetSelector,\n      first_byte: toServerDuration(view.initialViewMetrics.navigationTimings?.firstByte),\n      dom_complete: toServerDuration(view.initialViewMetrics.navigationTimings?.domComplete),\n      dom_content_loaded: toServerDuration(view.initialViewMetrics.navigationTimings?.domContentLoaded),\n      dom_interactive: toServerDuration(view.initialViewMetrics.navigationTimings?.domInteractive),\n      error: {\n        count: view.eventCounts.errorCount,\n      },\n      first_contentful_paint: toServerDuration(view.initialViewMetrics.firstContentfulPaint),\n      first_input_delay: toServerDuration(view.initialViewMetrics.firstInput?.delay),\n      first_input_time: toServerDuration(view.initialViewMetrics.firstInput?.time),\n      first_input_target_selector: view.initialViewMetrics.firstInput?.targetSelector,\n      interaction_to_next_paint: toServerDuration(view.commonViewMetrics.interactionToNextPaint?.value),\n      interaction_to_next_paint_time: toServerDuration(view.commonViewMetrics.interactionToNextPaint?.time),\n      interaction_to_next_paint_target_selector: view.commonViewMetrics.interactionToNextPaint?.targetSelector,\n      is_active: view.isActive,\n      name: view.name,\n      largest_contentful_paint: toServerDuration(view.initialViewMetrics.largestContentfulPaint?.value),\n      largest_contentful_paint_target_selector: view.initialViewMetrics.largestContentfulPaint?.targetSelector,\n      load_event: toServerDuration(view.initialViewMetrics.navigationTimings?.loadEvent),\n      loading_time: discardNegativeDuration(toServerDuration(view.commonViewMetrics.loadingTime)),\n      loading_type: view.loadingType,\n      long_task: {\n        count: view.eventCounts.longTaskCount,\n      },\n      resource: {\n        count: view.eventCounts.resourceCount,\n      },\n      time_spent: toServerDuration(view.duration),\n    },\n    feature_flags: featureFlagContext && !isEmptyObject(featureFlagContext) ? featureFlagContext : undefined,\n    display: view.commonViewMetrics.scroll\n      ? {\n          scroll: {\n            max_depth: view.commonViewMetrics.scroll.maxDepth,\n            max_depth_scroll_top: view.commonViewMetrics.scroll.maxDepthScrollTop,\n            max_scroll_height: view.commonViewMetrics.scroll.maxScrollHeight,\n            max_scroll_height_time: toServerDuration(view.commonViewMetrics.scroll.maxScrollHeightTime),\n          },\n        }\n      : undefined,\n    session: {\n      has_replay: replayStats ? true : undefined,\n      is_active: view.sessionIsActive ? undefined : false,\n    },\n    privacy: {\n      replay_level: configuration.defaultPrivacyLevel,\n    },\n  }\n  if (!isEmptyObject(view.customTimings)) {\n    viewEvent.view.custom_timings = mapValues(\n      view.customTimings,\n      toServerDuration as (duration: Duration) => ServerDuration\n    )\n  }\n  return {\n    rawRumEvent: viewEvent,\n    startTime: view.startClocks.relative,\n    domainContext: {\n      location: view.location,\n    },\n  }\n}\n","import { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { ValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport type { Configuration } from '../configuration'\nimport type { TrackingConsentState } from '../trackingConsent'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\nimport type { SessionState } from './sessionState'\n\nexport interface SessionManager<TrackingType extends string> {\n  findSession: (\n    startTime?: RelativeTime,\n    options?: { returnInactive: boolean }\n  ) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  sessionStateUpdateObservable: Observable<{ previousState: SessionState; newState: SessionState }>\n  expire: () => void\n  updateSessionState: (state: Partial<SessionState>) => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n  isReplayForced: boolean\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  configuration: Configuration,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean },\n  trackingConsentState: TrackingConsentState\n): SessionManager<TrackingType> {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  // TODO - Improve configuration type and remove assertion\n  const sessionStore = startSessionStore(configuration.sessionStoreStrategyType!, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ValueHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n    renewObservable.notify()\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    expireObservable.notify()\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  // We expand/renew session unconditionally as tracking consent is always granted when the session\n  // manager is started.\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackingConsentState.observable.subscribe(() => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    } else {\n      sessionStore.expire()\n    }\n  })\n\n  trackActivity(configuration, () => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    }\n  })\n  trackVisibility(configuration, () => sessionStore.expandSession())\n  trackResume(configuration, () => sessionStore.restartSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n      isReplayForced: !!sessionStore.getSession().forcedReplay,\n    }\n  }\n\n  return {\n    findSession: (startTime, options) => sessionContextHistory.find(startTime, options),\n    renewObservable,\n    expireObservable,\n    sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n    expire: sessionStore.expire,\n    updateSessionState: sessionStore.updateSessionState,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(configuration: Configuration, expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(configuration: Configuration, expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n\nfunction trackResume(configuration: Configuration, cb: () => void) {\n  const { stop } = addEventListener(configuration, window, DOM_EVENT.RESUME, cb, { capture: true })\n  stopCallbacks.push(stop)\n}\n","import type { RelativeTime, TrackingConsentState } from '@datadog/browser-core'\nimport {\n  BridgeCapability,\n  Observable,\n  bridgeSupports,\n  noop,\n  performDraw,\n  startSessionManager,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const RUM_SESSION_KEY = 'rum'\n\nexport interface RumSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => RumSession | undefined\n  expire: () => void\n  expireObservable: Observable<void>\n  setForcedReplay: () => void\n}\n\nexport type RumSession = {\n  id: string\n  sessionReplay: SessionReplayState\n}\n\nexport const enum RumTrackingType {\n  NOT_TRACKED = '0',\n  TRACKED_WITH_SESSION_REPLAY = '1',\n  TRACKED_WITHOUT_SESSION_REPLAY = '2',\n}\n\nexport const enum SessionReplayState {\n  OFF,\n  SAMPLED,\n  FORCED,\n}\n\nexport function startRumSessionManager(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  trackingConsentState: TrackingConsentState\n): RumSessionManager {\n  const sessionManager = startSessionManager(\n    configuration,\n    RUM_SESSION_KEY,\n    (rawTrackingType) => computeSessionState(configuration, rawTrackingType),\n    trackingConsentState\n  )\n\n  sessionManager.expireObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_EXPIRED)\n  })\n\n  sessionManager.renewObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_RENEWED)\n  })\n\n  sessionManager.sessionStateUpdateObservable.subscribe(({ previousState, newState }) => {\n    if (!previousState.forcedReplay && newState.forcedReplay) {\n      const sessionEntity = sessionManager.findSession()\n      if (sessionEntity) {\n        sessionEntity.isReplayForced = true\n      }\n    }\n  })\n\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findSession(startTime)\n      if (!session || !isTypeTracked(session.trackingType)) {\n        return\n      }\n      return {\n        id: session.id,\n        sessionReplay:\n          session.trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n            ? SessionReplayState.SAMPLED\n            : session.isReplayForced\n              ? SessionReplayState.FORCED\n              : SessionReplayState.OFF,\n      }\n    },\n    expire: sessionManager.expire,\n    expireObservable: sessionManager.expireObservable,\n    setForcedReplay: () => sessionManager.updateSessionState({ forcedReplay: '1' }),\n  }\n}\n\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub(): RumSessionManager {\n  const session: RumSession = {\n    id: '00000000-aaaa-0000-aaaa-000000000000',\n    sessionReplay: bridgeSupports(BridgeCapability.RECORDS) ? SessionReplayState.SAMPLED : SessionReplayState.OFF,\n  }\n  return {\n    findTrackedSession: () => session,\n    expire: noop,\n    expireObservable: new Observable(),\n    setForcedReplay: noop,\n  }\n}\n\nfunction computeSessionState(configuration: RumConfiguration, rawTrackingType?: string) {\n  let trackingType: RumTrackingType\n  if (hasValidRumSession(rawTrackingType)) {\n    trackingType = rawTrackingType\n  } else if (!performDraw(configuration.sessionSampleRate)) {\n    trackingType = RumTrackingType.NOT_TRACKED\n  } else if (!performDraw(configuration.sessionReplaySampleRate)) {\n    trackingType = RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  } else {\n    trackingType = RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  }\n  return {\n    trackingType,\n    isTracked: isTypeTracked(trackingType),\n  }\n}\n\nfunction hasValidRumSession(trackingType?: string): trackingType is RumTrackingType {\n  return (\n    trackingType === RumTrackingType.NOT_TRACKED ||\n    trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY ||\n    trackingType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  )\n}\n\nfunction isTypeTracked(rumSessionType: RumTrackingType | undefined) {\n  return (\n    rumSessionType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY ||\n    rumSessionType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  )\n}\n","import { DOCS_ORIGIN, display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageExitObservable'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { Subscription } from '../tools/observable'\nimport type { Encoder, EncoderResult } from '../tools/encoder'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport type { HttpRequest, Payload } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport class Batch {\n  private upsertBuffer: { [key: string]: string } = {}\n  private flushSubscription: Subscription\n\n  constructor(\n    private encoder: Encoder,\n    private request: HttpRequest,\n    public flushController: FlushController,\n    private messageBytesLimit: number\n  ) {\n    this.flushSubscription = this.flushController.flushObservable.subscribe((event) => this.flush(event))\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  stop() {\n    this.flushSubscription.unsubscribe()\n  }\n\n  private flush(event: FlushEvent) {\n    const upsertMessages = objectValues(this.upsertBuffer).join('\\n')\n    this.upsertBuffer = {}\n\n    const isPageExit = isPageExitReason(event.reason)\n    const send = isPageExit ? this.request.sendOnExit : this.request.send\n\n    if (\n      isPageExit &&\n      // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n      // if the encoder is async we need to send two requests in some cases (one for encoded data\n      // and the other for non-encoded data). But if it's not async, we don't have to worry about\n      // it and always send a single request.\n      this.encoder.isAsync\n    ) {\n      const encoderResult = this.encoder.finishSync()\n\n      // Send encoded messages\n      if (encoderResult.outputBytesCount) {\n        send(formatPayloadFromEncoder(encoderResult))\n      }\n\n      // Send messages that are not yet encoded at this point\n      const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n')\n      if (pendingMessages) {\n        send({\n          data: pendingMessages,\n          bytesCount: computeBytesCount(pendingMessages),\n        })\n      }\n    } else {\n      if (upsertMessages) {\n        this.encoder.write(this.encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`)\n      }\n      this.encoder.finish((encoderResult) => {\n        send(formatPayloadFromEncoder(encoderResult))\n      })\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const serializedMessage = jsonStringify(message)!\n\n    const estimatedMessageBytesCount = this.encoder.estimateEncodedBytesCount(serializedMessage)\n\n    if (estimatedMessageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB. More details: ${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting/#technical-limitations`\n      )\n      return\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n\n    this.push(serializedMessage, estimatedMessageBytesCount, key)\n  }\n\n  private push(serializedMessage: string, estimatedMessageBytesCount: number, key?: string) {\n    this.flushController.notifyBeforeAddMessage(estimatedMessageBytesCount)\n\n    if (key !== undefined) {\n      this.upsertBuffer[key] = serializedMessage\n      this.flushController.notifyAfterAddMessage()\n    } else {\n      this.encoder.write(\n        this.encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`,\n        (realMessageBytesCount) => {\n          this.flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount)\n        }\n      )\n    }\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = this.encoder.estimateEncodedBytesCount(removedMessage)\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount)\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n}\n\nfunction formatPayloadFromEncoder(encoderResult: EncoderResult): Payload {\n  let data: string | Blob\n  if (typeof encoderResult.output === 'string') {\n    data = encoderResult.output\n  } else {\n    data = new Blob([encoderResult.output], {\n      // This will set the 'Content-Type: text/plain' header. Reasoning:\n      // * The intake rejects the request if there is no content type.\n      // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n      // could induce higher intake load (and maybe has other impacts).\n      // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n      // new lines.\n      type: 'text/plain',\n    })\n  }\n\n  return {\n    data,\n    bytesCount: encoderResult.outputBytesCount,\n    encoding: encoderResult.encoding,\n  }\n}\n","import type { TrackType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, trackType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, trackType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, trackType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder, Configuration } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor } from '../tools/monitor'\nimport { addEventListener } from '../browser/addEventListener'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData | Blob\n  bytesCount: number\n  retry?: RetryInfo\n  encoding?: 'deflate'\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload\n) {\n  const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', payload)\n      const isQueued = navigator.sendBeacon(beaconUrl, payload.data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  const xhrUrl = endpointBuilder.build('xhr', payload)\n  sendXHR(configuration, xhrUrl, payload.data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch', payload)\n    fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })),\n      monitor(() => {\n        const xhrUrl = endpointBuilder.build('xhr', payload)\n        // failed to queue the request\n        sendXHR(configuration, xhrUrl, payload.data, onResponse)\n      })\n    )\n  } else {\n    const xhrUrl = endpointBuilder.build('xhr', payload)\n    sendXHR(configuration, xhrUrl, payload.data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(\n  configuration: Configuration,\n  url: string,\n  data: Payload['data'],\n  onResponse?: (r: HttpResponse) => void\n) {\n  const request = new XMLHttpRequest()\n  request.open('POST', url, true)\n  if (data instanceof Blob) {\n    // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n    // automatically, so the intake request ends up being rejected with an HTTP status 415\n    // Defining the header manually fixes this issue.\n    request.setRequestHeader('Content-Type', data.type)\n  }\n  addEventListener(\n    configuration,\n    request,\n    'loadend',\n    () => {\n      onResponse?.({ status: request.status })\n    },\n    {\n      // prevent multiple onResponse callbacks\n      // if the xhr instance is reused by a third party\n      once: true,\n    }\n  )\n  request.send(data)\n}\n","import type { PageExitEvent, PageExitReason } from '../browser/pageExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageExitObservable: Observable<PageExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const pageExitSubscription = pageExitObservable.subscribe((event) => flush(event.reason))\n  const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  const flushObservable = new Observable<FlushEvent>(() => () => {\n    pageExitSubscription.unsubscribe()\n    sessionExpireSubscription.unsubscribe()\n  })\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     *\n     * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n     * actually added.\n     */\n    notifyBeforeAddMessage(estimatedMessageBytesCount: number) {\n      if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += estimatedMessageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     *\n     * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n     * its actual bytes count once added to the pool.\n     */\n    notifyAfterAddMessage(messageBytesCountDiff = 0) {\n      currentBytesCount += messageBytesCountDiff\n\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     *\n     * @param messageBytesCount: the message bytes count that was added to the pool. Should\n     * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n     * `notifyAfterAddMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n","import type { Context, TelemetryEvent, Observable, RawError, PageExitEvent, Encoder } from '@datadog/browser-core'\nimport {\n  DeflateEncoderStreamId,\n  combine,\n  isTelemetryReplicationAllowed,\n  startBatchWithReplica,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  telemetryEventObservable: Observable<TelemetryEvent & Context>,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder\n) {\n  const replica = configuration.replica\n\n  const batch = startBatchWithReplica(\n    configuration,\n    {\n      endpoint: configuration.rumEndpointBuilder,\n      encoder: createEncoder(DeflateEncoderStreamId.RUM),\n    },\n    replica && {\n      endpoint: replica.rumEndpointBuilder,\n      transformMessage: (message) => combine(message, { application: { id: replica.applicationId } }),\n      encoder: createEncoder(DeflateEncoderStreamId.RUM_REPLICA),\n    },\n    reportError,\n    pageExitObservable,\n    sessionExpireObservable\n  )\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    if (serverRumEvent.type === RumEventType.VIEW) {\n      batch.upsert(serverRumEvent, serverRumEvent.view.id)\n    } else {\n      batch.add(serverRumEvent)\n    }\n  })\n\n  telemetryEventObservable.subscribe((event) => batch.add(event, isTelemetryReplicationAllowed(configuration)))\n\n  return batch\n}\n","import type { Configuration, EndpointBuilder } from '../domain/configuration'\nimport type { Context } from '../tools/serialisation/context'\nimport type { Observable } from '../tools/observable'\nimport type { PageExitEvent } from '../browser/pageExitObservable'\nimport type { RawError } from '../domain/error/error.types'\nimport type { Encoder } from '../tools/encoder'\nimport { Batch } from './batch'\nimport { createHttpRequest } from './httpRequest'\nimport { createFlushController } from './flushController'\n\nexport interface BatchConfiguration {\n  endpoint: EndpointBuilder\n  encoder: Encoder\n}\n\ninterface ReplicaBatchConfiguration<T> extends BatchConfiguration {\n  transformMessage?: (message: T) => T\n}\n\nexport function startBatchWithReplica<T extends Context>(\n  configuration: Configuration,\n  primary: BatchConfiguration,\n  replica: ReplicaBatchConfiguration<T> | undefined,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const primaryBatch = createBatch(configuration, primary)\n  const replicaBatch = replica && createBatch(configuration, replica)\n\n  function createBatch(configuration: Configuration, { endpoint, encoder }: BatchConfiguration) {\n    return new Batch(\n      encoder,\n      createHttpRequest(configuration, endpoint, configuration.batchBytesLimit, reportError),\n      createFlushController({\n        messagesLimit: configuration.batchMessagesLimit,\n        bytesLimit: configuration.batchBytesLimit,\n        durationLimit: configuration.flushTimeout,\n        pageExitObservable,\n        sessionExpireObservable,\n      }),\n      configuration.messageBytesLimit\n    )\n  }\n\n  return {\n    flushObservable: primaryBatch.flushController.flushObservable,\n\n    add(message: T, replicated = true) {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message)\n      }\n    },\n\n    upsert: (message: T, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key)\n      }\n    },\n\n    stop: () => {\n      primaryBatch.stop()\n      replicaBatch?.stop()\n    },\n  }\n}\n","import type { RelativeTime, Observable } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, relativeNow, ValueHistory } from '@datadog/browser-core'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\n\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface UrlContext {\n  url: string\n  referrer: string\n}\n\nexport interface UrlContexts {\n  findUrl: (startTime?: RelativeTime) => UrlContext | undefined\n  stop: () => void\n}\n\nexport function startUrlContexts(\n  lifeCycle: LifeCycle,\n  locationChangeObservable: Observable<LocationChange>,\n  location: Location\n) {\n  const urlContextHistory = new ValueHistory<UrlContext>(URL_CONTEXT_TIME_OUT_DELAY)\n\n  let previousViewUrl: string | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_CREATED, ({ startClocks }) => {\n    const viewUrl = location.href\n    urlContextHistory.add(\n      buildUrlContext({\n        url: viewUrl,\n        referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n      }),\n      startClocks.relative\n    )\n    previousViewUrl = viewUrl\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.AFTER_VIEW_ENDED, ({ endClocks }) => {\n    urlContextHistory.closeActive(endClocks.relative)\n  })\n\n  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n    const current = urlContextHistory.find()\n    if (current) {\n      const changeTime = relativeNow()\n      urlContextHistory.closeActive(changeTime)\n      urlContextHistory.add(\n        buildUrlContext({\n          url: newLocation.href,\n          referrer: current.referrer,\n        }),\n        changeTime\n      )\n    }\n  })\n\n  function buildUrlContext({ url, referrer }: { url: string; referrer: string }) {\n    return {\n      url,\n      referrer,\n    }\n  }\n\n  return {\n    findUrl: (startTime?: RelativeTime) => urlContextHistory.find(startTime),\n    stop: () => {\n      locationChangeSubscription.unsubscribe()\n      urlContextHistory.stop()\n    },\n  }\n}\n","import { addEventListener, DOM_EVENT, instrumentMethod, Observable, shallowClone } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\n\nexport interface LocationChange {\n  oldLocation: Readonly<Location>\n  newLocation: Readonly<Location>\n}\n\nexport function createLocationChangeObservable(configuration: RumConfiguration, location: Location) {\n  let currentLocation = shallowClone(location)\n\n  return new Observable<LocationChange>((observable) => {\n    const { stop: stopHistoryTracking } = trackHistory(configuration, onLocationChange)\n    const { stop: stopHashTracking } = trackHash(configuration, onLocationChange)\n\n    function onLocationChange() {\n      if (currentLocation.href === location.href) {\n        return\n      }\n      const newLocation = shallowClone(location)\n      observable.notify({\n        newLocation,\n        oldLocation: currentLocation,\n      })\n      currentLocation = newLocation\n    }\n\n    return () => {\n      stopHistoryTracking()\n      stopHashTracking()\n    }\n  })\n}\n\nfunction trackHistory(configuration: RumConfiguration, onHistoryChange: () => void) {\n  const { stop: stopInstrumentingPushState } = instrumentMethod(history, 'pushState', ({ onPostCall }) => {\n    onPostCall(onHistoryChange)\n  })\n  const { stop: stopInstrumentingReplaceState } = instrumentMethod(history, 'replaceState', ({ onPostCall }) => {\n    onPostCall(onHistoryChange)\n  })\n  const { stop: removeListener } = addEventListener(configuration, window, DOM_EVENT.POP_STATE, onHistoryChange)\n\n  return {\n    stop: () => {\n      stopInstrumentingPushState()\n      stopInstrumentingReplaceState()\n      removeListener()\n    },\n  }\n}\n\nfunction trackHash(configuration: RumConfiguration, onHashChange: () => void) {\n  return addEventListener(configuration, window, DOM_EVENT.HASH_CHANGE, onHashChange)\n}\n","import type { RelativeTime, ContextValue, Context, CustomerDataTracker } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, ValueHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\nexport const FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type FeatureFlagContext = Context\n\nexport interface FeatureFlagContexts {\n  findFeatureFlagEvaluations: (startTime?: RelativeTime) => FeatureFlagContext | undefined\n  addFeatureFlagEvaluation: (key: string, value: ContextValue) => void\n  stop: () => void\n}\n\n/**\n * Start feature flag contexts\n *\n * Feature flag contexts follow the life of views.\n * A new context is added when a view is created and ended when the view is ended\n *\n * Note: we choose not to add a new context at each evaluation to save memory\n */\nexport function startFeatureFlagContexts(\n  lifeCycle: LifeCycle,\n  customerDataTracker: CustomerDataTracker\n): FeatureFlagContexts {\n  const featureFlagContexts = new ValueHistory<FeatureFlagContext>(FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY)\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_VIEW_CREATED, ({ startClocks }) => {\n    featureFlagContexts.add({}, startClocks.relative)\n    customerDataTracker.resetCustomerData()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.AFTER_VIEW_ENDED, ({ endClocks }) => {\n    featureFlagContexts.closeActive(endClocks.relative)\n  })\n\n  return {\n    findFeatureFlagEvaluations: (startTime?: RelativeTime) => featureFlagContexts.find(startTime),\n    addFeatureFlagEvaluation: (key: string, value: ContextValue) => {\n      const currentContext = featureFlagContexts.find()\n      if (currentContext) {\n        currentContext[key] = value\n        customerDataTracker.updateCustomerData(currentContext)\n      }\n    },\n    stop: () => customerDataTracker.stop(),\n  }\n}\n","import type { Context, CustomerDataTrackerManager, FlushEvent, Observable, Telemetry } from '@datadog/browser-core'\nimport {\n  includes,\n  performDraw,\n  ONE_SECOND,\n  addTelemetryDebug,\n  setInterval,\n  CustomerDataType,\n} from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const MEASURES_PERIOD_DURATION = 10 * ONE_SECOND\n\ntype Measure = {\n  min: number\n  max: number\n  sum: number\n}\n\ntype CurrentPeriodMeasures = {\n  batchCount: number\n  batchBytesCount: Measure\n  batchMessagesCount: Measure\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\ntype CurrentBatchMeasures = {\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\nlet currentPeriodMeasures: CurrentPeriodMeasures\nlet currentBatchMeasures: CurrentBatchMeasures\nlet batchHasRumEvent: boolean\n\nexport function startCustomerDataTelemetry(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  lifeCycle: LifeCycle,\n  customerDataTrackerManager: CustomerDataTrackerManager,\n  batchFlushObservable: Observable<FlushEvent>\n) {\n  const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n  if (!customerDataTelemetryEnabled) {\n    return\n  }\n\n  initCurrentPeriodMeasures()\n  initCurrentBatchMeasures()\n\n  // We measure the data of every view updates even if there could only be one per batch due to the upsert\n  // It means that contexts bytes count sums can be higher than it really is\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event: RumEvent & Context) => {\n    batchHasRumEvent = true\n    updateMeasure(\n      currentBatchMeasures.globalContextBytes,\n      customerDataTrackerManager.getOrCreateTracker(CustomerDataType.GlobalContext).getBytesCount()\n    )\n\n    updateMeasure(\n      currentBatchMeasures.userContextBytes,\n      customerDataTrackerManager.getOrCreateTracker(CustomerDataType.User).getBytesCount()\n    )\n\n    updateMeasure(\n      currentBatchMeasures.featureFlagBytes,\n      includes([RumEventType.VIEW, RumEventType.ERROR], event.type)\n        ? customerDataTrackerManager.getOrCreateTracker(CustomerDataType.FeatureFlag).getBytesCount()\n        : 0\n    )\n  })\n\n  batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {\n    // Don't measure batch that only contains telemetry events to avoid batch sending loop\n    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n    if (!batchHasRumEvent) {\n      return\n    }\n    currentPeriodMeasures.batchCount += 1\n    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount)\n    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount)\n    mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes)\n    mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes)\n    mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes)\n    initCurrentBatchMeasures()\n  })\n\n  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION)\n}\n\nfunction sendCurrentPeriodMeasures() {\n  if (currentPeriodMeasures.batchCount === 0) {\n    return\n  }\n\n  addTelemetryDebug('Customer data measures', currentPeriodMeasures)\n  initCurrentPeriodMeasures()\n}\n\nfunction createMeasure(): Measure {\n  return { min: Infinity, max: 0, sum: 0 }\n}\n\nfunction updateMeasure(measure: Measure, value: number) {\n  measure.sum += value\n  measure.min = Math.min(measure.min, value)\n  measure.max = Math.max(measure.max, value)\n}\n\nfunction mergeMeasure(target: Measure, source: Measure) {\n  target.sum += source.sum\n  target.min = Math.min(target.min, source.min)\n  target.max = Math.max(target.max, source.max)\n}\n\nfunction initCurrentPeriodMeasures() {\n  currentPeriodMeasures = {\n    batchCount: 0,\n    batchBytesCount: createMeasure(),\n    batchMessagesCount: createMeasure(),\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n\nfunction initCurrentBatchMeasures() {\n  batchHasRumEvent = false\n  currentBatchMeasures = {\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  elapsed,\n  ValueHistory,\n  SESSION_TIME_OUT_DELAY,\n  toServerDuration,\n  addEventListeners,\n  relativeNow,\n  DOM_EVENT,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type { PageStateServerEntry } from '../../rawRumEvent.types'\n\n// Arbitrary value to cap number of element for memory consumption in the browser\nexport const MAX_PAGE_STATE_ENTRIES = 4000\n// Arbitrary value to cap number of element for backend & to save bandwidth\nexport const MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500\n\nexport const PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport const enum PageState {\n  ACTIVE = 'active',\n  PASSIVE = 'passive',\n  HIDDEN = 'hidden',\n  FROZEN = 'frozen',\n  TERMINATED = 'terminated',\n}\n\nexport type PageStateEntry = { state: PageState; startTime: RelativeTime }\n\nexport interface PageStateHistory {\n  findAll: (startTime: RelativeTime, duration: Duration) => PageStateServerEntry[] | undefined\n  wasInPageStateAt: (state: PageState, startTime: RelativeTime) => boolean\n  wasInPageStateDuringPeriod: (state: PageState, startTime: RelativeTime, duration: Duration) => boolean\n  addPageState(nextPageState: PageState, startTime?: RelativeTime): void\n  stop: () => void\n}\n\nexport function startPageStateHistory(\n  configuration: RumConfiguration,\n  maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE\n): PageStateHistory {\n  const pageStateEntryHistory = new ValueHistory<PageStateEntry>(\n    PAGE_STATE_CONTEXT_TIME_OUT_DELAY,\n    MAX_PAGE_STATE_ENTRIES\n  )\n\n  let currentPageState: PageState\n  addPageState(getPageState(), relativeNow())\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    window,\n    [\n      DOM_EVENT.PAGE_SHOW,\n      DOM_EVENT.FOCUS,\n      DOM_EVENT.BLUR,\n      DOM_EVENT.VISIBILITY_CHANGE,\n      DOM_EVENT.RESUME,\n      DOM_EVENT.FREEZE,\n      DOM_EVENT.PAGE_HIDE,\n    ],\n    (event) => {\n      addPageState(computePageState(event), event.timeStamp as RelativeTime)\n    },\n    { capture: true }\n  )\n\n  function addPageState(nextPageState: PageState, startTime = relativeNow()) {\n    if (nextPageState === currentPageState) {\n      return\n    }\n\n    currentPageState = nextPageState\n    pageStateEntryHistory.closeActive(startTime)\n    pageStateEntryHistory.add({ state: currentPageState, startTime }, startTime)\n  }\n\n  const pageStateHistory = {\n    findAll: (eventStartTime: RelativeTime, duration: Duration): PageStateServerEntry[] | undefined => {\n      const pageStateEntries = pageStateEntryHistory.findAll(eventStartTime, duration)\n\n      if (pageStateEntries.length === 0) {\n        return\n      }\n\n      const pageStateServerEntries = []\n      // limit the number of entries to return\n      const limit = Math.max(0, pageStateEntries.length - maxPageStateEntriesSelectable)\n\n      // loop page state entries backward to return the selected ones in desc order\n      for (let index = pageStateEntries.length - 1; index >= limit; index--) {\n        const pageState = pageStateEntries[index]\n        // compute the start time relative to the event start time (ex: to be relative to the view start time)\n        const relativeStartTime = elapsed(eventStartTime, pageState.startTime)\n\n        pageStateServerEntries.push({\n          state: pageState.state,\n          start: toServerDuration(relativeStartTime),\n        })\n      }\n\n      return pageStateServerEntries\n    },\n    wasInPageStateAt: (state: PageState, startTime: RelativeTime) =>\n      pageStateHistory.wasInPageStateDuringPeriod(state, startTime, 0 as Duration),\n    wasInPageStateDuringPeriod: (state: PageState, startTime: RelativeTime, duration: Duration) =>\n      pageStateEntryHistory.findAll(startTime, duration).some((pageState) => pageState.state === state),\n    addPageState,\n    stop: () => {\n      stopEventListeners()\n      pageStateEntryHistory.stop()\n    },\n  }\n  return pageStateHistory\n}\n\nfunction computePageState(event: Event & { type: DOM_EVENT }) {\n  if (event.type === DOM_EVENT.FREEZE) {\n    return PageState.FROZEN\n  } else if (event.type === DOM_EVENT.PAGE_HIDE) {\n    return (event as PageTransitionEvent).persisted ? PageState.FROZEN : PageState.TERMINATED\n  }\n  return getPageState()\n}\n\nfunction getPageState() {\n  if (document.visibilityState === 'hidden') {\n    return PageState.HIDDEN\n  }\n\n  if (document.hasFocus()) {\n    return PageState.ACTIVE\n  }\n\n  return PageState.PASSIVE\n}\n","import type { ClocksState, Duration, Context } from '@datadog/browser-core'\nimport { combine, elapsed, generateUUID } from '@datadog/browser-core'\nimport type { LifeCycle, RawRumEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { RawRumVitalEvent } from '../../rawRumEvent.types'\nimport { RumEventType, VitalType } from '../../rawRumEvent.types'\nimport type { PageStateHistory } from '../contexts/pageStateHistory'\nimport { PageState } from '../contexts/pageStateHistory'\n\nexport interface DurationVitalStart {\n  name: string\n  startClocks: ClocksState\n  context?: Context\n}\n\nexport interface DurationVitalStop {\n  name: string\n  stopClocks: ClocksState\n  context?: Context\n}\n\ninterface DurationVital {\n  name: string\n  type: VitalType.DURATION\n  startClocks: ClocksState\n  value: Duration\n  context?: Context\n}\n\nexport function startVitalCollection(lifeCycle: LifeCycle, pageStateHistory: PageStateHistory) {\n  const vitalStartsByName = new Map<string, DurationVitalStart>()\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    // Discard all the vitals that have not been stopped to avoid memory leaks\n    vitalStartsByName.clear()\n  })\n\n  function isValid(vital: DurationVital) {\n    return !pageStateHistory.wasInPageStateDuringPeriod(PageState.FROZEN, vital.startClocks.relative, vital.value)\n  }\n\n  return {\n    startDurationVital: (vitalStart: DurationVitalStart) => {\n      vitalStartsByName.set(vitalStart.name, vitalStart)\n    },\n    stopDurationVital: (vitalStop: DurationVitalStop) => {\n      const vitalStart = vitalStartsByName.get(vitalStop.name)\n      if (!vitalStart) {\n        return\n      }\n      const vital = buildDurationVital(vitalStart, vitalStop)\n      vitalStartsByName.delete(vital.name)\n      if (isValid(vital)) {\n        lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processVital(vital, true))\n      }\n    },\n  }\n}\n\nfunction buildDurationVital(vitalStart: DurationVitalStart, vitalStop: DurationVitalStop) {\n  return {\n    name: vitalStart.name,\n    type: VitalType.DURATION,\n    startClocks: vitalStart.startClocks,\n    value: elapsed(vitalStart.startClocks.timeStamp, vitalStop.stopClocks.timeStamp),\n    context: combine(vitalStart.context, vitalStop.context),\n  }\n}\n\nfunction processVital(vital: DurationVital, valueComputedBySdk: boolean): RawRumEventCollectedData<RawRumVitalEvent> {\n  const rawRumEvent: RawRumVitalEvent = {\n    date: vital.startClocks.timeStamp,\n    vital: {\n      id: generateUUID(),\n      type: vital.type,\n      name: vital.name,\n      custom: {\n        [vital.name]: vital.value,\n      },\n    },\n    type: RumEventType.VITAL,\n  }\n\n  if (valueComputedBySdk) {\n    rawRumEvent._dd = {\n      vital: {\n        computed_value: true,\n      },\n    }\n  }\n\n  return {\n    rawRumEvent,\n    startTime: vital.startClocks.relative,\n    customerContext: vital.context,\n    domainContext: {},\n  }\n}\n","import type { Configuration, CookieStore } from '@datadog/browser-core'\nimport {\n  setInterval,\n  clearInterval,\n  Observable,\n  addEventListener,\n  ONE_SECOND,\n  findCommaSeparatedValue,\n  DOM_EVENT,\n  find,\n} from '@datadog/browser-core'\n\nexport interface CookieStoreWindow extends Window {\n  cookieStore?: CookieStore\n}\n\nexport type CookieObservable = ReturnType<typeof createCookieObservable>\n\nexport function createCookieObservable(configuration: Configuration, cookieName: string) {\n  const detectCookieChangeStrategy = (window as CookieStoreWindow).cookieStore\n    ? listenToCookieStoreChange(configuration)\n    : watchCookieFallback\n\n  return new Observable<string | undefined>((observable) =>\n    detectCookieChangeStrategy(cookieName, (event) => observable.notify(event))\n  )\n}\n\nfunction listenToCookieStoreChange(configuration: Configuration) {\n  return (cookieName: string, callback: (event: string | undefined) => void) => {\n    const listener = addEventListener(\n      configuration,\n      (window as CookieStoreWindow).cookieStore!,\n      DOM_EVENT.CHANGE,\n      (event) => {\n        // Based on our experimentation, we're assuming that entries for the same cookie cannot be in both the 'changed' and 'deleted' arrays.\n        // However, due to ambiguity in the specification, we asked for clarification: https://github.com/WICG/cookie-store/issues/226\n        const changeEvent =\n          find(event.changed, (event) => event.name === cookieName) ||\n          find(event.deleted, (event) => event.name === cookieName)\n        if (changeEvent) {\n          callback(changeEvent.value)\n        }\n      }\n    )\n    return listener.stop\n  }\n}\n\nexport const WATCH_COOKIE_INTERVAL_DELAY = ONE_SECOND\n\nfunction watchCookieFallback(cookieName: string, callback: (event: string | undefined) => void) {\n  const previousCookieValue = findCommaSeparatedValue(document.cookie, cookieName)\n  const watchCookieIntervalId = setInterval(() => {\n    const cookieValue = findCommaSeparatedValue(document.cookie, cookieName)\n    if (cookieValue !== previousCookieValue) {\n      callback(cookieValue)\n    }\n  }, WATCH_COOKIE_INTERVAL_DELAY)\n\n  return () => {\n    clearInterval(watchCookieIntervalId)\n  }\n}\n","import { getInitCookie, type Configuration } from '@datadog/browser-core'\n\nimport { createCookieObservable } from '../../browser/cookieObservable'\n\nexport const CI_VISIBILITY_TEST_ID_COOKIE_NAME = 'datadog-ci-visibility-test-execution-id'\n\nexport interface CiTestWindow extends Window {\n  Cypress?: {\n    env: (key: string) => string | undefined\n  }\n}\n\nexport type CiVisibilityContext = ReturnType<typeof startCiVisibilityContext>\n\nexport function startCiVisibilityContext(\n  configuration: Configuration,\n  cookieObservable = createCookieObservable(configuration, CI_VISIBILITY_TEST_ID_COOKIE_NAME)\n) {\n  let testExecutionId =\n    getInitCookie(CI_VISIBILITY_TEST_ID_COOKIE_NAME) || (window as CiTestWindow).Cypress?.env('traceId')\n\n  const cookieObservableSubscription = cookieObservable.subscribe((value) => {\n    testExecutionId = value\n  })\n\n  return {\n    get: () => {\n      if (typeof testExecutionId === 'string') {\n        return {\n          test_execution_id: testExecutionId,\n        }\n      }\n    },\n    stop: () => cookieObservableSubscription.unsubscribe(),\n  }\n}\n","import { INTAKE_SITE_STAGING, INTAKE_SITE_US1, INTAKE_SITE_EU1 } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { ViewContext } from './contexts/viewContexts'\nimport type { RumSession } from './rumSessionManager'\n\nexport function getSessionReplayUrl(\n  configuration: RumConfiguration,\n  {\n    session,\n    viewContext,\n    errorType,\n  }: {\n    session?: RumSession\n    viewContext?: ViewContext\n    errorType?: string\n  }\n): string {\n  const sessionId = session ? session.id : 'no-session-id'\n  const parameters: string[] = []\n  if (errorType !== undefined) {\n    parameters.push(`error-type=${errorType}`)\n  }\n  if (viewContext) {\n    parameters.push(`seed=${viewContext.id}`)\n    parameters.push(`from=${viewContext.startClocks.timeStamp}`)\n  }\n\n  const origin = getDatadogSiteUrl(configuration)\n  const path = `/rum/replay/sessions/${sessionId}`\n  return `${origin}${path}?${parameters.join('&')}`\n}\n\nexport function getDatadogSiteUrl(rumConfiguration: RumConfiguration) {\n  const site = rumConfiguration.site\n  const subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration)\n  return `https://${subdomain ? `${subdomain}.` : ''}${site}`\n}\n\nfunction getSiteDefaultSubdomain(configuration: RumConfiguration): string | undefined {\n  switch (configuration.site) {\n    case INTAKE_SITE_US1:\n    case INTAKE_SITE_EU1:\n      return 'app'\n    case INTAKE_SITE_STAGING:\n      return 'dd'\n    default:\n      return undefined\n  }\n}\n","import type { ReplayStats } from '@datadog/browser-rum-core'\n\nexport const MAX_STATS_HISTORY = 10\nlet statsPerView: Map<string, ReplayStats> | undefined\n\nexport function getSegmentsCount(viewId: string) {\n  return getOrCreateReplayStats(viewId).segments_count\n}\n\nexport function addSegment(viewId: string) {\n  getOrCreateReplayStats(viewId).segments_count += 1\n}\n\nexport function addRecord(viewId: string) {\n  getOrCreateReplayStats(viewId).records_count += 1\n}\n\nexport function addWroteData(viewId: string, additionalBytesCount: number) {\n  getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount\n}\n\nexport function getReplayStats(viewId: string) {\n  return statsPerView?.get(viewId)\n}\n\nexport function resetReplayStats() {\n  statsPerView = undefined\n}\n\nfunction getOrCreateReplayStats(viewId: string) {\n  if (!statsPerView) {\n    statsPerView = new Map()\n  }\n\n  let replayStats: ReplayStats\n  if (statsPerView.has(viewId)) {\n    replayStats = statsPerView.get(viewId)!\n  } else {\n    replayStats = {\n      records_count: 0,\n      segments_count: 0,\n      segments_total_raw_size: 0,\n    }\n    statsPerView.set(viewId, replayStats)\n    if (statsPerView.size > MAX_STATS_HISTORY) {\n      deleteOldestStats()\n    }\n  }\n\n  return replayStats\n}\n\nfunction deleteOldestStats() {\n  if (!statsPerView) {\n    return\n  }\n  if (statsPerView.keys) {\n    statsPerView.delete(statsPerView.keys().next().value)\n  } else {\n    // IE11 doesn't support map.keys\n    let isFirst = true\n    statsPerView.forEach((_value, key) => {\n      if (isFirst) {\n        statsPerView!.delete(key)\n        isFirst = false\n      }\n    })\n  }\n}\n","import { buildUrl } from '@datadog/browser-core'\nimport { getParentNode, isNodeShadowRoot, CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core'\nimport type { NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { NodeWithSerializedNode } from './serialization.types'\n\nconst serializedNodeIds = new WeakMap<Node, number>()\n\nexport function hasSerializedNode(node: Node): node is NodeWithSerializedNode {\n  return serializedNodeIds.has(node)\n}\n\nexport function nodeAndAncestorsHaveSerializedNode(node: Node): node is NodeWithSerializedNode {\n  let current: Node | null = node\n  while (current) {\n    if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n      return false\n    }\n    current = getParentNode(current)\n  }\n  return true\n}\n\nexport function getSerializedNodeId(node: NodeWithSerializedNode): number\nexport function getSerializedNodeId(node: Node): number | undefined\nexport function getSerializedNodeId(node: Node) {\n  return serializedNodeIds.get(node)\n}\n\nexport function setSerializedNodeId(node: Node, serializeNodeId: number) {\n  serializedNodeIds.set(node, serializeNodeId)\n}\n\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element: Element, nodePrivacyLevel: NodePrivacyLevel) {\n  /*\n   BROWSER SPEC NOTE: <input>, <select>\n   For some <input> elements, the `value` is an exceptional property/attribute that has the\n   value synced between el.value and el.getAttribute()\n   input[type=button,checkbox,hidden,image,radio,reset,submit]\n   */\n  const tagName = element.tagName\n  const value = (element as HTMLInputElement | HTMLTextAreaElement).value\n\n  if (shouldMaskNode(element, nodePrivacyLevel)) {\n    const type = (element as HTMLInputElement | HTMLTextAreaElement).type\n    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n      // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n      // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n      return value\n    } else if (!value || tagName === 'OPTION') {\n      // <Option> value provides no benefit\n      return\n    }\n    return CENSORED_STRING_MARK\n  }\n\n  if (tagName === 'OPTION' || tagName === 'SELECT') {\n    return (element as HTMLOptionElement | HTMLSelectElement).value\n  }\n\n  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n    return\n  }\n\n  return value\n}\n\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//\nexport const DATA_URI = /^data:.*,/i\n\nexport function switchToAbsoluteUrl(cssText: string, cssHref: string | null): string {\n  return cssText.replace(\n    URL_IN_CSS_REF,\n    (\n      matchingSubstring: string,\n      singleQuote: string | undefined,\n      urlWrappedInSingleQuotes: string | undefined,\n      doubleQuote: string | undefined,\n      urlWrappedInDoubleQuotes: string | undefined,\n      urlNotWrappedInQuotes: string | undefined\n    ) => {\n      const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes\n\n      if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n        return matchingSubstring\n      }\n\n      const quote = singleQuote || doubleQuote || ''\n      return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`\n    }\n  )\n}\n\nexport function makeUrlAbsolute(url: string, baseUrl: string): string {\n  try {\n    return buildUrl(url, baseUrl).href\n  } catch (_) {\n    return url\n  }\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nexport function getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n\nexport function censoredImageForSize(width: number, height: number) {\n  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`\n}\n","import type * as SessionReplay from './sessionReplay'\n\nexport const RecordType: {\n  FullSnapshot: SessionReplay.BrowserFullSnapshotRecord['type']\n  IncrementalSnapshot: SessionReplay.BrowserIncrementalSnapshotRecord['type']\n  Meta: SessionReplay.MetaRecord['type']\n  Focus: SessionReplay.FocusRecord['type']\n  ViewEnd: SessionReplay.ViewEndRecord['type']\n  VisualViewport: SessionReplay.VisualViewportRecord['type']\n  FrustrationRecord: SessionReplay.FrustrationRecord['type']\n} = {\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Focus: 6,\n  ViewEnd: 7,\n  VisualViewport: 8,\n  FrustrationRecord: 9,\n} as const\n\nexport type RecordType = (typeof RecordType)[keyof typeof RecordType]\n\nexport const NodeType: {\n  Document: SessionReplay.DocumentNode['type']\n  DocumentType: SessionReplay.DocumentTypeNode['type']\n  Element: SessionReplay.ElementNode['type']\n  Text: SessionReplay.TextNode['type']\n  CDATA: SessionReplay.CDataNode['type']\n  DocumentFragment: SessionReplay.DocumentFragmentNode['type']\n} = {\n  Document: 0,\n  DocumentType: 1,\n  Element: 2,\n  Text: 3,\n  CDATA: 4,\n  DocumentFragment: 11,\n} as const\n\nexport type NodeType = (typeof NodeType)[keyof typeof NodeType]\n\nexport const IncrementalSource: {\n  Mutation: SessionReplay.BrowserMutationData['source']\n  MouseMove: Exclude<SessionReplay.MousemoveData['source'], 6>\n  MouseInteraction: SessionReplay.MouseInteractionData['source']\n  Scroll: SessionReplay.ScrollData['source']\n  ViewportResize: SessionReplay.ViewportResizeData['source']\n  Input: SessionReplay.InputData['source']\n  TouchMove: Exclude<SessionReplay.MousemoveData['source'], 1>\n  MediaInteraction: SessionReplay.MediaInteractionData['source']\n  StyleSheetRule: SessionReplay.StyleSheetRuleData['source']\n} = {\n  Mutation: 0,\n  MouseMove: 1,\n  MouseInteraction: 2,\n  Scroll: 3,\n  ViewportResize: 4,\n  Input: 5,\n  TouchMove: 6,\n  MediaInteraction: 7,\n  StyleSheetRule: 8,\n  // CanvasMutation : 9,\n  // Font : 10,\n} as const\n\nexport type IncrementalSource = (typeof IncrementalSource)[keyof typeof IncrementalSource]\n\nexport const MouseInteractionType = {\n  MouseUp: 0,\n  MouseDown: 1,\n  Click: 2,\n  ContextMenu: 3,\n  DblClick: 4,\n  Focus: 5,\n  Blur: 6,\n  TouchStart: 7,\n  TouchEnd: 9,\n} as const\n\nexport type MouseInteractionType = (typeof MouseInteractionType)[keyof typeof MouseInteractionType]\n\nexport const MediaInteractionType = {\n  Play: 0,\n  Pause: 1,\n} as const\n\nexport type MediaInteractionType = (typeof MediaInteractionType)[keyof typeof MediaInteractionType]\n","import type { StyleSheet } from '../../../types'\n\nexport function serializeStyleSheets(cssStyleSheets: CSSStyleSheet[] | undefined): StyleSheet[] | undefined {\n  if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n    return undefined\n  }\n  return cssStyleSheets.map((cssStyleSheet) => {\n    const rules = cssStyleSheet.cssRules || cssStyleSheet.rules\n    const cssRules = Array.from(rules, (cssRule) => cssRule.cssText)\n\n    const styleSheet: StyleSheet = {\n      cssRules,\n      disabled: cssStyleSheet.disabled || undefined,\n      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n    }\n    return styleSheet\n  })\n}\n","import { startsWith } from '@datadog/browser-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  CENSORED_STRING_MARK,\n  CENSORED_IMG_MARK,\n  STABLE_ATTRIBUTES,\n  isLongDataUrl,\n  sanitizeDataUrl,\n} from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { censoredImageForSize } from './serializationUtils'\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | number | boolean | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n  const attributeValue = element.getAttribute(attributeName)\n  if (\n    nodePrivacyLevel === NodePrivacyLevel.MASK &&\n    attributeName !== PRIVACY_ATTR_NAME &&\n    !STABLE_ATTRIBUTES.includes(attributeName) &&\n    attributeName !== configuration.actionNameAttribute\n  ) {\n    const tagName = element.tagName\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK\n    }\n\n    // mask image URLs\n    if (tagName === 'IMG' && (attributeName === 'src' || attributeName === 'srcset')) {\n      // generate image with similar dimension than the original to have the same rendering behaviour\n      const image = element as HTMLImageElement\n      if (image.naturalWidth > 0) {\n        return censoredImageForSize(image.naturalWidth, image.naturalHeight)\n      }\n      const { width, height } = element.getBoundingClientRect()\n      if (width > 0 || height > 0) {\n        return censoredImageForSize(width, height)\n      }\n      // if we can't get the image size, fallback to the censored image\n      return CENSORED_IMG_MARK\n    }\n\n    // mask source URLs\n    if (tagName === 'SOURCE' && (attributeName === 'src' || attributeName === 'srcset')) {\n      return CENSORED_IMG_MARK\n    }\n\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK\n    }\n\n    // mask data-* attributes\n    if (attributeValue && startsWith(attributeName, 'data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK\n    }\n\n    // mask iframe srcdoc\n    if (tagName === 'IFRAME' && attributeName === 'srcdoc') {\n      return CENSORED_STRING_MARK\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue\n  }\n\n  // Minimum Fix for customer.\n  if (isLongDataUrl(attributeValue)) {\n    return sanitizeDataUrl(attributeValue)\n  }\n\n  return attributeValue\n}\n","import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core'\nimport { isSafari } from '@datadog/browser-core'\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { SerializationContextStatus } from './serialization.types'\nimport { serializeAttribute } from './serializeAttribute'\n\nexport function serializeAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i)!\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet)\n    if (cssText && stylesheet) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (tagName === 'style' && (element as HTMLStyleElement).sheet) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      delete safeAttrs.checked\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n\nexport function getCssRulesString(cssStyleSheet: CSSStyleSheet | undefined | null): string | null {\n  if (!cssStyleSheet) {\n    return null\n  }\n  let rules: CSSRuleList | undefined\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules\n  } catch {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null\n  }\n  const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('')\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href)\n}\n\nfunction getCssRuleStringForSafari(rule: CSSRule): string {\n  // Safari does not escape attribute selectors containing : properly\n  // https://bugs.webkit.org/show_bug.cgi?id=184604\n  if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n    // This regex replaces [foo:bar] by [foo\\\\:bar]\n    const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g\n    return rule.cssText.replace(escapeColon, '$1\\\\$2')\n  }\n\n  return getCssRuleString(rule)\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n  // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n  // to the @import rule CSS text.\n  return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n\nfunction isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n  return 'selectorText' in rule\n}\n","import {\n  reducePrivacyLevel,\n  getNodeSelfPrivacyLevel,\n  getTextContent,\n  isNodeShadowRoot,\n  hasChildNodes,\n  forEachChildNodes,\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n} from '@datadog/browser-rum-core'\nimport { assign } from '@datadog/browser-core'\nimport type {\n  DocumentFragmentNode,\n  DocumentNode,\n  SerializedNode,\n  SerializedNodeWithId,\n  CDataNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n} from '../../../types'\nimport { NodeType } from '../../../types'\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { serializeStyleSheets } from './serializeStyleSheets'\nimport { serializeAttributes } from './serializeAttributes'\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nlet _nextId = 1\nexport function generateNextId(): number {\n  return _nextId++\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  forEachChildNodes(node, (childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  options: SerializeOptions\n): DocumentFragmentNode | undefined {\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes: serializeChildNodes(element, options),\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\nfunction serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = serializeAttributes(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (\n    hasChildNodes(element) &&\n    // Do not serialize style children as the css rules are already in the _cssText attribute\n    tagName !== 'style'\n  ) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      })\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (textContent === undefined) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n","import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { SerializedNodeWithId } from '../../../types'\nimport type { SerializationContext } from './serialization.types'\nimport { serializeNodeWithId } from './serializeNode'\n\nexport function serializeDocument(\n  document: Document,\n  configuration: RumConfiguration,\n  serializationContext: SerializationContext\n): SerializedNodeWithId {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration,\n  })!\n}\n","import { isNodeShadowHost } from '@datadog/browser-rum-core'\n\nexport function isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches)\n}\n\nexport function getEventTarget(event: Event): Node {\n  if (event.composed === true && isNodeShadowHost(event.target as Node)) {\n    return event.composedPath()[0] as Node\n  }\n  return event.target as Node\n}\n","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport: VisualViewport) {\n  return (\n    Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visualViewport = window.visualViewport\n  const normalized: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft)\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft)\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop)\n  }\n  return normalized\n}\n\nexport const getVisualViewport = (visualViewport: VisualViewport): VisualViewportRecord['data'] => ({\n  scale: visualViewport.scale,\n  offsetLeft: visualViewport.offsetLeft,\n  offsetTop: visualViewport.offsetTop,\n  pageLeft: visualViewport.pageLeft,\n  pageTop: visualViewport.pageTop,\n  height: visualViewport.height,\n  width: visualViewport.width,\n})\n","import { assign, timeStampNow } from '@datadog/browser-core'\nimport type { BrowserIncrementalData, BrowserIncrementalSnapshotRecord } from '../../types'\nimport { RecordType } from '../../types'\n\nexport function assembleIncrementalSnapshot<Data extends BrowserIncrementalData>(\n  source: Data['source'],\n  data: Omit<Data, 'source'>\n): BrowserIncrementalSnapshotRecord {\n  return {\n    data: assign(\n      {\n        source,\n      },\n      data\n    ) as Data,\n    type: RecordType.IncrementalSnapshot,\n    timestamp: timeStampNow(),\n  }\n}\n","import { addEventListeners, addTelemetryDebug, DOM_EVENT, throttle } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { BrowserIncrementalSnapshotRecord, MousemoveData, MousePosition } from '../../../types'\nimport { IncrementalSource } from '../../../types'\nimport { getEventTarget, isTouchEvent } from '../eventsUtils'\nimport { convertMouseEventToLayoutCoordinates } from '../viewports'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50\n\nexport type MousemoveCallBack = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackMove(configuration: RumConfiguration, moveCb: MousemoveCallBack): Tracker {\n  const { throttled: updatePosition, cancel: cancelThrottle } = throttle(\n    (event: MouseEvent | TouchEvent) => {\n      const target = getEventTarget(event)\n      if (hasSerializedNode(target)) {\n        const coordinates = tryToComputeCoordinates(event)\n        if (!coordinates) {\n          return\n        }\n        const position: MousePosition = {\n          id: getSerializedNodeId(target),\n          timeOffset: 0,\n          x: coordinates.x,\n          y: coordinates.y,\n        }\n\n        moveCb(\n          assembleIncrementalSnapshot<MousemoveData>(\n            isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove,\n            { positions: [position] }\n          )\n        )\n      }\n    },\n    MOUSE_MOVE_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n\n  const { stop: removeListener } = addEventListeners(\n    configuration,\n    document,\n    [DOM_EVENT.MOUSE_MOVE, DOM_EVENT.TOUCH_MOVE],\n    updatePosition,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n\nexport function tryToComputeCoordinates(event: MouseEvent | TouchEvent) {\n  let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event\n  if (window.visualViewport) {\n    const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y)\n    x = visualViewportX\n    y = visualViewportY\n  }\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    if (event.isTrusted) {\n      addTelemetryDebug('mouse/touch event without x/y')\n    }\n    return undefined\n  }\n  return { x, y }\n}\n","import { assign, addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { MouseInteraction, MouseInteractionData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { IncrementalSource, MouseInteractionType } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport { getEventTarget } from '../eventsUtils'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { RecordIds } from '../recordIds'\nimport { tryToComputeCoordinates } from './trackMove'\nimport type { Tracker } from './types'\n\nconst eventTypeToMouseInteraction = {\n  // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n  // allows to reference such records from Frustration records.\n  //\n  // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n  // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n  // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n  // convey such interaction. This would cleanly solve the issue since we would have\n  // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n  [DOM_EVENT.POINTER_UP]: MouseInteractionType.MouseUp,\n\n  [DOM_EVENT.MOUSE_DOWN]: MouseInteractionType.MouseDown,\n  [DOM_EVENT.CLICK]: MouseInteractionType.Click,\n  [DOM_EVENT.CONTEXT_MENU]: MouseInteractionType.ContextMenu,\n  [DOM_EVENT.DBL_CLICK]: MouseInteractionType.DblClick,\n  [DOM_EVENT.FOCUS]: MouseInteractionType.Focus,\n  [DOM_EVENT.BLUR]: MouseInteractionType.Blur,\n  [DOM_EVENT.TOUCH_START]: MouseInteractionType.TouchStart,\n  [DOM_EVENT.TOUCH_END]: MouseInteractionType.TouchEnd,\n}\n\nexport type MouseInteractionCallback = (record: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackMouseInteraction(\n  configuration: RumConfiguration,\n  mouseInteractionCb: MouseInteractionCallback,\n  recordIds: RecordIds\n): Tracker {\n  const handler = (event: MouseEvent | TouchEvent | FocusEvent) => {\n    const target = getEventTarget(event)\n    if (\n      getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const type = eventTypeToMouseInteraction[event.type as keyof typeof eventTypeToMouseInteraction]\n\n    let interaction: MouseInteraction\n    if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n      const coordinates = tryToComputeCoordinates(event as MouseEvent | TouchEvent)\n      if (!coordinates) {\n        return\n      }\n      interaction = { id, type, x: coordinates.x, y: coordinates.y }\n    } else {\n      interaction = { id, type }\n    }\n\n    const record = assign(\n      { id: recordIds.getIdForEvent(event) },\n      assembleIncrementalSnapshot<MouseInteractionData>(IncrementalSource.MouseInteraction, interaction)\n    )\n    mouseInteractionCb(record)\n  }\n  return addEventListeners(\n    configuration,\n    document,\n    Object.keys(eventTypeToMouseInteraction) as Array<keyof typeof eventTypeToMouseInteraction>,\n    handler,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n}\n","import { DOM_EVENT, throttle, addEventListener } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { ElementsScrollPositions } from '../elementsScrollPositions'\nimport { getEventTarget } from '../eventsUtils'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, ScrollData } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nconst SCROLL_OBSERVER_THRESHOLD = 100\n\nexport type ScrollCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackScroll(\n  configuration: RumConfiguration,\n  scrollCb: ScrollCallback,\n  elementsScrollPositions: ElementsScrollPositions,\n  target: Document | ShadowRoot = document\n): Tracker {\n  const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event: Event) => {\n    const target = getEventTarget(event) as HTMLElement | Document\n    if (\n      !target ||\n      getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const scrollPositions =\n      target === document\n        ? {\n            scrollTop: getScrollY(),\n            scrollLeft: getScrollX(),\n          }\n        : {\n            scrollTop: Math.round((target as HTMLElement).scrollTop),\n            scrollLeft: Math.round((target as HTMLElement).scrollLeft),\n          }\n    elementsScrollPositions.set(target, scrollPositions)\n    scrollCb(\n      assembleIncrementalSnapshot<ScrollData>(IncrementalSource.Scroll, {\n        id,\n        x: scrollPositions.scrollLeft,\n        y: scrollPositions.scrollTop,\n      })\n    )\n  }, SCROLL_OBSERVER_THRESHOLD)\n\n  const { stop: removeListener } = addEventListener(configuration, target, DOM_EVENT.SCROLL, updatePosition, {\n    capture: true,\n    passive: true,\n  })\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n","import { throttle, DOM_EVENT, addEventListeners, timeStampNow, noop } from '@datadog/browser-core'\nimport type { RumConfiguration, ViewportDimension } from '@datadog/browser-rum-core'\nimport { initViewportObservable } from '@datadog/browser-rum-core'\nimport { IncrementalSource, RecordType } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, ViewportResizeData, VisualViewportRecord } from '../../../types'\nimport { getVisualViewport } from '../viewports'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200\n\nexport type ViewportResizeCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport type VisualViewportResizeCallback = (visualViewportRecord: VisualViewportRecord) => void\n\nexport function trackViewportResize(\n  configuration: RumConfiguration,\n  viewportResizeCb: ViewportResizeCallback\n): Tracker {\n  const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data: ViewportDimension) => {\n    viewportResizeCb(assembleIncrementalSnapshot<ViewportResizeData>(IncrementalSource.ViewportResize, data))\n  })\n\n  return {\n    stop: () => {\n      viewportResizeSubscription.unsubscribe()\n    },\n  }\n}\n\nexport function tackVisualViewportResize(\n  configuration: RumConfiguration,\n  visualViewportResizeCb: VisualViewportResizeCallback\n): Tracker {\n  const visualViewport = window.visualViewport\n  if (!visualViewport) {\n    return { stop: noop }\n  }\n  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(\n    () => {\n      visualViewportResizeCb({\n        data: getVisualViewport(visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp: timeStampNow(),\n      })\n    },\n    VISUAL_VIEWPORT_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n  const { stop: removeListener } = addEventListeners(\n    configuration,\n    visualViewport,\n    [DOM_EVENT.RESIZE, DOM_EVENT.SCROLL],\n    updateDimension,\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  return {\n    stop: () => {\n      removeListener()\n      cancelThrottle()\n    },\n  }\n}\n","import { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core'\nimport type { BrowserIncrementalSnapshotRecord, MediaInteractionData } from '../../../types'\nimport { IncrementalSource, MediaInteractionType } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nexport type MediaInteractionCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackMediaInteraction(\n  configuration: RumConfiguration,\n  mediaInteractionCb: MediaInteractionCallback\n): Tracker {\n  return addEventListeners(\n    configuration,\n    document,\n    [DOM_EVENT.PLAY, DOM_EVENT.PAUSE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        !target ||\n        getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n        !hasSerializedNode(target)\n      ) {\n        return\n      }\n      mediaInteractionCb(\n        assembleIncrementalSnapshot<MediaInteractionData>(IncrementalSource.MediaInteraction, {\n          id: getSerializedNodeId(target),\n          type: event.type === DOM_EVENT.PLAY ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        })\n      )\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n}\n","import { instrumentMethod } from '@datadog/browser-core'\nimport { IncrementalSource } from '../../../types'\nimport type { StyleSheetRuleData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\nexport type StyleSheetCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackStyleSheet(styleSheetCb: StyleSheetCallback): Tracker {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode!)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode))\n    }\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        styleSheetCb(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            adds: [{ rule, index }],\n          })\n        )\n      )\n    }),\n\n    instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n      checkStyleSheetAndCallback(styleSheet, (id) =>\n        styleSheetCb(\n          assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n            id,\n            removes: [{ index }],\n          })\n        )\n      )\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index || 0)\n            styleSheetCb(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index: path }],\n              })\n            )\n          }\n        })\n      }),\n\n      instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n        checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n          const path = getPathToNestedCSSRule(styleSheet)\n          if (path) {\n            path.push(index)\n            styleSheetCb(\n              assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index: path }],\n              })\n            )\n          }\n        })\n      })\n    )\n  }\n\n  return {\n    stop: () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    },\n  }\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n","import { DOM_EVENT, addEventListeners, timeStampNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { RecordType, type FocusRecord } from '../../../types'\nimport type { Tracker } from './types'\n\nexport type FocusCallback = (data: FocusRecord) => void\n\nexport function trackFocus(configuration: RumConfiguration, focusCb: FocusCallback): Tracker {\n  return addEventListeners(configuration, window, [DOM_EVENT.FOCUS, DOM_EVENT.BLUR], () => {\n    focusCb({\n      data: { has_focus: document.hasFocus() },\n      type: RecordType.Focus,\n      timestamp: timeStampNow(),\n    })\n  })\n}\n","import type { LifeCycle } from '@datadog/browser-rum-core'\nimport { ActionType, RumEventType, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { FrustrationRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { RecordIds } from '../recordIds'\nimport type { Tracker } from './types'\n\nexport type FrustrationCallback = (record: FrustrationRecord) => void\n\nexport function trackFrustration(\n  lifeCycle: LifeCycle,\n  frustrationCb: FrustrationCallback,\n  recordIds: RecordIds\n): Tracker {\n  const frustrationSubscription = lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n    if (\n      data.rawRumEvent.type === RumEventType.ACTION &&\n      data.rawRumEvent.action.type === ActionType.CLICK &&\n      data.rawRumEvent.action.frustration?.type?.length &&\n      'events' in data.domainContext &&\n      data.domainContext.events?.length\n    ) {\n      frustrationCb({\n        timestamp: data.rawRumEvent.date,\n        type: RecordType.FrustrationRecord,\n        data: {\n          frustrationTypes: data.rawRumEvent.action.frustration.type,\n          recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n        },\n      })\n    }\n  })\n\n  return {\n    stop: () => {\n      frustrationSubscription.unsubscribe()\n    },\n  }\n}\n","import { timeStampNow } from '@datadog/browser-core'\nimport type { LifeCycle } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { ViewEndRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { Tracker } from './types'\n\nexport type ViewEndCallback = (record: ViewEndRecord) => void\n\nexport function trackViewEnd(lifeCycle: LifeCycle, viewEndCb: ViewEndCallback): Tracker {\n  const viewEndSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, () => {\n    viewEndCb({\n      timestamp: timeStampNow(),\n      type: RecordType.ViewEnd,\n    })\n  })\n\n  return {\n    stop: () => {\n      viewEndSubscription.unsubscribe()\n    },\n  }\n}\n","import { instrumentSetter, assign, DOM_EVENT, addEventListeners, forEach, noop } from '@datadog/browser-core'\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode, cssEscape } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { IncrementalSource } from '../../../types'\nimport type { BrowserIncrementalSnapshotRecord, InputData, InputState } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nexport type InputCallback = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\nexport function trackInput(\n  configuration: RumConfiguration,\n  inputCb: InputCallback,\n  target: Document | ShadowRoot = document\n): Tracker {\n  const defaultPrivacyLevel = configuration.defaultPrivacyLevel\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  const isShadowRoot = target !== document\n\n  const { stop: stopEventListeners } = addEventListeners(\n    configuration,\n    target,\n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        target instanceof HTMLInputElement ||\n        target instanceof HTMLTextAreaElement ||\n        target instanceof HTMLSelectElement\n      ) {\n        onElementChange(target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  let stopPropertySetterInstrumentation: () => void\n  if (!isShadowRoot) {\n    const instrumentationStoppers = [\n      instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n    ]\n    stopPropertySetterInstrumentation = () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    }\n  } else {\n    stopPropertySetterInstrumentation = noop\n  }\n\n  return {\n    stop: () => {\n      stopPropertySetterInstrumentation()\n      stopEventListeners()\n    },\n  }\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      forEach(document.querySelectorAll(`input[type=\"radio\"][name=\"${cssEscape(name)}\"]`), (el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target: Node, inputState: InputState) {\n    if (!hasSerializedNode(target)) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      inputCb(\n        assembleIncrementalSnapshot<InputData>(\n          IncrementalSource.Input,\n          assign(\n            {\n              id: getSerializedNodeId(target),\n            },\n            inputState\n          )\n        )\n      )\n    }\n  }\n}\n","import { noop, monitor, throttle } from '@datadog/browser-core'\nimport type { RumMutationRecord } from './trackers'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n    leading: false,\n  })\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n      cancelThrottle()\n    },\n  }\n}\n\n/**\n * Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n * browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n * fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n * browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes efficiently.\n *\n * Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n */\nfunction requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  if (window.requestIdleCallback && window.cancelIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n","import { monitor, noop } from '@datadog/browser-core'\nimport type { RumConfiguration, NodePrivacyLevelCache } from '@datadog/browser-rum-core'\nimport {\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n  forEachChildNodes,\n  getNodePrivacyLevel,\n  getTextContent,\n  NodePrivacyLevel,\n} from '@datadog/browser-rum-core'\nimport { IncrementalSource } from '../../../types'\nimport type {\n  BrowserMutationData,\n  AddedNodeMutation,\n  AttributeMutation,\n  RemovedNodeMutation,\n  TextMutation,\n  BrowserIncrementalSnapshotRecord,\n} from '../../../types'\nimport type { NodeWithSerializedNode } from '../serialization'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n  serializeNodeWithId,\n  SerializationContextStatus,\n  serializeAttribute,\n} from '../serialization'\nimport { createMutationBatch } from '../mutationBatch'\nimport type { ShadowRootCallBack, ShadowRootsController } from '../shadowRootsController'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport type { Tracker } from './types'\n\nexport type MutationCallBack = (incrementalSnapshotRecord: BrowserIncrementalSnapshotRecord) => void\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\ninterface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\ninterface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\ninterface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\nexport type MutationTracker = Tracker & { flush: () => void }\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n): MutationTracker {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(\n      mutations.concat(observer.takeRecords() as RumMutationRecord[]),\n      mutationCallback,\n      configuration,\n      shadowRootsController\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: MutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController\n) {\n  const nodePrivacyLevelCache: NodePrivacyLevelCache = new Map()\n\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      mutation.target.isConnected &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n        NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration,\n    shadowRootsController,\n    nodePrivacyLevelCache\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration,\n    nodePrivacyLevelCache\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration,\n    nodePrivacyLevelCache\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback(\n    assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, { adds, removes, texts, attributes })\n  )\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      node.parentNode!,\n      configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION, shadowRootsController },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      configuration.defaultPrivacyLevel,\n      nodePrivacyLevelCache\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration,\n  nodePrivacyLevelCache: NodePrivacyLevelCache\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes?.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\n\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: ShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback))\n}\n","import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { BrowserIncrementalSnapshotRecord } from '../../types'\nimport { trackInput, trackMutation, trackScroll } from './trackers'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\n\ninterface ShadowRootController {\n  stop: () => void\n  flush: () => void\n}\n\nexport type ShadowRootCallBack = (shadowRoot: ShadowRoot) => void\n\nexport interface ShadowRootsController {\n  addShadowRoot: ShadowRootCallBack\n  removeShadowRoot: ShadowRootCallBack\n  stop: () => void\n  flush: () => void\n}\n\nexport const initShadowRootsController = (\n  configuration: RumConfiguration,\n  callback: (record: BrowserIncrementalSnapshotRecord) => void,\n  elementsScrollPositions: ElementsScrollPositions\n): ShadowRootsController => {\n  const controllerByShadowRoot = new Map<ShadowRoot, ShadowRootController>()\n\n  const shadowRootsController: ShadowRootsController = {\n    addShadowRoot: (shadowRoot: ShadowRoot) => {\n      if (controllerByShadowRoot.has(shadowRoot)) {\n        return\n      }\n      const mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot)\n      // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n      const inputTracker = trackInput(configuration, callback, shadowRoot)\n      // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n      const scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot)\n      controllerByShadowRoot.set(shadowRoot, {\n        flush: () => mutationTracker.flush(),\n        stop: () => {\n          mutationTracker.stop()\n          inputTracker.stop()\n          scrollTracker.stop()\n        },\n      })\n    },\n    removeShadowRoot: (shadowRoot: ShadowRoot) => {\n      const entry = controllerByShadowRoot.get(shadowRoot)\n      if (!entry) {\n        // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n        return\n      }\n      entry.stop()\n      controllerByShadowRoot.delete(shadowRoot)\n    },\n    stop: () => {\n      controllerByShadowRoot.forEach(({ stop }) => stop())\n    },\n    flush: () => {\n      controllerByShadowRoot.forEach(({ flush }) => flush())\n    },\n  }\n  return shadowRootsController\n}\n","import { sendToExtension } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration, ViewContexts } from '@datadog/browser-rum-core'\nimport type { BrowserRecord } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { Tracker } from './trackers'\nimport {\n  trackFocus,\n  trackFrustration,\n  trackInput,\n  trackMediaInteraction,\n  trackMouseInteraction,\n  trackMove,\n  trackMutation,\n  trackScroll,\n  trackStyleSheet,\n  trackViewEnd,\n  trackViewportResize,\n} from './trackers'\nimport { createElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { initShadowRootsController } from './shadowRootsController'\nimport { startFullSnapshots } from './startFullSnapshots'\nimport { initRecordIds } from './recordIds'\n\nexport interface RecordOptions {\n  emit?: (record: BrowserRecord) => void\n  configuration: RumConfiguration\n  lifeCycle: LifeCycle\n  viewContexts: ViewContexts\n}\n\nexport interface RecordAPI {\n  stop: () => void\n  flushMutations: () => void\n  shadowRootsController: ShadowRootsController\n}\n\nexport function record(options: RecordOptions): RecordAPI {\n  const { emit, configuration, lifeCycle } = options\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required')\n  }\n\n  const emitAndComputeStats = (record: BrowserRecord) => {\n    emit(record)\n    sendToExtension('record', { record })\n    const view = options.viewContexts.findView()!\n    replayStats.addRecord(view.id)\n  }\n\n  const elementsScrollPositions = createElementsScrollPositions()\n\n  const shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions)\n\n  const { stop: stopFullSnapshots } = startFullSnapshots(\n    elementsScrollPositions,\n    shadowRootsController,\n    lifeCycle,\n    configuration,\n    flushMutations,\n    (records) => records.forEach((record) => emitAndComputeStats(record))\n  )\n\n  function flushMutations() {\n    shadowRootsController.flush()\n    mutationTracker.flush()\n  }\n\n  const recordIds = initRecordIds()\n  const mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document)\n  const trackers: Tracker[] = [\n    mutationTracker,\n    trackMove(configuration, emitAndComputeStats),\n    trackMouseInteraction(configuration, emitAndComputeStats, recordIds),\n    trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),\n    trackViewportResize(configuration, emitAndComputeStats),\n    trackInput(configuration, emitAndComputeStats),\n    trackMediaInteraction(configuration, emitAndComputeStats),\n    trackStyleSheet(emitAndComputeStats),\n    trackFocus(configuration, emitAndComputeStats),\n    trackViewportResize(configuration, emitAndComputeStats),\n    trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n    trackViewEnd(lifeCycle, (viewEndRecord) => {\n      flushMutations()\n      emitAndComputeStats(viewEndRecord)\n    }),\n  ]\n\n  return {\n    stop: () => {\n      shadowRootsController.stop()\n      trackers.forEach((tracker) => tracker.stop())\n      stopFullSnapshots()\n    },\n    flushMutations,\n    shadowRootsController,\n  }\n}\n","export type ElementsScrollPositions = ReturnType<typeof createElementsScrollPositions>\nexport type ScrollPositions = { scrollLeft: number; scrollTop: number }\n\nexport function createElementsScrollPositions() {\n  const scrollPositionsByElement = new WeakMap<Element, ScrollPositions>()\n  return {\n    set(element: Element | Document, scrollPositions: ScrollPositions) {\n      if (element === document && !document.scrollingElement) {\n        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n        // in some cases scrolling elements can not be defined, we don't support those for now\n        return\n      }\n      scrollPositionsByElement.set(\n        element === document ? document.scrollingElement! : (element as Element),\n        scrollPositions\n      )\n    },\n    get(element: Element) {\n      return scrollPositionsByElement.get(element)\n    },\n    has(element: Element) {\n      return scrollPositionsByElement.has(element)\n    },\n  }\n}\n","import { LifeCycleEventType, getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core'\nimport type { RumConfiguration, LifeCycle } from '@datadog/browser-rum-core'\nimport { timeStampNow } from '@datadog/browser-core'\nimport type { BrowserRecord } from '../../types'\nimport { RecordType } from '../../types'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { SerializationContextStatus, serializeDocument } from './serialization'\nimport { getVisualViewport } from './viewports'\n\nexport function startFullSnapshots(\n  elementsScrollPositions: ElementsScrollPositions,\n  shadowRootsController: ShadowRootsController,\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  flushMutations: () => void,\n  fullSnapshotCallback: (records: BrowserRecord[]) => void\n) {\n  const takeFullSnapshot = (\n    timestamp = timeStampNow(),\n    serializationContext = {\n      status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT,\n      elementsScrollPositions,\n      shadowRootsController,\n    }\n  ) => {\n    const { width, height } = getViewportDimension()\n    const records: BrowserRecord[] = [\n      {\n        data: {\n          height,\n          href: window.location.href,\n          width,\n        },\n        type: RecordType.Meta,\n        timestamp,\n      },\n      {\n        data: {\n          has_focus: document.hasFocus(),\n        },\n        type: RecordType.Focus,\n        timestamp,\n      },\n      {\n        data: {\n          node: serializeDocument(document, configuration, serializationContext),\n          initialOffset: {\n            left: getScrollX(),\n            top: getScrollY(),\n          },\n        },\n        type: RecordType.FullSnapshot,\n        timestamp,\n      },\n    ]\n\n    if (window.visualViewport) {\n      records.push({\n        data: getVisualViewport(window.visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp,\n      })\n    }\n    return records\n  }\n\n  fullSnapshotCallback(takeFullSnapshot())\n\n  const { unsubscribe } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    flushMutations()\n    fullSnapshotCallback(\n      takeFullSnapshot(view.startClocks.timeStamp, {\n        shadowRootsController,\n        status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT,\n        elementsScrollPositions,\n      })\n    )\n  })\n\n  return {\n    stop: unsubscribe,\n  }\n}\n","export type RecordIds = ReturnType<typeof initRecordIds>\n\nexport function initRecordIds() {\n  const recordIds = new WeakMap<Event, number>()\n  let nextId = 1\n\n  return {\n    getIdForEvent(event: Event): number {\n      if (!recordIds.has(event)) {\n        recordIds.set(event, nextId++)\n      }\n      return recordIds.get(event)!\n    },\n  }\n}\n","import type { Encoder, EncoderResult } from '@datadog/browser-core'\nimport { assign } from '@datadog/browser-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\n\nexport type FlushReason = Exclude<CreationReason, 'init'> | 'stop'\nexport type FlushCallback = (metadata: BrowserSegmentMetadata, encoderResult: EncoderResult<Uint8Array>) => void\nexport type AddRecordCallback = (encodedBytesCount: number) => void\n\nexport class Segment {\n  private metadata: BrowserSegmentMetadata\n  private encodedBytesCount = 0\n\n  constructor(\n    private encoder: Encoder<Uint8Array>,\n    context: SegmentContext,\n    creationReason: CreationReason\n  ) {\n    const viewId = context.view.id\n\n    this.metadata = assign(\n      {\n        start: Infinity,\n        end: -Infinity,\n        creation_reason: creationReason,\n        records_count: 0,\n        has_full_snapshot: false,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser' as const,\n      },\n      context\n    )\n\n    replayStats.addSegment(viewId)\n  }\n\n  addRecord(record: BrowserRecord, callback: AddRecordCallback): void {\n    this.metadata.start = Math.min(this.metadata.start, record.timestamp)\n    this.metadata.end = Math.max(this.metadata.end, record.timestamp)\n    this.metadata.records_count += 1\n    this.metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n\n    const prefix = this.encoder.isEmpty ? '{\"records\":[' : ','\n    this.encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n      this.encodedBytesCount += additionalEncodedBytesCount\n      callback(this.encodedBytesCount)\n    })\n  }\n\n  flush(callback: FlushCallback) {\n    if (this.encoder.isEmpty) {\n      throw new Error('Empty segment flushed')\n    }\n\n    this.encoder.write(`],${JSON.stringify(this.metadata).slice(1)}\\n`)\n    this.encoder.finish((encoderResult) => {\n      replayStats.addWroteData(this.metadata.view.id, encoderResult.rawBytesCount)\n      callback(this.metadata, encoderResult)\n    })\n  }\n}\n","import type { DeflateEncoder, HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumSessionManager, RumConfiguration } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason } from './segment'\nimport { Segment } from './segment'\n\nexport const SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  httpRequest: HttpRequest,\n  encoder: DeflateEncoder\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(configuration.applicationId, sessionManager, viewContexts),\n    httpRequest,\n    encoder\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest,\n  encoder: DeflateEncoder\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    (pageExitEvent) => {\n      flushSegment(pageExitEvent.reason as FlushReason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush((metadata, encoderResult) => {\n        const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount)\n\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      })\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      if (state.status === SegmentCollectionStatus.Stopped) {\n        return\n      }\n\n      if (state.status === SegmentCollectionStatus.WaitingForInitialRecord) {\n        const context = getSegmentContext()\n        if (!context) {\n          return\n        }\n\n        state = {\n          status: SegmentCollectionStatus.SegmentPending,\n          segment: new Segment(encoder, context, state.nextSegmentCreationReason),\n          expirationTimeoutId: setTimeout(() => {\n            flushSegment('segment_duration_limit')\n          }, SEGMENT_DURATION_LIMIT),\n        }\n      }\n\n      state.segment.addRecord(record, (encodedBytesCount) => {\n        if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      })\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n","import type { Payload } from '@datadog/browser-core'\nimport { assign } from '@datadog/browser-core'\nimport type { BrowserSegmentMetadata } from '../../types'\n\nexport type BrowserSegmentMetadataAndSegmentSizes = BrowserSegmentMetadata & {\n  raw_segment_size: number\n  compressed_segment_size: number\n}\n\nexport function buildReplayPayload(\n  data: Uint8Array,\n  metadata: BrowserSegmentMetadata,\n  rawSegmentBytesCount: number\n): Payload {\n  const formData = new FormData()\n\n  formData.append(\n    'segment',\n    new Blob([data], {\n      type: 'application/octet-stream',\n    }),\n    `${metadata.session.id}-${metadata.start}`\n  )\n\n  const metadataAndSegmentSizes: BrowserSegmentMetadataAndSegmentSizes = assign(\n    {\n      raw_segment_size: rawSegmentBytesCount,\n      compressed_segment_size: data.byteLength,\n    },\n    metadata\n  )\n  const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes)\n  formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }))\n\n  return { data: formData, bytesCount: data.byteLength }\n}\n","/**\n * Test for Browser features used while recording\n */\nexport function isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' &&\n    typeof CSSSupportsRule === 'function' &&\n    typeof URL.createObjectURL === 'function' &&\n    'forEach' in NodeList.prototype\n  )\n}\n","import type { RumConfiguration, RumSessionManager, ViewContexts, RumSession } from '@datadog/browser-rum-core'\nimport { getSessionReplayUrl, SessionReplayState } from '@datadog/browser-rum-core'\nimport { isBrowserSupported } from '../boot/isBrowserSupported'\n\nexport function getSessionReplayLink(\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  isRecordingStarted: boolean\n): string | undefined {\n  const session = sessionManager.findTrackedSession()\n  const errorType = getErrorType(session, isRecordingStarted)\n  const viewContext = viewContexts.findView()\n\n  return getSessionReplayUrl(configuration, {\n    viewContext,\n    errorType,\n    session,\n  })\n}\n\nfunction getErrorType(session: RumSession | undefined, isRecordingStarted: boolean) {\n  if (!isBrowserSupported()) {\n    return 'browser-not-supported'\n  }\n  if (!session) {\n    // possibilities:\n    // - rum sampled out\n    // - session expired (edge case)\n    return 'rum-not-tracked'\n  }\n  if (session.sessionReplay === SessionReplayState.OFF) {\n    // possibilities\n    // - replay sampled out\n    return 'incorrect-session-plan'\n  }\n  if (!isRecordingStarted) {\n    return 'replay-not-started'\n  }\n}\n","import type {\n  DeflateWorkerResponse,\n  DeflateEncoder,\n  DeflateEncoderStreamId,\n  DeflateWorker,\n  EncoderResult,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { addEventListener, addTelemetryDebug, assign, concatBuffers } from '@datadog/browser-core'\n\nexport function createDeflateEncoder(\n  configuration: RumConfiguration,\n  worker: DeflateWorker,\n  streamId: DeflateEncoderStreamId\n): DeflateEncoder {\n  let rawBytesCount = 0\n  let compressedData: Uint8Array[] = []\n  let compressedDataTrailer: Uint8Array\n\n  let nextWriteActionId = 0\n  const pendingWriteActions: Array<{\n    writeCallback?: (additionalEncodedBytesCount: number) => void\n    finishCallback?: () => void\n    id: number\n    data: string\n  }> = []\n\n  const { stop: removeMessageListener } = addEventListener(\n    configuration,\n    worker,\n    'message',\n    ({ data: workerResponse }: MessageEvent<DeflateWorkerResponse>) => {\n      if (workerResponse.type !== 'wrote' || (workerResponse.streamId as DeflateEncoderStreamId) !== streamId) {\n        return\n      }\n\n      rawBytesCount += workerResponse.additionalBytesCount\n      compressedData.push(workerResponse.result)\n      compressedDataTrailer = workerResponse.trailer\n\n      const nextPendingAction = pendingWriteActions.shift()\n      if (nextPendingAction && nextPendingAction.id === workerResponse.id) {\n        if (nextPendingAction.writeCallback) {\n          nextPendingAction.writeCallback(workerResponse.result.byteLength)\n        } else if (nextPendingAction.finishCallback) {\n          nextPendingAction.finishCallback()\n        }\n      } else {\n        removeMessageListener()\n        addTelemetryDebug('Worker responses received out of order.')\n      }\n    }\n  )\n\n  function consumeResult(): EncoderResult<Uint8Array> {\n    const output =\n      compressedData.length === 0 ? new Uint8Array(0) : concatBuffers(compressedData.concat(compressedDataTrailer))\n    const result: EncoderResult<Uint8Array> = {\n      rawBytesCount,\n      output,\n      outputBytesCount: output.byteLength,\n      encoding: 'deflate',\n    }\n    rawBytesCount = 0\n    compressedData = []\n    return result\n  }\n\n  function sendResetIfNeeded() {\n    if (nextWriteActionId > 0) {\n      worker.postMessage({\n        action: 'reset',\n        streamId,\n      })\n      nextWriteActionId = 0\n    }\n  }\n\n  return {\n    isAsync: true,\n\n    get isEmpty() {\n      return nextWriteActionId === 0\n    },\n\n    write(data, callback) {\n      worker.postMessage({\n        action: 'write',\n        id: nextWriteActionId,\n        data,\n        streamId,\n      })\n      pendingWriteActions.push({\n        id: nextWriteActionId,\n        writeCallback: callback,\n        data,\n      })\n      nextWriteActionId += 1\n    },\n\n    finish(callback) {\n      sendResetIfNeeded()\n\n      if (!pendingWriteActions.length) {\n        callback(consumeResult())\n      } else {\n        // Make sure we do not call any write callback\n        pendingWriteActions.forEach((pendingWriteAction) => {\n          delete pendingWriteAction.writeCallback\n        })\n\n        // Wait for the last action to finish before calling the finish callback\n        pendingWriteActions[pendingWriteActions.length - 1].finishCallback = () => callback(consumeResult())\n      }\n    },\n\n    finishSync() {\n      sendResetIfNeeded()\n\n      const pendingData = pendingWriteActions\n        .map((pendingWriteAction) => {\n          // Make sure we do not call any write or finish callback\n          delete pendingWriteAction.writeCallback\n          delete pendingWriteAction.finishCallback\n          return pendingWriteAction.data\n        })\n        .join('')\n\n      return assign(consumeResult(), {\n        pendingData,\n      })\n    },\n\n    estimateEncodedBytesCount(data) {\n      // This is a rough estimation of the data size once it'll be encoded by deflate. We observed\n      // that if it's the first chunk of data pushed to the stream, the ratio is lower (3-4), but\n      // after that the ratio is greater (10+). We chose 8 here, which (on average) seems to produce\n      // requests of the expected size.\n      return data.length / 8\n    },\n\n    stop() {\n      removeMessageListener()\n    },\n  }\n}\n","import type { DeflateWorker, DeflateWorkerResponse } from '@datadog/browser-core'\nimport {\n  addTelemetryError,\n  display,\n  includes,\n  addEventListener,\n  setTimeout,\n  ONE_SECOND,\n  DOCS_ORIGIN,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\n\nexport const INITIALIZATION_TIME_OUT_DELAY = 10 * ONE_SECOND\n\ndeclare const __BUILD_ENV__WORKER_STRING__: string\n\n/**\n * In order to be sure that the worker is correctly working, we need a round trip of\n * initialization messages, making the creation asynchronous.\n * These worker lifecycle states handle this case.\n */\nexport const enum DeflateWorkerStatus {\n  Nil,\n  Loading,\n  Error,\n  Initialized,\n}\n\ntype DeflateWorkerState =\n  | {\n      status: DeflateWorkerStatus.Nil\n    }\n  | {\n      status: DeflateWorkerStatus.Loading\n      worker: DeflateWorker\n      stop: () => void\n      initializationFailureCallbacks: Array<() => void>\n    }\n  | {\n      status: DeflateWorkerStatus.Error\n    }\n  | {\n      status: DeflateWorkerStatus.Initialized\n      worker: DeflateWorker\n      stop: () => void\n      version: string\n    }\n\nexport type CreateDeflateWorker = typeof createDeflateWorker\n\nfunction createDeflateWorker(configuration: RumConfiguration): DeflateWorker {\n  return new Worker(configuration.workerUrl || URL.createObjectURL(new Blob([__BUILD_ENV__WORKER_STRING__])))\n}\n\nlet state: DeflateWorkerState = { status: DeflateWorkerStatus.Nil }\n\nexport function startDeflateWorker(\n  configuration: RumConfiguration,\n  source: string,\n  onInitializationFailure: () => void,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  if (state.status === DeflateWorkerStatus.Nil) {\n    // doStartDeflateWorker updates the state to \"loading\" or \"error\"\n    doStartDeflateWorker(configuration, source, createDeflateWorkerImpl)\n  }\n\n  switch (state.status) {\n    case DeflateWorkerStatus.Loading:\n      state.initializationFailureCallbacks.push(onInitializationFailure)\n      return state.worker\n    case DeflateWorkerStatus.Initialized:\n      return state.worker\n  }\n}\n\nexport function resetDeflateWorkerState() {\n  if (state.status === DeflateWorkerStatus.Initialized || state.status === DeflateWorkerStatus.Loading) {\n    state.stop()\n  }\n  state = { status: DeflateWorkerStatus.Nil }\n}\n\nexport function getDeflateWorkerStatus() {\n  return state.status\n}\n\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(\n  configuration: RumConfiguration,\n  source: string,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  try {\n    const worker = createDeflateWorkerImpl(configuration)\n    const { stop: removeErrorListener } = addEventListener(configuration, worker, 'error', (error) => {\n      onError(configuration, source, error)\n    })\n    const { stop: removeMessageListener } = addEventListener(\n      configuration,\n      worker,\n      'message',\n      ({ data }: MessageEvent<DeflateWorkerResponse>) => {\n        if (data.type === 'errored') {\n          onError(configuration, source, data.error, data.streamId)\n        } else if (data.type === 'initialized') {\n          onInitialized(data.version)\n        }\n      }\n    )\n    worker.postMessage({ action: 'init' })\n    setTimeout(() => onTimeout(source), INITIALIZATION_TIME_OUT_DELAY)\n    const stop = () => {\n      removeErrorListener()\n      removeMessageListener()\n    }\n\n    state = { status: DeflateWorkerStatus.Loading, worker, stop, initializationFailureCallbacks: [] }\n  } catch (error) {\n    onError(configuration, source, error)\n  }\n}\n\nfunction onTimeout(source: string) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    display.error(`${source} failed to start: a timeout occurred while initializing the Worker`)\n    state.initializationFailureCallbacks.forEach((callback) => callback())\n    state = { status: DeflateWorkerStatus.Error }\n  }\n}\n\nfunction onInitialized(version: string) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    state = { status: DeflateWorkerStatus.Initialized, worker: state.worker, stop: state.stop, version }\n  }\n}\n\nfunction onError(configuration: RumConfiguration, source: string, error: unknown, streamId?: number) {\n  if (state.status === DeflateWorkerStatus.Loading || state.status === DeflateWorkerStatus.Nil) {\n    display.error(`${source} failed to start: an error occurred while creating the Worker:`, error)\n    if (error instanceof Event || (error instanceof Error && isMessageCspRelated(error.message))) {\n      let baseMessage\n      if (configuration.workerUrl) {\n        baseMessage = `Please make sure the Worker URL ${configuration.workerUrl} is correct and CSP is correctly configured.`\n      } else {\n        baseMessage = 'Please make sure CSP is correctly configured.'\n      }\n      display.error(\n        `${baseMessage} See documentation at ${DOCS_ORIGIN}/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay`\n      )\n    } else {\n      addTelemetryError(error)\n    }\n    if (state.status === DeflateWorkerStatus.Loading) {\n      state.initializationFailureCallbacks.forEach((callback) => callback())\n    }\n    state = { status: DeflateWorkerStatus.Error }\n  } else {\n    addTelemetryError(error, {\n      worker_version: state.status === DeflateWorkerStatus.Initialized && state.version,\n      stream_id: streamId,\n    })\n  }\n}\n\nfunction isMessageCspRelated(message: string) {\n  return (\n    includes(message, 'Content Security Policy') ||\n    // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for\n    includes(message, \"requires 'TrustedScriptURL'\")\n  )\n}\n","// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core'\n\nimport { startRecording } from '../boot/startRecording'\nimport { makeRecorderApi } from '../boot/recorderApi'\nimport { createDeflateEncoder, startDeflateWorker } from '../domain/deflate'\n\nexport {\n  CommonProperties,\n  RumPublicApi as RumGlobal,\n  RumInitConfiguration,\n  // Events\n  RumEvent,\n  RumActionEvent,\n  RumErrorEvent,\n  RumLongTaskEvent,\n  RumResourceEvent,\n  RumViewEvent,\n  RumVitalEvent,\n  // Events context\n  RumEventDomainContext,\n  RumViewEventDomainContext,\n  RumErrorEventDomainContext,\n  RumActionEventDomainContext,\n  RumFetchResourceEventDomainContext,\n  RumXhrResourceEventDomainContext,\n  RumOtherResourceEventDomainContext,\n  RumLongTaskEventDomainContext,\n} from '@datadog/browser-rum-core'\nexport { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nconst recorderApi = makeRecorderApi(startRecording)\nexport const datadogRum = makeRumPublicApi(startRum, recorderApi, { startDeflateWorker, createDeflateEncoder })\n\ninterface BrowserWindow extends Window {\n  DD_RUM?: RumPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_RUM', datadogRum)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils/polyfills'\nimport { display } from '../tools/display'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport interface PublicApi {\n  /**\n   * Version of the Logs browser SDK\n   */\n  version: string\n\n  /**\n   * [For CDN async setup] Early RUM API calls must be wrapped in the `window.DD_RUM.onReady()` callback. This ensures the code only gets executed once the SDK is properly loaded.\n   *\n   * See [CDN async setup](https://docs.datadoghq.com/real_user_monitoring/browser/#cdn-async) for further information.\n   */\n  onReady: (callback: () => void) => void\n}\n\nexport function makePublicApi<T extends PublicApi>(stub: Omit<T, keyof PublicApi>): T {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi as T\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable = global[name] as { q?: Array<() => void>; version?: string } | undefined\n  if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n    display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.')\n  }\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import type { DeflateEncoder } from '@datadog/browser-core'\nimport {\n  DeflateEncoderStreamId,\n  canUseEventBridge,\n  noop,\n  runOnReadyState,\n  PageExitReason,\n  BridgeCapability,\n  bridgeSupports,\n} from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n  StartRecordingOptions,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType, SessionReplayState } from '@datadog/browser-rum-core'\nimport { getReplayStats as getReplayStatsImpl } from '../domain/replayStats'\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink'\nimport type { CreateDeflateWorker } from '../domain/deflate'\nimport {\n  createDeflateEncoder,\n  startDeflateWorker,\n  DeflateWorkerStatus,\n  getDeflateWorkerStatus,\n} from '../domain/deflate'\n\nimport type { startRecording } from './startRecording'\nimport { isBrowserSupported } from './isBrowserSupported'\n\nexport type StartRecording = typeof startRecording\n\nconst enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\ntype RecorderState =\n  | {\n      status: RecorderStatus.Stopped\n    }\n  | {\n      status: RecorderStatus.IntentToStart\n    }\n  | {\n      status: RecorderStatus.Starting\n    }\n  | {\n      status: RecorderStatus.Started\n      stopRecording: () => void\n    }\n\ntype StartStrategyFn = (options?: StartRecordingOptions) => void\n\nexport function makeRecorderApi(\n  startRecordingImpl: StartRecording,\n  createDeflateWorkerImpl?: CreateDeflateWorker\n): RecorderApi {\n  if ((canUseEventBridge() && !bridgeSupports(BridgeCapability.RECORDS)) || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n      getSessionReplayLink: () => undefined,\n    }\n  }\n\n  let state: RecorderState = {\n    status: RecorderStatus.IntentToStart,\n  }\n\n  let startStrategy: StartStrategyFn = () => {\n    state = { status: RecorderStatus.IntentToStart }\n  }\n  let stopStrategy = () => {\n    state = { status: RecorderStatus.Stopped }\n  }\n  let getSessionReplayLinkStrategy = noop as () => string | undefined\n\n  return {\n    start: (options?: StartRecordingOptions) => startStrategy(options),\n    stop: () => stopStrategy(),\n    getSessionReplayLink: () => getSessionReplayLinkStrategy(),\n    onRumStart: (\n      lifeCycle: LifeCycle,\n      configuration: RumConfiguration,\n      sessionManager: RumSessionManager,\n      viewContexts: ViewContexts,\n      worker\n    ) => {\n      if (configuration.startSessionReplayRecordingManually) {\n        state = { status: RecorderStatus.Stopped }\n      }\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          stopStrategy()\n          state = { status: RecorderStatus.IntentToStart }\n        }\n      })\n\n      // Stop the recorder on page unload to avoid sending records after the page is ended.\n      lifeCycle.subscribe(LifeCycleEventType.PAGE_EXITED, (pageExitEvent) => {\n        if (pageExitEvent.reason === PageExitReason.UNLOADING) {\n          stopStrategy()\n        }\n      })\n\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n        if (state.status === RecorderStatus.IntentToStart) {\n          startStrategy()\n        }\n      })\n\n      let cachedDeflateEncoder: DeflateEncoder | undefined\n\n      function getOrCreateDeflateEncoder() {\n        if (!cachedDeflateEncoder) {\n          if (!worker) {\n            worker = startDeflateWorker(\n              configuration,\n              'Datadog Session Replay',\n              () => {\n                stopStrategy()\n              },\n              createDeflateWorkerImpl\n            )\n          }\n          if (worker) {\n            cachedDeflateEncoder = createDeflateEncoder(configuration, worker, DeflateEncoderStreamId.REPLAY)\n          }\n        }\n        return cachedDeflateEncoder\n      }\n\n      startStrategy = (options?: StartRecordingOptions) => {\n        const session = sessionManager.findTrackedSession()\n        if (!session || (session.sessionReplay === SessionReplayState.OFF && !options?.force)) {\n          state = { status: RecorderStatus.IntentToStart }\n          return\n        }\n\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          return\n        }\n\n        state = { status: RecorderStatus.Starting }\n\n        runOnReadyState(configuration, 'interactive', () => {\n          if (state.status !== RecorderStatus.Starting) {\n            return\n          }\n\n          const deflateEncoder = getOrCreateDeflateEncoder()\n          if (!deflateEncoder) {\n            state = {\n              status: RecorderStatus.Stopped,\n            }\n            return\n          }\n\n          const { stop: stopRecording } = startRecordingImpl(\n            lifeCycle,\n            configuration,\n            sessionManager,\n            viewContexts,\n            deflateEncoder\n          )\n          state = {\n            status: RecorderStatus.Started,\n            stopRecording,\n          }\n        })\n\n        if (options?.force && session.sessionReplay === SessionReplayState.OFF) {\n          sessionManager.setForcedReplay()\n        }\n      }\n\n      stopStrategy = () => {\n        if (state.status === RecorderStatus.Stopped) {\n          return\n        }\n\n        if (state.status === RecorderStatus.Started) {\n          state.stopRecording()\n        }\n\n        state = {\n          status: RecorderStatus.Stopped,\n        }\n      }\n\n      getSessionReplayLinkStrategy = () =>\n        getSessionReplayLink(configuration, sessionManager, viewContexts, state.status !== RecorderStatus.Stopped)\n\n      if (state.status === RecorderStatus.IntentToStart) {\n        startStrategy()\n      }\n    },\n\n    isRecording: () =>\n      // The worker is started optimistically, meaning we could have started to record but its\n      // initialization fails a bit later. This could happen when:\n      // * the worker URL (blob or plain URL) is blocked by CSP in Firefox only (Chromium and Safari\n      // throw an exception when instantiating the worker, and IE doesn't care about CSP)\n      // * the browser fails to load the worker in case the workerUrl is used\n      // * an unexpected error occurs in the Worker before initialization, ex:\n      //   * a runtime exception collected by monitor()\n      //   * a syntax error notified by the browser via an error event\n      // * the worker is unresponsive for some reason and timeouts\n      //\n      // It is not expected to happen often. Nonetheless, the \"replayable\" status on RUM events is\n      // an important part of the Datadog App:\n      // * If we have a false positive (we set has_replay: true even if no replay data is present),\n      // we might display broken links to the Session Replay player.\n      // * If we have a false negative (we don't set has_replay: true even if replay data is\n      // available), it is less noticeable because no link will be displayed.\n      //\n      // Thus, it is better to have false negative, so let's make sure the worker is correctly\n      // initialized before advertizing that we are recording.\n      //\n      // In the future, when the compression worker will also be used for RUM data, this will be\n      // less important since no RUM event will be sent when the worker fails to initialize.\n      getDeflateWorkerStatus() === DeflateWorkerStatus.Initialized && state.status === RecorderStatus.Started,\n\n    getReplayStats: (viewId) =>\n      getDeflateWorkerStatus() === DeflateWorkerStatus.Initialized ? getReplayStatsImpl(viewId) : undefined,\n  }\n}\n","import type { RawError, HttpRequest, DeflateEncoder } from '@datadog/browser-core'\nimport { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumConfiguration, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\n\nimport { record } from '../domain/record'\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection'\nimport type { BrowserRecord } from '../types'\nimport { startRecordBridge } from '../domain/startRecordBridge'\n\nexport function startRecording(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  encoder: DeflateEncoder,\n  httpRequest?: HttpRequest\n) {\n  const cleanupTasks: Array<() => void> = []\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n\n  const replayRequest =\n    httpRequest ||\n    createHttpRequest(configuration, configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError)\n\n  let addRecord: (record: BrowserRecord) => void\n\n  if (!canUseEventBridge()) {\n    const segmentCollection = startSegmentCollection(\n      lifeCycle,\n      configuration,\n      sessionManager,\n      viewContexts,\n      replayRequest,\n      encoder\n    )\n    addRecord = segmentCollection.addRecord\n    cleanupTasks.push(segmentCollection.stop)\n  } else {\n    ;({ addRecord } = startRecordBridge(viewContexts))\n  }\n\n  const { stop: stopRecording } = record({\n    emit: addRecord,\n    configuration,\n    lifeCycle,\n    viewContexts,\n  })\n  cleanupTasks.push(stopRecording)\n\n  return {\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n","import { getEventBridge } from '@datadog/browser-core'\nimport type { ViewContexts } from '@datadog/browser-rum-core'\nimport type { BrowserRecord } from '../types'\n\nexport function startRecordBridge(viewContexts: ViewContexts) {\n  const bridge = getEventBridge<'record', BrowserRecord>()!\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      // Get the current active view, not at the time of the record, aligning with the segment logic.\n      // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n      // However the risk is minimal. We could address the issue when potential negative impact are identified.\n      const view = viewContexts.findView()!\n      bridge.send('record', record, view.id)\n    },\n  }\n}\n","import type {\n  Context,\n  TimeStamp,\n  RelativeTime,\n  User,\n  DeflateWorker,\n  DeflateEncoderStreamId,\n  DeflateEncoder,\n  TrackingConsent,\n  PublicApi,\n} from '@datadog/browser-core'\nimport {\n  addTelemetryUsage,\n  timeStampToClocks,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n  CustomerDataType,\n  assign,\n  createContextManager,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  callMonitored,\n  createHandlingStack,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n  createIdentityEncoder,\n  CustomerDataCompressionStatus,\n  createCustomerDataTrackerManager,\n  storeContextManager,\n  displayAlreadyInitializedError,\n  createTrackingConsentState,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewContexts } from '../domain/contexts/viewContexts'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { ReplayStats } from '../rawRumEvent.types'\nimport { ActionType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport type { InternalContext } from '../domain/contexts/internalContext'\nimport { createPreStartStrategy } from './preStartRum'\nimport type { StartRum, StartRumResult } from './startRum'\n\nexport interface StartRecordingOptions {\n  force: boolean\n}\nexport interface RumPublicApi extends PublicApi {\n  /**\n   * Init the RUM browser SDK.\n   * @param initConfiguration Configuration options of the SDK\n   *\n   * See [RUM Browser Monitoring Setup](https://docs.datadoghq.com/real_user_monitoring/browser) for further information.\n   */\n  init: (initConfiguration: RumInitConfiguration) => void\n\n  /**\n   * Set the tracking consent of the current user.\n   *\n   * @param {\"granted\" | \"not-granted\"} trackingConsent The user tracking consent\n   *\n   * Data will be sent only if it is set to \"granted\". This value won't be stored by the library\n   * across page loads: you will need to call this method or set the appropriate `trackingConsent`\n   * field in the init() method at each page load.\n   *\n   * If this method is called before the init() method, the provided value will take precedence\n   * over the one provided as initialization parameter.\n   *\n   * See [User tracking consent](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-tracking-consent) for further information.\n   */\n  setTrackingConsent: (trackingConsent: TrackingConsent) => void\n  /**\n   * Set the global context information to all events, stored in `@context`\n   *\n   * @param context Global context\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  setGlobalContext: (context: any) => void\n\n  /**\n   * Get the global Context\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  getGlobalContext: () => Context\n\n  /**\n   * Set or update a global context property, stored in `@context.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  setGlobalContextProperty: (key: any, value: any) => void\n\n  /**\n   * Remove a global context property\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  removeGlobalContextProperty: (key: any) => void\n\n  /**\n   * Clear the global context\n   *\n   * See [Global context](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#global-context) for further information.\n   */\n  clearGlobalContext: () => void\n\n  /**\n   * [Internal API] Get the internal SDK context\n   */\n  getInternalContext: (startTime?: number) => InternalContext | undefined\n\n  /**\n   * Get the init configuration\n   */\n  getInitConfiguration: () => RumInitConfiguration | undefined\n\n  /**\n   * Add a custom action, stored in `@action`\n   * @param name Name of the action\n   * @param context Context of the action\n   *\n   * See [Send RUM Custom Actions](https://docs.datadoghq.com/real_user_monitoring/guide/send-rum-custom-actions) for further information.\n   */\n  addAction: (name: string, context?: object) => void\n\n  /**\n   * Add a custom error, stored in `@error`.\n   * @param error Error. Favor sending a [Javascript Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) to have a stack trace attached to the error event.\n   * @param context Context of the error\n   *\n   * See [Send RUM Custom Actions](https://docs.datadoghq.com/real_user_monitoring/guide/send-rum-custom-actions) for further information.\n   */\n  addError: (error: unknown, context?: object) => void\n\n  /**\n   * Add a custom timing relative to the start of the current view,\n   * stored in `@view.custom_timings.<timing_name>`\n   *\n   * @param name Name of the custom timing\n   * @param [time] Epoch timestamp of the custom timing (if not set, will use current time)\n   *\n   * Note: passing a relative time is discouraged since it is actually used as-is but displayed relative to the view start.\n   * We currently don't provide a way to retrieve the view start time, so it can be challenging to provide a timing relative to the view start.\n   * see https://github.com/DataDog/browser-sdk/issues/2552\n   */\n  addTiming: (name: string, time?: number) => void\n\n  /**\n   * Set user information to all events, stored in `@usr`\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  setUser: (newUser: User) => void\n\n  /**\n   * Get user information\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  getUser: () => Context\n\n  /**\n   * Set or update the user property, stored in `@usr.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  setUserProperty: (key: any, property: any) => void\n\n  /**\n   * Remove a user property\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  removeUserProperty: (key: any) => void\n\n  /**\n   * Clear all user information\n   *\n   * See [User session](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#user-session) for further information.\n   */\n  clearUser: () => void\n\n  /**\n   * Start a view manually.\n   * Enable to manual start a view, use `trackViewManually: true` init parameter and call `startView()` to create RUM views and be aligned with how you’ve defined them in your SPA application routing.\n   *\n   * @param options.name name of the view\n   * @param options.service service of the view\n   * @param options.version version of the view\n   *\n   * See [Override default RUM view names](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/#override-default-rum-view-names) for further information.\n   */\n  startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  }\n\n  /**\n   * Stop the session. A new session will start at the next user interaction with the page.\n   */\n  stopSession: () => void\n\n  /**\n   * Add a feature flag evaluation,\n   * stored in `@feature_flags.<feature_flag_key>`\n   *\n   * @param {string} key The key of the feature flag.\n   * @param {any} value The value of the feature flag.\n   *\n   * We recommend enabling the intake request compression when using feature flags `compressIntakeRequests: true`.\n   *\n   * See [Feature Flag Tracking](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/) for further information.\n   */\n  addFeatureFlagEvaluation: (key: string, value: any) => void\n\n  /**\n   * Get the Session Replay Link.\n   *\n   * See [Connect Session Replay To Your Third-Party Tools](https://docs.datadoghq.com/real_user_monitoring/guide/connect-session-replay-to-your-third-party-tools) for further information.\n   */\n  getSessionReplayLink: () => string | undefined\n\n  /**\n   * Start Session Replay recording.\n   * Enable to conditionally start the recording, use the `startSessionReplayRecordingManually:true` init parameter and call `startSessionReplayRecording()`\n   *\n   * See [Browser Session Replay](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser) for further information.\n   */\n  startSessionReplayRecording: (options?: StartRecordingOptions) => void\n\n  /**\n   * Stop Session Replay recording.\n   *\n   * See [Browser Session Replay](https://docs.datadoghq.com/real_user_monitoring/session_replay/browser) for further information.\n   */\n  stopSessionReplayRecording: () => void\n}\n\nexport interface RecorderApi {\n  start: (options?: StartRecordingOptions) => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts,\n    deflateWorker: DeflateWorker | undefined\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n  getSessionReplayLink: () => string | undefined\n}\n\nexport interface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n  startDeflateWorker?: (\n    configuration: RumConfiguration,\n    source: string,\n    onInitializationFailure: () => void\n  ) => DeflateWorker | undefined\n  createDeflateEncoder?: (\n    configuration: RumConfiguration,\n    worker: DeflateWorker,\n    streamId: DeflateEncoderStreamId\n  ) => DeflateEncoder\n}\n\nconst RUM_STORAGE_KEY = 'rum'\n\nexport interface Strategy {\n  init: (initConfiguration: RumInitConfiguration, publicApi: RumPublicApi) => void\n  initConfiguration: RumInitConfiguration | undefined\n  getInternalContext: StartRumResult['getInternalContext']\n  stopSession: StartRumResult['stopSession']\n  addTiming: StartRumResult['addTiming']\n  startView: StartRumResult['startView']\n  addAction: StartRumResult['addAction']\n  addError: StartRumResult['addError']\n  addFeatureFlagEvaluation: StartRumResult['addFeatureFlagEvaluation']\n  startDurationVital: StartRumResult['startDurationVital']\n  stopDurationVital: StartRumResult['stopDurationVital']\n}\n\nexport function makeRumPublicApi(\n  startRumImpl: StartRum,\n  recorderApi: RecorderApi,\n  options: RumPublicApiOptions = {}\n): RumPublicApi {\n  const customerDataTrackerManager = createCustomerDataTrackerManager(CustomerDataCompressionStatus.Unknown)\n  const globalContextManager = createContextManager(\n    customerDataTrackerManager.getOrCreateTracker(CustomerDataType.GlobalContext)\n  )\n  const userContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(CustomerDataType.User))\n  const trackingConsentState = createTrackingConsentState()\n\n  function getCommonContext() {\n    return buildCommonContext(globalContextManager, userContextManager, recorderApi)\n  }\n\n  let strategy = createPreStartStrategy(\n    options,\n    getCommonContext,\n    trackingConsentState,\n\n    (configuration, deflateWorker, initialViewOptions) => {\n      if (isExperimentalFeatureEnabled(ExperimentalFeature.CUSTOM_VITALS)) {\n        /**\n         * Start a custom duration vital\n         * stored in @vital.custom.<name>\n         *\n         * @param name name of the custom vital\n         * @param options.context custom context attached to the vital\n         * @param options.startTime epoch timestamp of the start of the custom vital (if not set, will use current time)\n         */\n        ;(rumPublicApi as any).startDurationVital = monitor(\n          (name: string, options?: { context?: object; startTime?: number }) => {\n            strategy.startDurationVital({\n              name: sanitize(name)!,\n              startClocks: options?.startTime ? timeStampToClocks(options.startTime as TimeStamp) : clocksNow(),\n              context: sanitize(options?.context) as Context,\n            })\n            addTelemetryUsage({ feature: 'start-duration-vital' })\n          }\n        )\n\n        /**\n         * Stop a custom duration vital\n         * stored in @vital.custom.<name>\n         *\n         * @param name name of the custom vital\n         * @param options.context custom context attached to the vital\n         * @param options.stopTime epoch timestamp of the stop of the custom vital (if not set, will use current time)\n         */\n        ;(rumPublicApi as any).stopDurationVital = monitor(\n          (name: string, options?: { context?: object; stopTime?: number }) => {\n            strategy.stopDurationVital({\n              name: sanitize(name)!,\n              stopClocks: options?.stopTime ? timeStampToClocks(options.stopTime as TimeStamp) : clocksNow(),\n              context: sanitize(options?.context) as Context,\n            })\n          }\n        )\n      }\n\n      if (configuration.storeContextsAcrossPages) {\n        storeContextManager(configuration, globalContextManager, RUM_STORAGE_KEY, CustomerDataType.GlobalContext)\n        storeContextManager(configuration, userContextManager, RUM_STORAGE_KEY, CustomerDataType.User)\n      }\n\n      customerDataTrackerManager.setCompressionStatus(\n        deflateWorker ? CustomerDataCompressionStatus.Enabled : CustomerDataCompressionStatus.Disabled\n      )\n\n      const startRumResult = startRumImpl(\n        configuration,\n        recorderApi,\n        customerDataTrackerManager,\n        getCommonContext,\n        initialViewOptions,\n        deflateWorker && options.createDeflateEncoder\n          ? (streamId) => options.createDeflateEncoder!(configuration, deflateWorker, streamId)\n          : createIdentityEncoder,\n        trackingConsentState\n      )\n\n      recorderApi.onRumStart(\n        startRumResult.lifeCycle,\n        configuration,\n        startRumResult.session,\n        startRumResult.viewContexts,\n        deflateWorker\n      )\n\n      strategy = createPostStartStrategy(strategy, startRumResult)\n\n      return startRumResult\n    }\n  )\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    strategy.startView(sanitizedOptions)\n    addTelemetryUsage({ feature: 'start-view' })\n  })\n  const rumPublicApi: RumPublicApi = makePublicApi<RumPublicApi>({\n    init: monitor((initConfiguration) => strategy.init(initConfiguration, rumPublicApi)),\n\n    setTrackingConsent: monitor((trackingConsent) => {\n      trackingConsentState.update(trackingConsent)\n      addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent })\n    }),\n\n    setGlobalContext: monitor((context) => {\n      globalContextManager.setContext(context)\n      addTelemetryUsage({ feature: 'set-global-context' })\n    }),\n\n    getGlobalContext: monitor(() => globalContextManager.getContext()),\n\n    setGlobalContextProperty: monitor((key, value) => {\n      globalContextManager.setContextProperty(key, value)\n      addTelemetryUsage({ feature: 'set-global-context' })\n    }),\n\n    removeGlobalContextProperty: monitor((key) => globalContextManager.removeContextProperty(key)),\n\n    clearGlobalContext: monitor(() => globalContextManager.clearContext()),\n\n    getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),\n\n    getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),\n\n    addAction: (name, context) => {\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        strategy.addAction({\n          name: sanitize(name)!,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n          type: ActionType.CUSTOM,\n          handlingStack,\n        })\n        addTelemetryUsage({ feature: 'add-action' })\n      })\n    },\n\n    addError: (error, context) => {\n      const handlingStack = createHandlingStack()\n      callMonitored(() => {\n        strategy.addError({\n          error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n          handlingStack,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n        })\n        addTelemetryUsage({ feature: 'add-error' })\n      })\n    },\n\n    addTiming: monitor((name, time) => {\n      // TODO: next major decide to drop relative time support or update its behaviour\n      strategy.addTiming(sanitize(name)!, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setUser: monitor((newUser) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n      addTelemetryUsage({ feature: 'set-user' })\n    }),\n\n    getUser: monitor(() => userContextManager.getContext()),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n      addTelemetryUsage({ feature: 'set-user' })\n    }),\n\n    removeUserProperty: monitor((key) => userContextManager.removeContextProperty(key)),\n\n    clearUser: monitor(() => userContextManager.clearContext()),\n\n    startView,\n\n    stopSession: monitor(() => {\n      strategy.stopSession()\n      addTelemetryUsage({ feature: 'stop-session' })\n    }),\n\n    addFeatureFlagEvaluation: monitor((key, value) => {\n      strategy.addFeatureFlagEvaluation(sanitize(key)!, sanitize(value))\n      addTelemetryUsage({ feature: 'add-feature-flag-evaluation' })\n    }),\n\n    getSessionReplayLink: monitor(() => recorderApi.getSessionReplayLink()),\n    startSessionReplayRecording: monitor((options?: StartRecordingOptions) => {\n      recorderApi.start(options)\n      addTelemetryUsage({ feature: 'start-session-replay-recording', force: options?.force })\n    }),\n\n    stopSessionReplayRecording: monitor(() => recorderApi.stop()),\n  })\n\n  return rumPublicApi\n}\n\nfunction createPostStartStrategy(preStartStrategy: Strategy, startRumResult: StartRumResult): Strategy {\n  return assign(\n    {\n      init: (initConfiguration: RumInitConfiguration) => {\n        displayAlreadyInitializedError('DD_RUM', initConfiguration)\n      },\n      initConfiguration: preStartStrategy.initConfiguration,\n    },\n    startRumResult\n  )\n}\n","import type { Context, ContextManager, User } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../boot/rumPublicApi'\n\nexport interface CommonContext {\n  user: User\n  context: Context\n  hasReplay: true | undefined\n}\n\nexport function buildCommonContext(\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  recorderApi: RecorderApi\n): CommonContext {\n  return {\n    context: globalContextManager.getContext(),\n    user: userContextManager.getContext(),\n    hasReplay: recorderApi.isRecording() ? true : undefined,\n  }\n}\n","import type {\n  Observable,\n  TelemetryEvent,\n  RawError,\n  DeflateEncoderStreamId,\n  Encoder,\n  CustomerDataTrackerManager,\n  TrackingConsentState,\n} from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageExitObservable,\n  TelemetryService,\n  startTelemetry,\n  canUseEventBridge,\n  getEventBridge,\n  addTelemetryDebug,\n  CustomerDataType,\n  drainPreStartTelemetry,\n} from '@datadog/browser-core'\nimport { createDOMMutationObservable } from '../browser/domMutationObservable'\nimport { startPerformanceCollection } from '../browser/performanceCollection'\nimport { startRumAssembly } from '../domain/assembly'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startViewContexts } from '../domain/contexts/viewContexts'\nimport { startRequestCollection } from '../domain/requestCollection'\nimport { startActionCollection } from '../domain/action/actionCollection'\nimport { startErrorCollection } from '../domain/error/errorCollection'\nimport { startLongTaskCollection } from '../domain/longTask/longTaskCollection'\nimport { startResourceCollection } from '../domain/resource/resourceCollection'\nimport { startViewCollection } from '../domain/view/viewCollection'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager'\nimport { startRumBatch } from '../transport/startRumBatch'\nimport { startRumEventBridge } from '../transport/startRumEventBridge'\nimport { startUrlContexts } from '../domain/contexts/urlContexts'\nimport type { LocationChange } from '../browser/locationChangeObservable'\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/view/trackViews'\nimport { startFeatureFlagContexts } from '../domain/contexts/featureFlagContext'\nimport { startCustomerDataTelemetry } from '../domain/startCustomerDataTelemetry'\nimport { startPageStateHistory } from '../domain/contexts/pageStateHistory'\nimport type { CommonContext } from '../domain/contexts/commonContext'\nimport { startDisplayContext } from '../domain/contexts/displayContext'\nimport { startVitalCollection } from '../domain/vital/vitalCollection'\nimport { startCiVisibilityContext } from '../domain/contexts/ciVisibilityContext'\nimport type { RecorderApi } from './rumPublicApi'\n\nexport type StartRum = typeof startRum\nexport type StartRumResult = ReturnType<StartRum>\n\nexport function startRum(\n  configuration: RumConfiguration,\n  recorderApi: RecorderApi,\n  customerDataTrackerManager: CustomerDataTrackerManager,\n  getCommonContext: () => CommonContext,\n  initialViewOptions: ViewOptions | undefined,\n  createEncoder: (streamId: DeflateEncoderStreamId) => Encoder,\n\n  // `startRum` and its subcomponents assume tracking consent is granted initially and starts\n  // collecting logs unconditionally. As such, `startRum` should be called with a\n  // `trackingConsentState` set to \"granted\".\n  trackingConsentState: TrackingConsentState\n) {\n  const cleanupTasks: Array<() => void> = []\n  const lifeCycle = new LifeCycle()\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event) => sendToExtension('rum', event))\n\n  const telemetry = startRumTelemetry(configuration)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: configuration.applicationId,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: viewContexts.findView()?.id,\n    },\n    action: {\n      id: actionContexts.findActionId(),\n    },\n  }))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n  const featureFlagContexts = startFeatureFlagContexts(\n    lifeCycle,\n    customerDataTrackerManager.getOrCreateTracker(CustomerDataType.FeatureFlag)\n  )\n\n  const pageExitObservable = createPageExitObservable(configuration)\n  const pageExitSubscription = pageExitObservable.subscribe((event) => {\n    lifeCycle.notify(LifeCycleEventType.PAGE_EXITED, event)\n  })\n  cleanupTasks.push(() => pageExitSubscription.unsubscribe())\n\n  const session = !canUseEventBridge()\n    ? startRumSessionManager(configuration, lifeCycle, trackingConsentState)\n    : startRumSessionManagerStub()\n  if (!canUseEventBridge()) {\n    const batch = startRumBatch(\n      configuration,\n      lifeCycle,\n      telemetry.observable,\n      reportError,\n      pageExitObservable,\n      session.expireObservable,\n      createEncoder\n    )\n    cleanupTasks.push(() => batch.stop())\n    startCustomerDataTelemetry(configuration, telemetry, lifeCycle, customerDataTrackerManager, batch.flushObservable)\n  } else {\n    startRumEventBridge(lifeCycle)\n  }\n\n  const domMutationObservable = createDOMMutationObservable()\n  const locationChangeObservable = createLocationChangeObservable(configuration, location)\n\n  const {\n    viewContexts,\n    pageStateHistory,\n    urlContexts,\n    actionContexts,\n    addAction,\n    stop: stopRumEventCollection,\n  } = startRumEventCollection(\n    lifeCycle,\n    configuration,\n    location,\n    session,\n    locationChangeObservable,\n    domMutationObservable,\n    getCommonContext,\n    reportError\n  )\n  cleanupTasks.push(stopRumEventCollection)\n\n  drainPreStartTelemetry()\n\n  startLongTaskCollection(lifeCycle, configuration)\n  startResourceCollection(lifeCycle, configuration, pageStateHistory)\n\n  const {\n    addTiming,\n    startView,\n    stop: stopViewCollection,\n  } = startViewCollection(\n    lifeCycle,\n    configuration,\n    location,\n    domMutationObservable,\n    locationChangeObservable,\n    featureFlagContexts,\n    pageStateHistory,\n    recorderApi,\n    initialViewOptions\n  )\n  cleanupTasks.push(stopViewCollection)\n\n  const { addError } = startErrorCollection(lifeCycle, configuration, pageStateHistory, featureFlagContexts)\n\n  startRequestCollection(lifeCycle, configuration, session)\n  const { stop: stopPerformanceCollection } = startPerformanceCollection(lifeCycle, configuration)\n  cleanupTasks.push(stopPerformanceCollection)\n\n  const vitalCollection = startVitalCollection(lifeCycle, pageStateHistory)\n  const internalContext = startInternalContext(\n    configuration.applicationId,\n    session,\n    viewContexts,\n    actionContexts,\n    urlContexts\n  )\n\n  return {\n    addAction,\n    addError,\n    addTiming,\n    addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,\n    startView,\n    lifeCycle,\n    viewContexts,\n    session,\n    stopSession: () => session.expire(),\n    getInternalContext: internalContext.get,\n    startDurationVital: vitalCollection.startDurationVital,\n    stopDurationVital: vitalCollection.stopDurationVital,\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n\nfunction startRumTelemetry(configuration: RumConfiguration) {\n  const telemetry = startTelemetry(TelemetryService.RUM, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  }\n  return telemetry\n}\n\nexport function startRumEventCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  sessionManager: RumSessionManager,\n  locationChangeObservable: Observable<LocationChange>,\n  domMutationObservable: Observable<void>,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const viewContexts = startViewContexts(lifeCycle)\n  const urlContexts = startUrlContexts(lifeCycle, locationChangeObservable, location)\n\n  const pageStateHistory = startPageStateHistory(configuration)\n\n  const { addAction, actionContexts } = startActionCollection(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    pageStateHistory\n  )\n\n  const displayContext = startDisplayContext(configuration)\n  const ciVisibilityContext = startCiVisibilityContext(configuration)\n\n  startRumAssembly(\n    configuration,\n    lifeCycle,\n    sessionManager,\n    viewContexts,\n    urlContexts,\n    actionContexts,\n    displayContext,\n    ciVisibilityContext,\n    getCommonContext,\n    reportError\n  )\n\n  return {\n    viewContexts,\n    pageStateHistory,\n    urlContexts,\n    addAction,\n    actionContexts,\n    stop: () => {\n      ciVisibilityContext.stop()\n      displayContext.stop()\n      pageStateHistory.stop()\n      urlContexts.stop()\n      viewContexts.stop()\n      pageStateHistory.stop()\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumEventBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'rum', RumEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    bridge.send('rum', serverRumEvent)\n  })\n}\n","import type { RumConfiguration } from '../configuration'\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable'\n\nexport type DisplayContext = ReturnType<typeof startDisplayContext>\n\nexport function startDisplayContext(configuration: RumConfiguration) {\n  let viewport = getViewportDimension()\n  const unsubscribeViewport = initViewportObservable(configuration).subscribe((viewportDimension) => {\n    viewport = viewportDimension\n  }).unsubscribe\n\n  return {\n    get: () => ({ viewport }),\n    stop: unsubscribeViewport,\n  }\n}\n","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongTaskEvent } from '../../rawRumEvent.types'\nimport { RumEventType } from '../../rawRumEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { RumPerformanceEntryType } from '../../browser/performanceCollection'\nimport type { RumConfiguration } from '../configuration'\n\nexport function startLongTaskCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType !== RumPerformanceEntryType.LONG_TASK) {\n        break\n      }\n      if (!configuration.trackLongTasks) {\n        break\n      }\n      const startClocks = relativeToClocks(entry.startTime)\n      const rawRumEvent: RawRumLongTaskEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          duration: toServerDuration(entry.duration),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        domainContext: { performanceEntry: entry },\n      })\n    }\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { ActionContexts } from '../action/actionCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { ViewContexts } from './viewContexts'\nimport type { UrlContexts } from './urlContexts'\n\nexport interface InternalContext {\n  application_id: string\n  session_id: string | undefined\n  view?: {\n    id: string\n    url: string\n    referrer: string\n    name?: string\n  }\n  user_action?: {\n    id: string | string[]\n  }\n}\n\n/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  actionContexts: ActionContexts,\n  urlContexts: UrlContexts\n) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const viewContext = viewContexts.findView(startTime as RelativeTime)\n      const urlContext = urlContexts.findUrl(startTime as RelativeTime)\n      const session = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (session && viewContext && urlContext) {\n        const actionId = actionContexts.findActionId(startTime as RelativeTime)\n        return {\n          application_id: applicationId,\n          session_id: session.id,\n          user_action: actionId ? { id: actionId } : undefined,\n          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n        }\n      }\n    },\n  }\n}\n"],"names":["ConsoleApiName","log","debug","info","warn","error","globalConsole","console","originalConsoleMethods","Object","keys","forEach","name","PREFIX","display","bind","DOCS_ORIGIN","catchUserErrors","fn","errorMsg","args","err","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitor","callMonitored","this","arguments","context","apply","e","displayIfDebugEnabled","includes","candidate","search","indexOf","arrayLike","Array","from","array","Set","item","push","i","length","find","predicate","objectValues","object","map","key","objectEntries","startsWith","slice","target","toAssign","source","prototype","hasOwnProperty","call","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","window","ONE_KIBI_BYTE","ONE_MEBI_BYTE","HAS_MULTI_BYTES_CHARACTERS","computeBytesCount","test","undefined","TextEncoder","encode","Blob","size","getZoneJsOriginalValue","original","browserWindow","Zone","__symbol__","callback","delay","timeoutId","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","cancel","jsonStringify","value","replacer","space","JSON","stringify","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","objectToJson","toJSON","shallowClone","objectHasValue","some","isEmptyObject","CUSTOMER_DATA_BYTES_LIMIT","CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT","BYTES_COMPUTATION_THROTTLING_DELAY","createCustomerDataTrackerManager","compressionStatus","customerDataTrackers","Map","alreadyWarned","checkCustomerDataLimit","initialBytesCount","bytesCountLimit","bytesCount","tracker","getBytesCount","displayCustomerDataLimitReachedWarning","createDetachedTracker","createCustomerDataTracker","getOrCreateTracker","type","has","set","setCompressionStatus","newCompressionStatus","getCompressionStatus","stop","clear","bytesCountCache","computeBytesCountThrottled","cancelComputeBytesCount","resetBytesCount","updateCustomerData","resetCustomerData","getType","isArray","mergeInto","destination","circularReferenceChecker","WeakSet","hasAlreadyBeenSeen","add","createCircularReferenceChecker","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","SANITIZE_DEFAULT_MAX_CHARACTER_COUNT","JSON_PATH_ROOT_ELEMENT","KEY_DECORATION_LENGTH","sanitize","maxCharacterCount","containerQueue","visitedObjectsWithPath","WeakMap","sanitizedData","sanitizeProcessor","accumulatedCharacterCount","containerToProcess","shift","separatorLength","targetData","path","warnOverCharacterLimit","parentPath","queue","sourceToSanitize","tryToApplyToJSON","toString","description","sanitizePrimitivesAndFunctions","sanitizedSource","Event","isTrusted","match","sanitizeObjects","sourceAsObject","currentPath","changeType","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","filter","other","notify","data","observer","mergeObservables","Observable","globalObservable","subscriptions","observables","observable","subscription","createContextManager","customerDataTracker","changeObservable","contextManager","getContext","setContext","newContext","clearContext","setContextProperty","property","removeContextProperty","ExperimentalFeature","TrackingConsent","GRANTED","NOT_GRANTED","enabledExperimentalFeatures","initFeatureFlags","enableExperimentalFeatures","flag","isExperimentalFeatureEnabled","featureName","getExperimentalFeatures","performDraw","threshold","Math","random","round","num","decimals","toFixed","isPercentage","isNumber","navigationStart","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_YEAR","relativeToClocks","relative","timeStamp","getCorrectedTimeStamp","timeStampToClocks","getRelativeTime","relativeTime","correctedOrigin","dateNow","performance","now","getNavigationStart","addDuration","getTimeStamp","toServerDuration","duration","relativeNow","clocksNow","clocksOrigin","elapsed","start","end","a","b","timestamp","timing","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","split","line","stackFrame","parts","CHROME_LINE_RE","exec","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","url","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","computeStackTraceFromOnErrorMessage","messageObj","ERROR_TYPES_RE","tryToParseMessage","createHandlingStack","formattedStack","Error","stackTrace","toStackTraceString","result","formatErrorMessage","frame","NO_ERROR_STACK_PRESENT_MESSAGE","computeRawError","originalError","handlingStack","startClocks","nonErrorPrefix","handling","isErrorInstance","computeMessage","hasUsableStack","causes","flattenErrorCauses","fingerprint","tryToGetFingerprint","dd_fingerprint","parentSource","currentError","cause","INTAKE_SITE_STAGING","INTAKE_SITE_FED_STAGING","INTAKE_SITE_US1","INTAKE_SITE_EU1","PCI_INTAKE_HOST_US1","sendToExtension","payload","__ddBrowserSdkExtensionCallback","getConnectivity","navigator","status","onLine","interfaces","connection","effective_type","effectiveType","removeItem","index","splice","buffer","remove","drain","arg","TelemetryType","configuration","usage","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","preStartTelemetryBuffer","onRawTelemetryEventCollected","event","startTelemetry","telemetryService","contextProvider","alreadySentEvents","telemetryEnabled","site","telemetrySampleRate","telemetryEnabledPerType","telemetryConfigurationSampleRate","telemetryUsageSampleRate","runtimeEnvInfo","is_local_file","location","protocol","is_worker","rawEvent","stringifiedEvent","maxTelemetryEventsPerPage","date","service","version","_dd","format_version","telemetry","runtime_env","connectivity","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","enabled","addTelemetryDebug","kind","scrubCustomerFrames","formatError","addTelemetryUsage","allowedFrameUrl","addEventListener","eventTarget","eventName","listener","eventNames","once","capture","passive","listenerWithMonitor","__ddIsTrusted","allowUntrustedEvents","DOM_EVENT","CONTEXT_STORE_KEY_PREFIX","storageListeners","storeContextManager","productKey","customerDataType","storageKey","buildStorageKey","getFromStorage","rawContext","localStorage","getItem","parse","STORAGE","setItem","createIdentityEncoder","output","outputBytesCount","isAsync","isEmpty","write","additionalEncodedBytesCount","finish","finishSync","rawBytesCount","pendingData","estimateEncodedBytesCount","sanitizeUser","newUser","user","displayAlreadyInitializedError","sdkName","initConfiguration","silentMultipleInit","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getCapabilities","getPrivacyLevel","getAllowedWebViewHosts","send","eventType","viewId","view","id","bridgeSupports","capability","bridge","canUseEventBridge","currentHost","hostname","allowedHost","generateUUID","placeholder","parseInt","replace","initCookieParsed","getCurrentSiteCache","COMMA_SEPARATED_KEY_VALUE","findCommaSeparatedValue","rawString","lastIndex","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","setCookie","_expireDelay","_options","sessionStorage","getCookie","getInitCookie","findCommaSeparatedValues","document","cookie","deleteCookie","browserCache","SYNTHETICS_TEST_ID_COOKIE_NAME","SYNTHETICS_RESULT_ID_COOKIE_NAME","SYNTHETICS_INJECTS_RUM_COOKIE_NAME","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","detectBrowserCached","userAgent","chrome","vendor","documentMode","detectBrowser","SESSION_STORE_KEY","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","EXPIRED","getExpiredSessionState","isExpired","isSessionInNotStartedState","session","isSessionStarted","isSessionInExpiredState","sessionState","created","Number","expire","expandSessionState","toSessionString","toSessionState","sessionString","isValidSessionString","entry","matches","OLD_SESSION_COOKIE_NAME","OLD_RUM_COOKIE_NAME","OLD_LOGS_COOKIE_NAME","RUM_SESSION_KEY","LOGS_SESSION_KEY","selectCookieStrategy","cookieOptions","secure","useSecureSessionCookie","usePartitionedCrossSiteSessionCookie","useCrossSiteSessionCookie","crossSite","partitioned","trackSessionAcrossSubdomains","domain","testCookieName","domainLevels","candidateDomain","pop","getCurrentSite","buildCookieOptions","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","initCookieStrategy","cookieStore","isLockEnabled","persistSession","retrieveSession","retrieveSessionCookie","expireSession","cookieStoreStrategy","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","LOCAL_STORAGE_TEST_KEY","persistInLocalStorage","retrieveSessionFromLocalStorage","expireSessionFromLocalStorage","ongoingOperations","LOCK_RETRY_DELAY","LOCK_MAX_TRIES","bufferedOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","persistWithLock","lock","currentLock","retrieveStore","next","currentStore","retryLater","processedSession","process","after","sessionStore","currentNumberOfRetries","nextOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","sessionStoreStrategyType","allowFallbackToLocalStorage","testKey","retrievedId","selectLocalStorageStrategy","startSessionStore","computeSessionState","sessionCache","renewObservable","expireObservable","sessionStateUpdateObservable","watchSessionTimeoutId","synchronizeSession","startSession","synchronizedSession","trackingType","isTracked","expandOrRenewSessionState","hasSessionInCache","renewSessionInCache","throttledExpandOrRenewSession","cancelExpandOrRenewSession","isSessionInCacheOutdated","previousState","newState","expandOrRenewSession","expandSession","getSession","restartSession","updateSessionState","partialSessionState","normalizeUrl","buildUrl","href","base","supportedURL","isURLSupported","originalURL","getSupportedUrl","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","URL","createEndpointBuilder","trackType","configurationTags","buildUrlWithParameters","proxy","encodeURIComponent","host","internalAnalyticsSubdomain","usePciIntake","domainParts","extension","buildEndpointHost","createEndpointUrlWithParametersBuilder","build","api","clientToken","retry","encoding","tags","concat","count","lastFailureStatus","reverse","buildEndpointParameters","urlPrefix","TAG_SIZE_LIMIT","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","env","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeUrlPrefixes","builder","computeIntakeUrlPrefixes","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","DefaultPrivacyLevel","ALLOW","MASK","MASK_USER_INPUT","TraceContextInjection","ALL","SAMPLED","checkIfString","tag","tagName","isMatchOption","itemType","matchList","list","useStartsWith","clearTracingIfNeeded","isAborted","traceId","spanId","traceSampled","injectHeadersIfTracingAllowed","sessionManager","inject","getCrypto","findTrackedSession","propagatorTypes","tracingHeaders","tracingOption","allowedTracingUrls","traceSampleRate","traceContextInjection","TraceIdentifier","propagatorType","toDecimalString","traceparent","toPaddedHexadecimalString","b3","crypto","msCrypto","Uint8Array","getRandomValues","radix","high","readInt32","low","str","mod","floor","offset","DEFAULT_PROPAGATOR_TYPES","validateAndBuildRumConfiguration","sessionReplaySampleRate","excludedActivityUrls","option","expectedItem","validateAndBuildTracingOptions","baseConfiguration","sessionSampleRate","trackingConsent","beforeSend","storeContextsAcrossPages","batchBytesLimit","eventRateLimiterThreshold","flushTimeout","batchMessagesLimit","messageBytesLimit","validateAndBuildConfiguration","actionNameAttribute","startSessionReplayRecordingManually","workerUrl","compressIntakeRequests","trackUserInteractions","trackViewsManually","trackResources","trackLongTasks","subdomain","defaultPrivacyLevel","enablePrivacyForActionName","customerDataTelemetrySampleRate","plugins","PLUGINS","getSelectedTracingPropagators","usedTracingPropagators","REMOTE_CONFIGURATION_URL","fetchAndApplyRemoteConfiguration","xhr","XMLHttpRequest","responseText","displayRemoteConfigurationFetchingError","open","remoteConfigurationId","fetchRemoteConfiguration","remoteInitConfiguration","applyRemoteConfiguration","createPreStartStrategy","getCommonContext","trackingConsentState","doStartRum","firstStartViewCall","deflateWorker","cachedInitConfiguration","cachedConfiguration","ignoreInitIfSyntheticsWillInjectRum","startDeflateWorker","bufferApiCalls","trackingConsentStateSubscription","tryStartRum","isGranted","initialViewOptions","startRumResult","doInit","eventBridgeAvailable","overrideInitConfigurationForBridge","addTelemetryConfiguration","baseSerializedConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","telemetry_usage_sample_rate","use_before_send","use_cross_site_session_cookie","use_partitioned_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","allow_fallback_to_local_storage","store_contexts_across_pages","allow_untrusted_events","tracking_consent","session_replay_sample_rate","start_session_replay_recording_manually","trace_sample_rate","trace_context_injection","action_name_attribute","use_allowed_tracing_urls","selected_tracing_propagators","default_privacy_level","enable_privacy_for_action_name","use_excluded_activity_urls","use_worker_url","compress_intake_requests","track_views_manually","track_user_interactions","track_resources","track_long_task","plugin","getConfigurationTelemetry","serializeRumConfiguration","tryToInit","init","publicApi","methodName","parameter","method","callPluginsMethod","REMOTE_CONFIGURATION","getInternalContext","stopSession","addTiming","time","startView","addAction","action","commonContext","addError","providedError","addFeatureFlagEvaluation","startDurationVital","vitalStart","stopDurationVital","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","isPageExitReason","reason","getMutationObserverConstructor","constructor","MutationObserver","originalInstance","runOnReadyState","expectedReadyState","readyState","LOAD","DOM_CONTENT_LOADED","FAKE_INITIAL_DOCUMENT","RESOURCE_TYPES","initiatorType","_","computeResourceKind","isValidUrl","pathname","getPathName","isType","areInOrder","numbers","computePerformanceResourceDetails","isValidEntry","startTime","fetchStart","redirectStart","redirectEnd","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","details","download","formatTiming","first_byte","connect","ssl","dns","redirect","TOLERANT_RESOURCE_TIMINGS","areCommonTimingsInOrder","responseEnd","areRedirectionTimingsInOrder","hasRedirection","origin","computeSize","encodedBodySize","decodedBodySize","encoded_body_size","decoded_body_size","transfer_size","isAllowedRequestUrl","DATA_URL_REGEX","MAX_ATTRIBUTE_VALUE_CHAR_LENGTH","isLongDataUrl","substring","sanitizeDataUrl","isTextNode","node","nodeType","Node","TEXT_NODE","isElementNode","ELEMENT_NODE","isNodeShadowHost","shadowRoot","isNodeShadowRoot","DOCUMENT_FRAGMENT_NODE","forEachChildNodes","child","firstChild","nextSibling","getParentNode","parentNode","RumPerformanceEntryType","INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD","getDocumentTraceId","traceIdMeta","querySelector","traceTimeMeta","createDocumentTraceData","content","getDocumentTraceDataFromMeta","comment","childNodes","getTraceCommentFromNode","findTraceComment","getDocumentTraceDataFromComment","traceTime","rawTraceTime","COMMENT_NODE","isCommentNode","supportPerformanceObject","supportPerformanceTimingEvent","entryType","PerformanceObserver","supportedEntryTypes","startPerformanceCollection","lifeCycle","cleanupTasks","forcedAttributes","RESOURCE","NAVIGATION","getEntriesByType","navigationEntry","relativePerformanceTiming","computeRelativePerformanceTiming","transferSize","renderBlockingStatus","retrieveInitialDocumentResourceTiming","handleRumPerformanceEntries","getEntries","entries","mainEntries","LONG_TASK","PAINT","experimentalEntries","LARGEST_CONTENTFUL_PAINT","FIRST_INPUT","LAYOUT_SHIFT","EVENT","observe","buffered","durationThreshold","disconnect","entryTypes","removePerformanceListener","clearResourceTimings","sendFakeTiming","retrieveNavigationTiming","stopFirstInputTiming","startTimeStamp","timingSent","removeEventListeners","CLICK","MOUSE_DOWN","KEY_DOWN","TOUCH_START","POINTER_DOWN","evt","cancelable","processingStart","processingEnd","sendTimingIfPointerIsNotCancelled","sendTiming","POINTER_UP","POINTER_CANCEL","retrieveFirstInputTiming","task","numberKey","timingElement","rumAllowedPerformanceEntries","loadEventEnd","isIncompleteNavigation","isForbiddenResource","ErrorSource","AGENT","CONSOLE","CUSTOM","LOGGER","NETWORK","SOURCE","REPORT","createEventRateLimiter","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","getSyntheticsContext","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","_DATADOG_SYNTHETICS_RESULT_ID","getSyntheticsResultId","test_id","result_id","injected","limitModification","modifiableFieldPaths","modifier","clone","fieldPath","fieldType","newValue","current","field","isValidObjectContaining","newType","fields","isValidObject","modifiableFieldPathsByEvent","VIEW_MODIFIABLE_FIELD_PATHS","USER_CUSTOMIZABLE_FIELD_PATHS","ROOT_MODIFIABLE_FIELD_PATHS","startRumAssembly","viewContexts","urlContexts","actionContexts","displayContext","ciVisibilityContext","reportError","WRITABLE_RESOURCE_GRAPHQL","eventRateLimiters","syntheticsContext","rawRumEvent","domainContext","savedCommonContext","customerContext","viewContext","findView","urlContext","findUrl","actionId","findActionId","serverRumEvent","drift","browser_sdk_version","application","referrer","synthetics","ci_test","has_replay","hasReplay","sampled_for_replay","sessionReplay","usr","rateLimitReached","shouldSend","xhrObservable","LifeCycle","callbacks","eventCallbacks","END_OF_TIMES","Infinity","CLEAR_OLD_VALUES_INTERVAL","expireDelay","maxEntries","clearOldValuesInterval","clearOldValues","endTime","close","unshift","returnInactive","closeActive","latestEntry","findAll","reset","oldTimeThreshold","VIEW_CONTEXT_TIME_OUT_DELAY","instrumentMethod","targetPrototype","onPreCall","computeHandlingStack","stopped","instrumentation","postCallCallback","onPostCall","instrumentSetter","originalDescriptor","getOwnPropertyDescriptor","stoppedInstrumentation","instrumentationWrapper","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","openXhr","stopInstrumentingSend","startContext","state","hasBeenReported","stopInstrumentingOnReadyStateChange","DONE","onEnd","unsubscribeLoadEndListener","completeContext","sendXhr","stopInstrumentingAbort","abortXhr","createXhrObservable","toUpperCase","initFetchObservable","fetch","input","methodFromParams","Request","responsePromise","reportFetch","response","DOMException","code","ABORT_ERR","responseType","then","afterSend","nextRequestIndex","startRequestCollection","tracer","traceFetch","headers","append","Headers","header","traceXhr","setRequestHeader","startTracer","requestIndex","getNextRequestIndex","trackXhr","clonedResponse","tryToClone","stream","reader","getReader","chunks","readBytesCount","onDone","bytes","limitExceeded","catch","collectStreamBody","chunk","bytesLimit","readMore","read","done","readBytesFromStream","POSITIVE_INFINITY","waitForResponseToComplete","trackFetch","discardNegativeDuration","trackEventCounts","isChildEvent","onChange","eventCounts","errorCount","longTaskCount","resourceCount","actionCount","frustrationCount","frustration","discarded","PAGE_ACTIVITY_VALIDATION_DELAY","PAGE_ACTIVITY_END_DELAY","waitPageActivityEnd","domMutationObservable","pageActivityEndCallback","maxDuration","pageActivityObservable","firstRequestIndex","pendingRequestsCount","notifyPageActivity","isExcludedUrl","startEvent","request","stopTrackingWindowOpen","s","isBusy","createPageActivityObservable","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","complete","hadActivity","maxDurationTimeoutId","pageActivitySubscription","lastChangeTime","doWaitPageActivityEnd","requestUrl","cssEscape","CSS","escape","ch","asCodePoint","elementMatches","element","selector","msMatchesSelector","getParentElement","parentElement","initialValues","delete","NodePrivacyLevel","IGNORE","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_HIDDEN","PRIVACY_CLASS_PREFIX","CENSORED_STRING_MARK","CENSORED_IMG_MARK","FORM_PRIVATE_TAG_NAMES","INPUT","OUTPUT","TEXTAREA","SELECT","OPTION","DATALIST","OPTGROUP","getNodePrivacyLevel","cache","parentNodePrivacyLevel","nodePrivacyLevel","reducePrivacyLevel","getNodeSelfPrivacyLevel","childPrivacyLevel","inputElement","autocomplete","getAttribute","getPrivacySelector","nodeName","relAttribute","getLowerCaseAttribute","nameAttribute","propertyAttribute","hasAttribute","toLowerCase","shouldIgnoreElement","shouldMaskNode","privacyLevel","isFormElement","censorText","text","getTextContent","textNode","ignoreWhiteSpace","parentTagName","textContent","trim","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","ACTION_NAME_PLACEHOLDER","getActionNameFromElement","userProgrammaticAttribute","defaultActionName","getActionNameFromElementProgrammatically","getActionNameFromElementForStrategies","priorityStrategies","fallbackStrategies","targetElement","programmaticAttribute","elementWithAttribute","supportsElementClosestResult","HTMLElement","supportsElementClosest","closest","truncate","normalizeWhitespace","supportsLabelPropertyResult","privacy","HTMLInputElement","supportsLabelProperty","labels","getTextualContent","label","ownerDocument","querySelectorAll","htmlFor","privacyEnabledActionName","labelledByAttribute","refElement","getElementById","MAX_PARENTS_TO_CONSIDER","strategies","recursionCounter","strategy","trimmedName","isContentEditable","innerText","removeTextFromElements","query","textToReplace","supportScopeSelectorCache","STABLE_ATTRIBUTES","GLOBALLY_UNIQUE_SELECTOR_GETTERS","getStableAttributeSelector","isGeneratedValue","UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS","classList","classes","getClassList","className","getSelectorFromElement","isConnected","documentElement","contains","targetElementSelector","currentElement","globallyUniqueSelector","findSelector","isSelectorUniqueGlobally","isSelectorUniqueAmongSiblings","combineSelector","getPositionSelector","getAttributeSelector","attributeName","sibling","firstElementChild","elementIndex","nextElementSibling","selectorGetters","childSelector","elementSelector","selectorGetter","currentElementSelector","isSiblingMatching","supportScopeSelector","parent","MAX_DURATION_BETWEEN_CLICKS","MAX_DISTANCE_BETWEEN_CLICKS","createClickChain","firstClick","onFinalize","maxDurationBetweenClicksTimeoutId","bufferedClicks","appendClick","click","stopObservable","tryFinalize","dontAcceptMoreClick","every","isStopped","tryAppend","first","second","sqrt","pow","clientX","clientY","isSelectionEmpty","selection","getSelection","isCollapsed","isValidPointerEvent","Element","isPrimary","MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE","computeFrustration","clicks","rageClick","getUserActivity","scroll","isRage","addFrustration","isDead","hasError","hasSelectionChanged","DEAD_CLICK_EXCLUDE_SELECTOR","hasPageActivity","CLICK_ACTION_MAX_DURATION","ACTION_CONTEXT_TIME_OUT_DELAY","trackClickActions","currentClickChain","history","ValueHistory","stopClickChain","stopActionEventsListener","selectionEmptyAtPointerDown","clickContext","onPointerDown","onPointerUp","userActivity","listeners","SELECTION_CHANGE","SCROLL","listenActionEvents","pointerDownEvent","clickActionBase","rect","getBoundingClientRect","width","height","position","x","left","y","top","computeClickActionBase","hadActivityOnPointerDown","pageActivityEndEvent","processPointerDown","appendClickToClickChain","newClick","stopWaitPageActivityEnd","discard","viewEndedSubscription","endClocks","stopSubscription","startClickAction","validate","finalizeClicks","activityEndTime","historyEntry","eventCountsSubscription","frustrationTypes","newActivityEndTime","frustrationType","domEvents","clickAction","counts","events","processAction","pageStateHistory","autoActionProperties","isAutoAction","loading_time","long_task","resource","actionEvent","in_foreground","wasInPageStateAt","trackRuntimeError","errorObservable","handleRuntimeError","rawError","stopInstrumentingOnError","errorObj","stopInstrumentingOnUnhandledRejection","instrumentUnhandledRejection","consoleObservablesByApi","initConsoleObservable","apis","consoleObservables","originalConsoleApi","params","param","formatConsoleParameters","firstErrorParam","buildConsoleLog","createConsoleObservable","RawReportType","intervention","deprecation","cspViolation","initReportObservable","SECURITY_POLICY_VIOLATION","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","originalReport","buildRawReportFromCspViolation","createCspViolationReportObservable","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportFromReport","types","createReportObservable","startErrorCollection","featureFlagContexts","consoleError","trackConsoleError","csp","disposition","trackReportError","handling_stack","source_type","featureFlagContext","findFeatureFlagEvaluations","feature_flags","processError","doStartErrorCollection","alreadyMatchedEntries","matchRequestTiming","sameNameEntries","getEntriesByName","candidates","errorMargin","startResourceCollection","matchingTiming","tracingInfo","hasBeenTraced","span_id","trace_id","rule_psr","getRulePsr","computeRequestTracingInfo","correspondingTimingOverrides","computePerformanceEntryMetrics","wasInPageStateDuringPeriod","computeRequestDuration","resourceEvent","status_code","performanceEntry","requestInput","requestInit","processRequest","processResourceEntry","computeEntryTracingInfo","statusCode","entryMetrics","responseStatus","render_blocking_status","FCP_MAXIMUM_DELAY","LCP_MAXIMUM_DELAY","trackInitialViewMetrics","setLoadEvent","scheduleViewUpdate","initialViewMetrics","stopNavigationTracking","domComplete","domContentLoaded","domContentLoadedEventEnd","domInteractive","loadEvent","firstByte","trackNavigationTimings","navigationTimings","firstHidden","stopListeners","visibilityState","PAGE_HIDE","VISIBILITY_CHANGE","trackFirstHidden","stopFCPTracking","fcpEntry","trackFirstContentfulPaint","firstContentfulPaint","stopLCPTracking","firstInteractionTimestamp","stopEventListener","biggestLcpSize","unsubscribeLifeCycle","lcpEntry","findLast","lcpTargetSelector","targetSelector","trackLargestContentfulPaint","largestContentfulPaint","stopFIDTracking","firstInputEntry","firstInputDelay","firstInputTargetSelector","trackFirstInput","firstInput","trackCumulativeLayoutShift","viewStart","maxClsTarget","maxClsStartTime","maxClsValue","cumulatedValue","maxValue","update","isMaxValue","MAX_UPDATE_GAP","MAX_WINDOW_DURATION","slidingSessionWindow","hadRecentInput","getTargetFromSource","WeakRef","deref","interactionCountEstimate","minKnownInteractionId","maxKnownInteractionId","viewportObservable","getInteractionCount","interactionCount","MAX_INTERACTION_ENTRIES","MAX_INP_VALUE","trackInteractionToNextPaint","viewLoadingType","PerformanceEventTiming","getInteractionToNextPaint","setViewEnd","interactionToNextPaintTargetSelector","interactionToNextPaintStartTime","interactionId","min","max","previousInteractionCount","computeViewInteractionCount","getViewInteractionCount","stopViewInteractionCount","trackViewInteractionCount","viewEnd","longestInteractions","sortAndTrimLongestInteractions","sort","interactionIndex","findIndex","interaction","minLongestInteraction","estimateP98Interaction","trackLongestInteractions","interactionToNextPaint","viewEndTime","newInteraction","getScrollX","scrollX","visual","visualViewport","pageLeft","offsetLeft","pageXOffset","getScrollY","scrollY","pageTop","offsetTop","pageYOffset","initViewportObservable","updateDimension","getViewportDimension","RESIZE","createViewportObservable","scale","innerWidth","innerHeight","THROTTLE_SCROLL_DURATION","trackScrollMetrics","scrollValues","throttleDuration","scrollTop","scrollHeight","scrollDepth","scrollingElement","ResizeObserver","unobserve","createScrollValuesObservable","maxScrollDepth","maxScrollHeight","maxScrollHeightTime","shouldUpdate","maxDepth","maxDepthScrollTop","trackCommonViewMetrics","loadingType","commonViewMetrics","loadType","isWaitingForLoadEvent","isWaitingForActivityLoadingTime","loadingTimeCandidates","invokeCallbackIfAllCandidatesAreReceived","trackLoadingTime","newLoadingTime","loadingTime","stopLoadingTimeTracking","stopScrollMetricsTracking","newScrollMetrics","stopCLSTracking","cumulativeLayoutShift","stopINPTracking","getCommonViewMetrics","THROTTLE_VIEW_UPDATE_PERIOD","SESSION_KEEP_ALIVE_INTERVAL","KEEP_TRACKING_AFTER_VIEW_DELAY","trackViews","locationChangeObservable","areViewsTrackedAutomatically","locationChangeSubscription","activeViews","currentView","startNewView","viewOptions","newlyCreatedView","initialLocation","customTimings","documentVersion","sessionIsActive","viewCreatedEvent","triggerViewUpdate","cancelScheduleViewUpdate","stopCommonViewMetricsTracking","stopInitialViewMetricsTracking","trackViewEventCounts","stopEventCountsTracking","keepAliveIntervalId","currentEnd","isActive","looksLikeRelativeTime","sanitized","sanitizeTiming","newView","pageExitEvent","currentLocation","otherLocation","hash","correspondingId","oldLocation","newLocation","getPathFromHash","renewViewOnLocationChange","startViewCollection","recorderApi","replayStats","getReplayStats","pageStates","viewEvent","document_version","replay_stats","page_states","cumulative_layout_shift","cumulative_layout_shift_time","cumulative_layout_shift_target_selector","dom_complete","dom_content_loaded","dom_interactive","first_contentful_paint","first_input_delay","first_input_time","first_input_target_selector","interaction_to_next_paint","interaction_to_next_paint_time","interaction_to_next_paint_target_selector","is_active","largest_contentful_paint","largest_contentful_paint_target_selector","load_event","loading_type","time_spent","max_depth","max_depth_scroll_top","max_scroll_height","max_scroll_height_time","replay_level","custom_timings","newObject","mapValues","processViewUpdate","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","stopCallbacks","startSessionManager","sessionContextHistory","buildSessionContext","isReplayForced","forcedReplay","trackActivity","expandSessionWhenVisible","visibilityCheckInterval","trackVisibility","cb","RESUME","trackResume","findSession","startRumSessionManager","rawTrackingType","hasValidRumSession","isTypeTracked","sessionEntity","setForcedReplay","rumSessionType","encoder","flushController","upsertBuffer","flushSubscription","flushObservable","flush","addOrUpdate","upsert","upsertMessages","isPageExit","sendOnExit","encoderResult","formatPayloadFromEncoder","pendingMessages","serializedMessage","estimatedMessageBytesCount","hasMessageFor","notifyBeforeAddMessage","notifyAfterAddMessage","realMessageBytesCount","removedMessage","messageBytesCount","notifyAfterRemoveMessage","MAX_ONGOING_BYTES_COUNT","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","MAX_BACKOFF_TIME","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","sendStrategy","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","dequeue","currentBackoffTime","shouldRetryRequest","ongoingRequestCount","isFull","queueFullReported","previousQueue","newPayloadQueue","createHttpRequest","endpointBuilder","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","canUseKeepAlive","isKeepAliveSupported","fetchUrl","keepalive","mode","xhrUrl","sendXHR","fetchKeepAliveStrategy","canUseBeacon","sendBeacon","beaconUrl","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","createFlushController","durationLimitTimeoutId","messagesLimit","durationLimit","pageExitObservable","sessionExpireObservable","pageExitSubscription","sessionExpireSubscription","currentBytesCount","currentMessagesCount","flushReason","messagesCount","cancelDurationLimitTimeout","messageBytesCountDiff","startRumBatch","telemetryEventObservable","createEncoder","batch","primary","primaryBatch","createBatch","replicaBatch","endpoint","Batch","replicated","transformMessage","startBatchWithReplica","isTelemetryReplicationAllowed","URL_CONTEXT_TIME_OUT_DELAY","createLocationChangeObservable","stopHistoryTracking","onHistoryChange","stopInstrumentingPushState","stopInstrumentingReplaceState","removeListener","POP_STATE","trackHistory","onLocationChange","stopHashTracking","onHashChange","HASH_CHANGE","trackHash","FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY","currentPeriodMeasures","currentBatchMeasures","batchHasRumEvent","MEASURES_PERIOD_DURATION","sendCurrentPeriodMeasures","batchCount","initCurrentPeriodMeasures","updateMeasure","measure","sum","mergeMeasure","batchBytesCount","batchMessagesCount","globalContextBytes","userContextBytes","featureFlagBytes","initCurrentBatchMeasures","MAX_PAGE_STATE_ENTRIES","MAX_PAGE_STATE_ENTRIES_SELECTABLE","PAGE_STATE_CONTEXT_TIME_OUT_DELAY","startPageStateHistory","maxPageStateEntriesSelectable","currentPageState","pageStateEntryHistory","addPageState","getPageState","stopEventListeners","PAGE_SHOW","FOCUS","BLUR","FREEZE","persisted","computePageState","nextPageState","eventStartTime","pageStateEntries","pageStateServerEntries","pageState","relativeStartTime","hasFocus","startVitalCollection","vitalStartsByName","vitalStop","vital","stopClocks","buildDurationVital","isValid","valueComputedBySdk","custom","computed_value","processVital","createCookieObservable","cookieName","detectCookieChangeStrategy","CHANGE","changeEvent","changed","deleted","listenToCookieStoreChange","watchCookieFallback","WATCH_COOKIE_INTERVAL_DELAY","previousCookieValue","watchCookieIntervalId","cookieValue","CI_VISIBILITY_TEST_ID_COOKIE_NAME","getSessionReplayUrl","errorType","sessionId","rumConfiguration","getSiteDefaultSubdomain","statsPerView","MAX_STATS_HISTORY","getSegmentsCount","getOrCreateReplayStats","segments_count","records_count","segments_total_raw_size","_value","deleteOldestStats","serializedNodeIds","hasSerializedNode","getSerializedNodeId","getElementInputValue","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssText","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","quote","baseUrl","makeUrlAbsolute","TAG_NAME_REGEX","getValidTagName","processedTagName","censoredImageForSize","FullSnapshot","IncrementalSnapshot","Meta","Focus","ViewEnd","VisualViewport","FrustrationRecord","NodeType","Document","DocumentType","Text","CDATA","DocumentFragment","IncrementalSource","Mutation","MouseMove","MouseInteraction","Scroll","ViewportResize","Input","TouchMove","MediaInteraction","StyleSheetRule","MouseInteractionType","MouseUp","MouseDown","Click","ContextMenu","DblClick","Blur","TouchStart","TouchEnd","MediaInteractionType","Play","Pause","serializeStyleSheets","cssStyleSheets","cssStyleSheet","rules","cssRules","cssRule","disabled","media","serializeAttribute","attributeValue","image","naturalWidth","naturalHeight","getCssRulesString","getCssRuleStringForSafari","getCssRuleString","rule","isCSSStyleRule","selectorText","isCSSImportRule","styleSheet","serializeNodeWithId","serializedNode","DOCUMENT_NODE","serializeChildNodes","adoptedStyleSheets","serializeDocumentNode","isShadowRoot","serializationContext","shadowRootsController","addShadowRoot","serializeDocumentFragmentNode","DOCUMENT_TYPE_NODE","documentType","publicId","systemId","isSVG","el","SVGElement","attributes","rr_width","rr_height","safeAttrs","formValue","optionElement","selected","stylesheet","styleSheets","_cssText","sheet","scrollLeft","checked","mediaElement","rr_mediaState","paused","elementsScrollPositions","rr_scrollLeft","rr_scrollTop","serializeAttributes","hasChildNodes","serializeElementNode","serializeTextNode","CDATA_SECTION_NODE","serializeNode","_nextId","serializedNodeWithId","serializeNodeId","setSerializedNodeId","childNode","serializedChildNode","serializeDocument","isTouchEvent","changedTouches","getEventTarget","composed","composedPath","convertMouseEventToLayoutCoordinates","normalized","layoutViewportX","layoutViewportY","visualViewportX","visualViewportY","abs","isVisualViewportFactoredIn","assembleIncrementalSnapshot","MOUSE_MOVE_OBSERVER_THRESHOLD","trackMove","moveCb","coordinates","tryToComputeCoordinates","timeOffset","positions","updatePosition","cancelThrottle","MOUSE_MOVE","TOUCH_MOVE","isFinite","eventTypeToMouseInteraction","CONTEXT_MENU","DBL_CLICK","TOUCH_END","trackMouseInteraction","mouseInteractionCb","recordIds","record","getIdForEvent","SCROLL_OBSERVER_THRESHOLD","trackScroll","scrollCb","scrollPositions","trackViewportResize","viewportResizeCb","viewportResizeSubscription","trackMediaInteraction","mediaInteractionCb","PLAY","PAUSE","trackStyleSheet","styleSheetCb","checkStyleSheetAndCallback","ownerNode","instrumentationStoppers","CSSStyleSheet","adds","removes","instrumentGroupingCSSRuleClass","cls","parentStyleSheet","getPathToNestedCSSRule","CSSGroupingRule","CSSMediaRule","CSSSupportsRule","stopper","currentRule","parentRule","trackFocus","focusCb","has_focus","trackFrustration","frustrationCb","frustrationSubscription","trackViewEnd","viewEndCb","viewEndSubscription","trackInput","inputCb","stopPropertySetterInstrumentation","lastInputStateMap","HTMLTextAreaElement","HTMLSelectElement","onElementChange","inputState","isChecked","cbWithDedup","lastInputState","MUTATION_PROCESS_MAX_DELAY","MUTATION_PROCESS_MIN_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","throttledFlush","addMutations","mutations","opts","requestIdleCallback","cancelIdleCallback","requestAnimationFrame","cancelAnimationFrame","timeout","trackMutation","mutationCallback","mutationBatch","nodePrivacyLevelCache","mutation","removedNodes","removedNode","traverseRemovedShadowDom","removeShadowRoot","filteredMutations","nodeAndAncestorsHaveSerializedNode","addedAndMovedNodes","addedNodes","sortedAddedAndMovedNodes","nodes","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","addedNodeMutations","hasBeenSerialized","nextId","getNextSibling","parentId","removedNodeMutations","processChildListMutations","texts","textMutations","handledNodes","oldValue","processCharacterDataMutations","attributeMutations","handledElements","handledAttributes","emittedMutations","transformedValue","inputValue","emittedMutation","processAttributesMutations","processMutations","takeRecords","attributeOldValue","characterData","characterDataOldValue","childList","subtree","shadowDomRemovedCallback","initShadowRootsController","controllerByShadowRoot","mutationTracker","inputTracker","scrollTracker","emit","scrollPositionsByElement","emitAndComputeStats","stopFullSnapshots","flushMutations","fullSnapshotCallback","takeFullSnapshot","records","initialOffset","startFullSnapshots","initRecordIds","trackers","viewEndRecord","creationReason","encodedBytesCount","metadata","creation_reason","has_full_snapshot","index_in_view","addRecord","prefix","additionalBytesCount","SEGMENT_DURATION_LIMIT","SEGMENT_BYTES_LIMIT","startSegmentCollection","httpRequest","getSegmentContext","nextSegmentCreationReason","unsubscribeViewCreated","flushSegment","unsubscribePageExited","segment","rawSegmentBytesCount","formData","FormData","metadataAndSegmentSizes","raw_segment_size","compressed_segment_size","byteLength","serializedMetadataAndSegmentSizes","buildReplayPayload","expirationTimeoutId","Segment","doStartSegmentCollection","computeSegmentContext","isBrowserSupported","createObjectURL","NodeList","getSessionReplayLink","isRecordingStarted","getErrorType","createDeflateEncoder","worker","streamId","compressedDataTrailer","compressedData","nextWriteActionId","pendingWriteActions","removeMessageListener","workerResponse","trailer","nextPendingAction","writeCallback","finishCallback","consumeResult","buffers","reduce","total","concatBuffers","sendResetIfNeeded","postMessage","pendingWriteAction","INITIALIZATION_TIME_OUT_DELAY","createDeflateWorker","Worker","onInitializationFailure","createDeflateWorkerImpl","onError","initializationFailureCallbacks","onTimeout","doStartDeflateWorker","getDeflateWorkerStatus","baseMessage","worker_version","stream_id","existingGlobalVariable","startRecordingImpl","onRumStart","isRecording","startStrategy","stopStrategy","getSessionReplayLinkStrategy","cachedDeflateEncoder","force","deflateEncoder","stopRecording","makeRecorderApi","replayRequest","startRecordBridge","segmentCollection","datadogRum","startRumImpl","currentConsent","customerDataTrackerManager","globalContextManager","userContextManager","buildCommonContext","stub","CUSTOM_VITALS","rumPublicApi","feature","stopTime","preStartStrategy","createPostStartStrategy","sanitizedOptions","setTrackingConsent","setGlobalContext","getGlobalContext","setGlobalContextProperty","removeGlobalContextProperty","clearGlobalContext","getInitConfiguration","setUser","checkUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","clearUser","startSessionReplayRecording","stopSessionReplayRecording","onReady","enumerable","makeRumPublicApi","startRumTelemetry","currentContext","startFeatureFlagContexts","stopBeforeUnloadListener","BEFORE_UNLOAD","createPageExitObservable","startRumSessionManagerStub","startRumEventBridge","batchFlushObservable","startCustomerDataTelemetry","viewContextHistory","buildViewContext","startViewContexts","previousViewUrl","urlContextHistory","viewUrl","buildUrlContext","changeTime","startUrlContexts","startActionCollection","viewport","viewportDimension","startDisplayContext","cookieObservable","testExecutionId","Cypress","cookieObservableSubscription","test_execution_id","startCiVisibilityContext","startRumEventCollection","stopRumEventCollection","startLongTaskCollection","stopViewCollection","stopPerformanceCollection","vitalCollection","internalContext","application_id","session_id","user_action","startInternalContext","q"],"sourceRoot":""}