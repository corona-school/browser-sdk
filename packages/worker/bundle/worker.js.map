{"version":3,"file":"worker.js","mappings":"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","sources":["webpack:///../core/src/tools/utils/byteUtils.ts","webpack:///./src/domain/deflate.js","webpack:///./src/boot/startWorker.ts","webpack:///./src/entries/main.ts"],"sourcesContent":["export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]) {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n","/* eslint-disable camelcase, no-bitwise */\n// This file comes from and was trimmed from unused code https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* Public constants ========================================================== */\n\n/* =========================================================================== */\n// const Z_FILTERED          = 1;\n// const Z_HUFFMAN_ONLY      = 2;\n// const Z_RLE               = 3;\n\nvar Z_FIXED = 4 // const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n\nvar Z_BINARY = 0\nvar Z_TEXT = 1 // const Z_ASCII             = 1; // = Z_TEXT\n\nvar Z_UNKNOWN = 2\n/* ============================================================================ */\n\nfunction zero(buf) {\n  var len = buf.length\n\n  while (--len >= 0) {\n    buf[len] = 0\n  }\n} // From zutil.h\n\nvar STORED_BLOCK = 0\nvar STATIC_TREES = 1\nvar DYN_TREES = 2\n/* The three kinds of block type */\n\nvar MIN_MATCH = 3\nvar MAX_MATCH = 258\n/* The minimum and maximum match lengths */\n// From deflate.h\n\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES = 29\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS = 256\n/* number of literal bytes 0..255 */\n\nvar L_CODES = LITERALS + 1 + LENGTH_CODES\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES = 30\n/* number of distance codes */\n\nvar BL_CODES = 19\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE = 2 * L_CODES + 1\n/* maximum heap size */\n\nvar MAX_BITS = 15\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size = 16\n/* size of bit buffer in bi_buf */\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK = 256\n/* end of block literal code */\n\nvar REP_3_6 = 16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10 = 17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nvar extra_lbits =\n  /* extra bits for each length code */\n  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])\nvar extra_dbits =\n  /* extra bits for each distance code */\n  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])\nvar extra_blbits =\n  /* extra bits for each bit length code */\n  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])\nvar bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512\n/* see definition of array dist_code below */\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\nvar static_ltree = new Array((L_CODES + 2) * 2)\nzero(static_ltree)\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree = new Array(D_CODES * 2)\nzero(static_dtree)\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code = new Array(DIST_CODE_LEN)\n\nzero(_dist_code)\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code = new Array(MAX_MATCH - MIN_MATCH + 1)\n\nzero(_length_code)\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length = new Array(LENGTH_CODES)\nzero(base_length)\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist = new Array(D_CODES)\nzero(base_dist)\n/* First normalized distance for each code (0 = distance of 1) */\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n  this.static_tree = static_tree\n  /* static tree or NULL */\n\n  this.extra_bits = extra_bits\n  /* extra bits for each code or NULL */\n\n  this.extra_base = extra_base\n  /* base index for extra_bits */\n\n  this.elems = elems\n  /* max number of elements in the tree */\n\n  this.max_length = max_length\n  /* max bit length for the codes */\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n  this.has_stree = static_tree && static_tree.length\n}\n\nvar static_l_desc\nvar static_d_desc\nvar static_bl_desc\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree\n  /* the dynamic tree */\n\n  this.max_code = 0\n  /* largest code with non zero frequency */\n\n  this.stat_desc = stat_desc\n  /* the corresponding static tree */\n}\n\nvar d_code = function d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]\n}\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\n\nvar put_short = function put_short(s, w) {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = w & 0xff\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n\nvar send_bits = function send_bits(s, value, length) {\n  if (s.bi_valid > Buf_size - length) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff\n    put_short(s, s.bi_buf)\n    s.bi_buf = value >> (Buf_size - s.bi_valid)\n    s.bi_valid += length - Buf_size\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff\n    s.bi_valid += length\n  }\n}\n\nvar send_code = function send_code(s, c, tree) {\n  send_bits(\n    s,\n    tree[c * 2],\n    /* .Code */\n    tree[c * 2 + 1]\n    /* .Len */\n  )\n}\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\n\nvar bi_reverse = function bi_reverse(code, len) {\n  var res = 0\n\n  do {\n    res |= code & 1\n    code >>>= 1\n    res <<= 1\n  } while (--len > 0)\n\n  return res >>> 1\n}\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\n\nvar bi_flush = function bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf)\n    s.bi_buf = 0\n    s.bi_valid = 0\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff\n    s.bi_buf >>= 8\n    s.bi_valid -= 8\n  }\n}\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\n\nvar gen_bitlen = function gen_bitlen(\n  s,\n  desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n) {\n  var tree = desc.dyn_tree\n  var max_code = desc.max_code\n  var stree = desc.stat_desc.static_tree\n  var has_stree = desc.stat_desc.has_stree\n  var extra = desc.stat_desc.extra_bits\n  var base = desc.stat_desc.extra_base\n  var max_length = desc.stat_desc.max_length\n  var h\n  /* heap index */\n\n  var n\n  var m\n  /* iterate over the tree elements */\n\n  var bits\n  /* bit length */\n\n  var xbits\n  /* extra bits */\n\n  var f\n  /* frequency */\n\n  var overflow = 0\n  /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0\n  }\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n\n  tree[s.heap[s.heap_max] * 2 + 1] =\n    /* .Len */\n    0\n  /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h]\n    bits =\n      tree[\n        tree[n * 2 + 1] *\n          /* .Dad */\n          2 +\n          1\n      ] +\n      /* .Len */\n      1\n\n    if (bits > max_length) {\n      bits = max_length\n      overflow++\n    }\n\n    tree[n * 2 + 1] =\n      /* .Len */\n      bits\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) {\n      continue\n    }\n    /* not a leaf node */\n\n    s.bl_count[bits]++\n    xbits = 0\n\n    if (n >= base) {\n      xbits = extra[n - base]\n    }\n\n    f = tree[n * 2]\n    /* .Freq */\n    s.opt_len += f * (bits + xbits)\n\n    if (has_stree) {\n      s.static_len +=\n        f *\n        (stree[n * 2 + 1] +\n          /* .Len */\n          xbits)\n    }\n  }\n\n  if (overflow === 0) {\n    return\n  } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n\n  do {\n    bits = max_length - 1\n\n    while (s.bl_count[bits] === 0) {\n      bits--\n    }\n\n    s.bl_count[bits]--\n    /* move one leaf down the tree */\n\n    s.bl_count[bits + 1] += 2\n    /* move one overflow item as its brother */\n\n    s.bl_count[max_length]--\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n\n    overflow -= 2\n  } while (overflow > 0)\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits]\n\n    while (n !== 0) {\n      m = s.heap[--h]\n\n      if (m > max_code) {\n        continue\n      }\n\n      if (\n        tree[m * 2 + 1] !==\n        /* .Len */\n        bits\n      ) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len +=\n          (bits - tree[m * 2 + 1]) *\n          /* .Len */\n          tree[m * 2]\n        /* .Freq */\n        tree[m * 2 + 1] =\n          /* .Len */\n          bits\n      }\n\n      n--\n    }\n  }\n}\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\n\nvar gen_codes = function gen_codes(\n  tree,\n  max_code,\n  bl_count\n  //    ct_data *tree;             /* the tree to decorate */\n  //    int max_code;              /* largest code with non zero frequency */\n  //    ushf *bl_count;            /* number of codes at each bit length */\n) {\n  var next_code = new Array(MAX_BITS + 1)\n  /* next code value for each bit length */\n\n  var code = 0\n  /* running code value */\n\n  var bits\n  /* bit index */\n\n  var n\n  /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0; n <= max_code; n++) {\n    var len = tree[n * 2 + 1]\n    /* .Len */\n    if (len === 0) {\n      continue\n    }\n    /* Now reverse the bits */\n\n    tree[n * 2] =\n      /* .Code */\n      bi_reverse(next_code[len]++, len) // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\n\nvar tr_static_init = function tr_static_init() {\n  var n\n  /* iterates over tree elements */\n\n  var bits\n  /* bit counter */\n\n  var length\n  /* length value */\n\n  var code\n  /* code value */\n\n  var dist\n  /* distance index */\n\n  var bl_count = new Array(MAX_BITS + 1)\n  /* number of codes at each bit length for an optimal tree */\n  // do check in _tr_init()\n  // if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n\n  /* #ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n    #endif */\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n  length = 0\n\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length\n\n    for (n = 0; n < 1 << extra_lbits[code]; n++) {\n      _length_code[length++] = code\n    }\n  } // Assert (length == 256, \"tr_static_init: length != 256\");\n\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n\n  _length_code[length - 1] = code\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n  dist = 0\n\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist\n\n    for (n = 0; n < 1 << extra_dbits[code]; n++) {\n      _dist_code[dist++] = code\n    }\n  } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n  dist >>= 7\n  /* from now on, all distances are divided by 128 */\n\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7\n\n    for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n      _dist_code[256 + dist++] = code\n    }\n  } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0\n  }\n\n  n = 0\n\n  while (n <= 143) {\n    static_ltree[n * 2 + 1] =\n      /* .Len */\n      8\n    n++\n    bl_count[8]++\n  }\n\n  while (n <= 255) {\n    static_ltree[n * 2 + 1] =\n      /* .Len */\n      9\n    n++\n    bl_count[9]++\n  }\n\n  while (n <= 279) {\n    static_ltree[n * 2 + 1] =\n      /* .Len */\n      7\n    n++\n    bl_count[7]++\n  }\n\n  while (n <= 287) {\n    static_ltree[n * 2 + 1] =\n      /* .Len */\n      8\n    n++\n    bl_count[8]++\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n\n  gen_codes(static_ltree, L_CODES + 1, bl_count)\n  /* The static distance tree is trivial: */\n\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1] =\n      /* .Len */\n      5\n    static_dtree[n * 2] =\n      /* .Code */\n      bi_reverse(n, 5)\n  } // Now data ready and we can init static trees\n\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS)\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS)\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)\n  // static_init_done = true;\n}\n/* ===========================================================================\n * Initialize a new block.\n */\n\nvar init_block = function init_block(s) {\n  var n\n  /* iterates over tree elements */\n\n  /* Initialize the trees. */\n\n  for (n = 0; n < L_CODES; n++) {\n    s.dyn_ltree[n * 2] =\n      /* .Freq */\n      0\n  }\n\n  for (n = 0; n < D_CODES; n++) {\n    s.dyn_dtree[n * 2] =\n      /* .Freq */\n      0\n  }\n\n  for (n = 0; n < BL_CODES; n++) {\n    s.bl_tree[n * 2] =\n      /* .Freq */\n      0\n  }\n\n  s.dyn_ltree[END_BLOCK * 2] =\n    /* .Freq */\n    1\n  s.opt_len = s.static_len = 0\n  s.last_lit = s.matches = 0\n}\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\n\nvar bi_windup = function bi_windup(s) {\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf)\n  } else if (s.bi_valid > 0) {\n    // put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf\n  }\n\n  s.bi_buf = 0\n  s.bi_valid = 0\n}\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\n\nvar copy_block = function copy_block(\n  s,\n  buf,\n  len,\n  header\n  // DeflateState *s;\n  // charf    *buf;    /* the input data */\n  // unsigned len;     /* its length */\n  // int      header;  /* true if block header must be written */\n) {\n  bi_windup(s)\n  /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len)\n    put_short(s, ~len)\n  }\n  //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n\n  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending)\n  s.pending += len\n}\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n\nvar smaller = function smaller(tree, n, m, depth) {\n  var _n2 = n * 2\n\n  var _m2 = m * 2\n\n  return (\n    tree[_n2] <\n      /* .Freq */\n      tree[_m2] ||\n    /* .Freq */\n    (tree[_n2] ===\n      /* .Freq */\n      tree[_m2] &&\n      /* .Freq */\n      depth[n] <= depth[m])\n  )\n}\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\n\nvar pqdownheap = function pqdownheap(\n  s,\n  tree,\n  k\n  //    deflate_state *s;\n  //    ct_data *tree;  /* the tree to restore */\n  //    int k;               /* node to move down */\n) {\n  var v = s.heap[k]\n  var j = k << 1\n  /* left son of k */\n\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++\n    }\n    /* Exit if v is smaller than both sons */\n\n    if (smaller(tree, v, s.heap[j], s.depth)) {\n      break\n    }\n    /* Exchange v with the smallest son */\n\n    s.heap[k] = s.heap[j]\n    k = j\n    /* And continue down the tree, setting j to the left son of k */\n\n    j <<= 1\n  }\n\n  s.heap[k] = v\n} // inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\n\nvar compress_block = function compress_block(\n  s,\n  ltree,\n  dtree\n  //    deflate_state *s;\n  //    const ct_data *ltree; /* literal tree */\n  //    const ct_data *dtree; /* distance tree */\n) {\n  var dist\n  /* distance of matched string */\n\n  var lc\n  /* match length or unmatched char (if dist == 0) */\n\n  var lx = 0\n  /* running index in l_buf */\n\n  var code\n  /* the code to send */\n\n  var extra\n  /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1]\n      lc = s.pending_buf[s.l_buf + lx]\n      lx++\n\n      if (dist === 0) {\n        send_code(s, lc, ltree)\n        /* send a literal byte */\n        // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc]\n        send_code(s, code + LITERALS + 1, ltree)\n        /* send the length code */\n\n        extra = extra_lbits[code]\n\n        if (extra !== 0) {\n          lc -= base_length[code]\n          send_bits(s, lc, extra)\n          /* send the extra length bits */\n        }\n\n        dist--\n        /* dist is now the match distance - 1 */\n\n        code = d_code(dist) // Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree)\n        /* send the distance code */\n\n        extra = extra_dbits[code]\n\n        if (extra !== 0) {\n          dist -= base_dist[code]\n          send_bits(s, dist, extra)\n          /* send the extra distance bits */\n        }\n      }\n      /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n    } while (lx < s.last_lit)\n  }\n\n  send_code(s, END_BLOCK, ltree)\n}\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\n\nvar build_tree = function build_tree(\n  s,\n  desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n) {\n  var tree = desc.dyn_tree\n  var stree = desc.stat_desc.static_tree\n  var has_stree = desc.stat_desc.has_stree\n  var elems = desc.stat_desc.elems\n  var n\n  var m\n  /* iterate over heap elements */\n\n  var max_code = -1\n  /* largest code with non zero frequency */\n\n  var node\n  /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n\n  s.heap_len = 0\n  s.heap_max = HEAP_SIZE\n\n  for (n = 0; n < elems; n++) {\n    if (\n      tree[n * 2] !==\n      /* .Freq */\n      0\n    ) {\n      s.heap[++s.heap_len] = max_code = n\n      s.depth[n] = 0\n    } else {\n      tree[n * 2 + 1] =\n        /* .Len */\n        0\n    }\n  }\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0\n    tree[node * 2] =\n      /* .Freq */\n      1\n    s.depth[node] = 0\n    s.opt_len--\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]\n      /* .Len */\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n\n  desc.max_code = max_code\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n\n  for (\n    n = s.heap_len >> 1;\n    /* int /2 */\n    n >= 1;\n    n--\n  ) {\n    pqdownheap(s, tree, n)\n  }\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n\n  node = elems\n  /* next internal node of the tree */\n\n  do {\n    // pqremove(s, tree, n);  /* n = node of least frequency */\n\n    /** * pqremove ** */\n    n = s.heap[1]\n    /* SMALLEST */\n    s.heap[1] = s.heap[s.heap_len--]\n    /* SMALLEST */\n    pqdownheap(\n      s,\n      tree,\n      1\n      /* SMALLEST */\n    )\n    /***/\n\n    m = s.heap[1]\n    /* SMALLEST */\n    /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n\n    /* keep the nodes sorted by frequency */\n\n    s.heap[--s.heap_max] = m\n    /* Create a new node father of n and m */\n\n    tree[node * 2] =\n      /* .Freq */\n      tree[n * 2] +\n      /* .Freq */\n      tree[m * 2]\n    /* .Freq */\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1\n    tree[n * 2 + 1] =\n      /* .Dad */\n      tree[m * 2 + 1] =\n        /* .Dad */\n        node\n    /* and insert the new node in the heap */\n\n    s.heap[1] = node++\n    /* SMALLEST */\n    pqdownheap(\n      s,\n      tree,\n      1\n      /* SMALLEST */\n    )\n  } while (s.heap_len >= 2)\n\n  s.heap[--s.heap_max] = s.heap[1]\n  /* SMALLEST */\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n\n  gen_bitlen(s, desc)\n  /* The field len is now set, we can generate the bit codes */\n\n  gen_codes(tree, max_code, s.bl_count)\n}\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\n\nvar scan_tree = function scan_tree(\n  s,\n  tree,\n  max_code\n  //    deflate_state *s;\n  //    ct_data *tree;   /* the tree to be scanned */\n  //    int max_code;    /* and its largest code of non zero frequency */\n) {\n  var n\n  /* iterates over all tree elements */\n\n  var prevlen = -1\n  /* last emitted length */\n\n  var curlen\n  /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]\n  /* .Len */\n  /* length of next code */\n\n  var count = 0\n  /* repeat count of the current code */\n\n  var max_count = 7\n  /* max repeat count */\n\n  var min_count = 4\n  /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138\n    min_count = 3\n  }\n\n  tree[(max_code + 1) * 2 + 1] =\n    /* .Len */\n    0xffff\n  /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen\n    nextlen = tree[(n + 1) * 2 + 1]\n    /* .Len */\n\n    if (++count < max_count && curlen === nextlen) {\n      continue\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2] +=\n        /* .Freq */\n        count\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        s.bl_tree[curlen * 2] /* .Freq */++\n      }\n\n      s.bl_tree[REP_3_6 * 2] /* .Freq */++\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2] /* .Freq */++\n    } else {\n      s.bl_tree[REPZ_11_138 * 2] /* .Freq */++\n    }\n\n    count = 0\n    prevlen = curlen\n\n    if (nextlen === 0) {\n      max_count = 138\n      min_count = 3\n    } else if (curlen === nextlen) {\n      max_count = 6\n      min_count = 3\n    } else {\n      max_count = 7\n      min_count = 4\n    }\n  }\n}\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\n\nvar send_tree = function send_tree(\n  s,\n  tree,\n  max_code\n  //    deflate_state *s;\n  //    ct_data *tree; /* the tree to be scanned */\n  //    int max_code;       /* and its largest code of non zero frequency */\n) {\n  var n\n  /* iterates over all tree elements */\n\n  var prevlen = -1\n  /* last emitted length */\n\n  var curlen\n  /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]\n  /* .Len */\n  /* length of next code */\n\n  var count = 0\n  /* repeat count of the current code */\n\n  var max_count = 7\n  /* max repeat count */\n\n  var min_count = 4\n  /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */\n\n  /* guard already set */\n\n  if (nextlen === 0) {\n    max_count = 138\n    min_count = 3\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen\n    nextlen = tree[(n + 1) * 2 + 1]\n    /* .Len */\n\n    if (++count < max_count && curlen === nextlen) {\n      continue\n    } else if (count < min_count) {\n      do {\n        send_code(s, curlen, s.bl_tree)\n      } while (--count !== 0)\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree)\n        count--\n      } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n      send_code(s, REP_3_6, s.bl_tree)\n      send_bits(s, count - 3, 2)\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree)\n      send_bits(s, count - 3, 3)\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree)\n      send_bits(s, count - 11, 7)\n    }\n\n    count = 0\n    prevlen = curlen\n\n    if (nextlen === 0) {\n      max_count = 138\n      min_count = 3\n    } else if (curlen === nextlen) {\n      max_count = 6\n      min_count = 3\n    } else {\n      max_count = 7\n      min_count = 4\n    }\n  }\n}\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\n\nvar build_bl_tree = function build_bl_tree(s) {\n  var max_blindex\n  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code)\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code)\n  /* Build the bit length tree: */\n\n  build_tree(s, s.bl_desc)\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (\n      s.bl_tree[bl_order[max_blindex] * 2 + 1] !==\n      /* .Len */\n      0\n    ) {\n      break\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4 // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex\n}\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\n\nvar send_all_trees = function send_all_trees(\n  s,\n  lcodes,\n  dcodes,\n  blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n) {\n  var rank\n  /* index in bl_order */\n  // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  // Tracev((stderr, \"\\nbl counts: \"));\n\n  send_bits(s, lcodes - 257, 5)\n  /* not +255 as stated in appnote.txt */\n\n  send_bits(s, dcodes - 1, 5)\n  send_bits(s, blcodes - 4, 4)\n  /* not -3 as stated in appnote.txt */\n\n  for (rank = 0; rank < blcodes; rank++) {\n    // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(\n      s,\n      s.bl_tree[bl_order[rank] * 2 + 1],\n      /* .Len */\n      3\n    )\n  } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1)\n  /* literal tree */\n  // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1)\n  /* distance tree */\n  // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\n\nvar detect_data_type = function detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f\n  var n\n  /* Check for non-textual (\"black-listed\") bytes. */\n\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if (\n      black_mask & 1 &&\n      s.dyn_ltree[n * 2] !==\n        /* .Freq */\n        0\n    ) {\n      return Z_BINARY\n    }\n  }\n  /* Check for textual (\"white-listed\") bytes. */\n\n  if (\n    s.dyn_ltree[9 * 2] !==\n      /* .Freq */\n      0 ||\n    s.dyn_ltree[10 * 2] !==\n      /* .Freq */\n      0 ||\n    s.dyn_ltree[13 * 2] !==\n      /* .Freq */\n      0\n  ) {\n    return Z_TEXT\n  }\n\n  for (n = 32; n < LITERALS; n++) {\n    if (\n      s.dyn_ltree[n * 2] !==\n      /* .Freq */\n      0\n    ) {\n      return Z_TEXT\n    }\n  }\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n\n  return Z_BINARY\n}\n\nvar static_init_done = false\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\n\nvar _tr_init = function _tr_init(s) {\n  if (!static_init_done) {\n    tr_static_init()\n    static_init_done = true\n  }\n\n  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)\n  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)\n  s.bi_buf = 0\n  s.bi_valid = 0\n  /* Initialize the first block of the first file: */\n\n  init_block(s)\n}\n/* ===========================================================================\n * Send a stored block\n */\n\nvar _tr_stored_block = function _tr_stored_block(\n  s,\n  buf,\n  stored_len,\n  last\n  // DeflateState *s;\n  // charf *buf;       /* input block */\n  // ulg stored_len;   /* length of input block */\n  // int last;         /* one if this is the last block for a file */\n) {\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3)\n  /* send block type */\n\n  copy_block(s, buf, stored_len, true)\n  /* with header */\n}\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\n\nvar _tr_align = function _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3)\n  send_code(s, END_BLOCK, static_ltree)\n  bi_flush(s)\n}\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\n\nvar _tr_flush_block = function _tr_flush_block(\n  s,\n  buf,\n  stored_len,\n  last\n  // DeflateState *s;\n  // charf *buf;       /* input block, or NULL if too old */\n  // ulg stored_len;   /* length of input block */\n  // int last;         /* one if this is the last block for a file */\n) {\n  var opt_lenb\n  var static_lenb\n  /* opt_len and static_len in bytes */\n\n  var max_blindex = 0\n  /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n\n  if (s.level > 0) {\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s)\n    }\n    /* Construct the literal and distance trees */\n\n    build_tree(s, s.l_desc) // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc) // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n\n    max_blindex = build_bl_tree(s)\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3\n    static_lenb = (s.static_len + 3 + 7) >>> 3 // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) {\n      opt_lenb = static_lenb\n    }\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5\n    /* force a stored block */\n  }\n\n  if (stored_len + 4 <= opt_lenb && buf !== -1) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last)\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3)\n    compress_block(s, static_ltree, static_dtree)\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3)\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1)\n    compress_block(s, s.dyn_ltree, s.dyn_dtree)\n  } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n\n  init_block(s)\n\n  if (last) {\n    bi_windup(s)\n  } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\n\nvar _tr_tally = function _tr_tally(\n  s,\n  dist,\n  lc\n  //    deflate_state *s;\n  //    unsigned dist;  /* distance of matched string */\n  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n) {\n  // let out_length, in_length, dcode;\n  s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff\n  s.last_lit++\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2] /* .Freq */++\n  } else {\n    s.matches++\n    /* Here, lc is the match length - MIN_MATCH */\n\n    dist--\n    /* dist = match distance - 1 */\n    // Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++\n    s.dyn_dtree[d_code(dist) * 2] /* .Freq */++\n  } // (!) This block is disabled in zlib defaults,\n  // don't enable it for binary compatibility\n  // #ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  // #endif\n\n  return s.last_lit === s.lit_bufsize - 1\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nvar _tr_init_1 = _tr_init\nvar _tr_stored_block_1 = _tr_stored_block\nvar _tr_flush_block_1 = _tr_flush_block\nvar _tr_tally_1 = _tr_tally\nvar _tr_align_1 = _tr_align\nvar trees = {\n  _tr_init: _tr_init_1,\n  _tr_stored_block: _tr_stored_block_1,\n  _tr_flush_block: _tr_flush_block_1,\n  _tr_tally: _tr_tally_1,\n  _tr_align: _tr_align_1,\n}\n\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar adler32 = function adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) | 0\n  var s2 = ((adler >>> 16) & 0xffff) | 0\n  var n = 0\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len\n    len -= n\n\n    do {\n      s1 = (s1 + buf[pos++]) | 0\n      s2 = (s2 + s1) | 0\n    } while (--n)\n\n    s1 %= 65521\n    s2 %= 65521\n  }\n\n  return s1 | (s2 << 16) | 0\n}\n\nvar adler32_1 = adler32\n\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// Use ordinary array, since untyped makes no boost here\n\nvar makeTable = function makeTable() {\n  var c\n  var table = []\n\n  for (var n = 0; n < 256; n++) {\n    c = n\n\n    for (var k = 0; k < 8; k++) {\n      c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1\n    }\n\n    table[n] = c\n  }\n\n  return table\n} // Create table on load. Just 255 signed longs. Not a problem.\n\nvar crcTable = new Uint32Array(makeTable())\n\nvar crc32 = function crc32(crc, buf, len, pos) {\n  var t = crcTable\n  var end = pos + len\n  crc ^= -1\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff]\n  }\n\n  return crc ^ -1 // >>> 0;\n}\n\nvar crc32_1 = crc32\n\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2: 'need dictionary',\n\n  /* Z_NEED_DICT       2  */\n  1: 'stream end',\n\n  /* Z_STREAM_END      1  */\n  0: '',\n\n  /* Z_OK              0  */\n  '-1': 'file error',\n\n  /* Z_ERRNO         (-1) */\n  '-2': 'stream error',\n\n  /* Z_STREAM_ERROR  (-2) */\n  '-3': 'data error',\n\n  /* Z_DATA_ERROR    (-3) */\n  '-4': 'insufficient memory',\n\n  /* Z_MEM_ERROR     (-4) */\n  '-5': 'buffer error',\n\n  /* Z_BUF_ERROR     (-5) */\n  '-6': 'incompatible version',\n  /* Z_VERSION_ERROR (-6) */\n}\n\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nexport var constants = {\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_TREES: 6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n   * are errors, positive values are used for special but normal events.\n   */\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  // Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY: 0,\n  Z_TEXT: 1,\n  // Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN: 2,\n\n  /* The deflate compression method */\n  Z_DEFLATED: 8, // Z_NULL:                 null // Use -1 or null inline, depending on var type\n}\n\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar _tr_init$1 = trees._tr_init\nvar _tr_stored_block$1 = trees._tr_stored_block\nvar _tr_flush_block$1 = trees._tr_flush_block\nvar _tr_tally$1 = trees._tr_tally\nvar _tr_align$1 = trees._tr_align\n/* Public constants ========================================================== */\n\n/* =========================================================================== */\n\nvar Z_NO_FLUSH = constants.Z_NO_FLUSH\nvar Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH\nvar Z_FULL_FLUSH = constants.Z_FULL_FLUSH\nvar Z_FINISH = constants.Z_FINISH\nvar Z_BLOCK = constants.Z_BLOCK\nvar Z_OK = constants.Z_OK\nvar Z_STREAM_END = constants.Z_STREAM_END\nvar Z_STREAM_ERROR = constants.Z_STREAM_ERROR\nvar Z_DATA_ERROR = constants.Z_DATA_ERROR\nvar Z_BUF_ERROR = constants.Z_BUF_ERROR\nvar Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION\nvar Z_FILTERED = constants.Z_FILTERED\nvar Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY\nvar Z_RLE = constants.Z_RLE\nvar Z_FIXED$1 = constants.Z_FIXED\nvar Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY\nvar Z_UNKNOWN$1 = constants.Z_UNKNOWN\nvar Z_DEFLATED = constants.Z_DEFLATED\n/* ============================================================================ */\n\nvar MAX_MEM_LEVEL = 9\n/* Maximum value for memLevel in deflateInit2 */\n\nvar MAX_WBITS = 15\n/* 32K LZ77 window */\n\nvar DEF_MEM_LEVEL = 8\nvar LENGTH_CODES$1 = 29\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS$1 = 256\n/* number of literal bytes 0..255 */\n\nvar L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES$1 = 30\n/* number of distance codes */\n\nvar BL_CODES$1 = 19\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE$1 = 2 * L_CODES$1 + 1\n/* maximum heap size */\n\nvar MAX_BITS$1 = 15\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH$1 = 3\nvar MAX_MATCH$1 = 258\nvar MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1\nvar PRESET_DICT = 0x20\nvar INIT_STATE = 42\nvar EXTRA_STATE = 69\nvar NAME_STATE = 73\nvar COMMENT_STATE = 91\nvar HCRC_STATE = 103\nvar BUSY_STATE = 113\nvar FINISH_STATE = 666\nvar BS_NEED_MORE = 1\n/* block not completed, need more input or more output */\n\nvar BS_BLOCK_DONE = 2\n/* block flush performed */\n\nvar BS_FINISH_STARTED = 3\n/* finish started, need only more output at next deflate */\n\nvar BS_FINISH_DONE = 4\n/* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03 // Unix :) . Don't detect, use this default.\n\nvar err = function err(strm, errorCode) {\n  strm.msg = messages[errorCode]\n  return errorCode\n}\n\nvar rank = function rank(f) {\n  return (f << 1) - (f > 4 ? 9 : 0)\n}\n\nvar zero$1 = function zero(buf) {\n  var len = buf.length\n\n  while (--len >= 0) {\n    buf[len] = 0\n  }\n}\n\nvar HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n  return ((prev << s.hash_shift) ^ data) & s.hash_mask\n} // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n// let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\nvar HASH = HASH_ZLIB\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\n\nvar flush_pending = function flush_pending(strm) {\n  var s = strm.state // _tr_flush_bits(s);\n\n  var len = s.pending\n\n  if (len > strm.avail_out) {\n    len = strm.avail_out\n  }\n\n  if (len === 0) {\n    return\n  }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out)\n  strm.next_out += len\n  s.pending_out += len\n  strm.total_out += len\n  strm.avail_out -= len\n  s.pending -= len\n\n  if (s.pending === 0) {\n    s.pending_out = 0\n  }\n}\n\nvar flush_block_only = function flush_block_only(s, last) {\n  _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last)\n\n  s.block_start = s.strstart\n  flush_pending(s.strm)\n}\n\nvar put_byte = function put_byte(s, b) {\n  s.pending_buf[s.pending++] = b\n}\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\n\nvar putShortMSB = function putShortMSB(s, b) {\n  //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff\n  s.pending_buf[s.pending++] = b & 0xff\n}\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\n\nvar read_buf = function read_buf(strm, buf, start, size) {\n  var len = strm.avail_in\n\n  if (len > size) {\n    len = size\n  }\n\n  if (len === 0) {\n    return 0\n  }\n\n  strm.avail_in -= len // zmemcpy(buf, strm->next_in, len);\n\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start)\n\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start)\n  } else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start)\n  }\n\n  strm.next_in += len\n  strm.total_in += len\n  return len\n}\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\n\nvar longest_match = function longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length\n  /* max hash chain length */\n\n  var scan = s.strstart\n  /* current string */\n\n  var match\n  /* matched string */\n\n  var len\n  /* length of current match */\n\n  var best_len = s.prev_length\n  /* best match length so far */\n\n  var nice_match = s.nice_match\n  /* stop if match long enough */\n\n  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\n  /* NIL */\n  var _win = s.window // shortcut\n\n  var wmask = s.w_mask\n  var prev = s.prev\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH$1\n  var scan_end1 = _win[scan + best_len - 1]\n  var scan_end = _win[scan + best_len]\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n\n  if (nice_match > s.lookahead) {\n    nice_match = s.lookahead\n  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (\n      _win[match + best_len] !== scan_end ||\n      _win[match + best_len - 1] !== scan_end1 ||\n      _win[match] !== _win[scan] ||\n      _win[++match] !== _win[scan + 1]\n    ) {\n      continue\n    }\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n\n    scan += 2\n    match++ // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n\n    do {\n      /* jshint noempty:false */\n    } while (\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      scan < strend\n    ) // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH$1 - (strend - scan)\n    scan = strend - MAX_MATCH$1\n\n    if (len > best_len) {\n      s.match_start = cur_match\n      best_len = len\n\n      if (len >= nice_match) {\n        break\n      }\n\n      scan_end1 = _win[scan + best_len - 1]\n      scan_end = _win[scan + best_len]\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)\n\n  if (best_len <= s.lookahead) {\n    return best_len\n  }\n\n  return s.lookahead\n}\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\n\nvar fill_window = function fill_window(s) {\n  var _w_size = s.w_size\n  var p\n  var n\n  var m\n  var more\n  var str // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart // JS ints have 32 bit, block below not needed\n\n    /* Deal with !@#$% 64K limit: */\n    // if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    // }\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0)\n      s.match_start -= _w_size\n      s.strstart -= _w_size\n      /* we now have strstart >= MAX_DIST */\n\n      s.block_start -= _w_size\n      /* Slide the hash table (could be avoided with 32 bit values\n         at the expense of memory usage). We slide even when level == 0\n         to keep the hash table consistent if we switch back to level > 0\n         later. (Using level 0 permanently is not an optimal usage of\n         zlib, so we don't care about this pathological case.)\n         */\n\n      n = s.hash_size\n      p = n\n\n      do {\n        m = s.head[--p]\n        s.head[p] = m >= _w_size ? m - _w_size : 0\n      } while (--n)\n\n      n = _w_size\n      p = n\n\n      do {\n        m = s.prev[--p]\n        s.prev[p] = m >= _w_size ? m - _w_size : 0\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n)\n\n      more += _w_size\n    }\n\n    if (s.strm.avail_in === 0) {\n      break\n    }\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    // Assert(more >= 2, \"more < 2\");\n\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more)\n    s.lookahead += n\n    /* Initialize the hash value now that we have some input: */\n\n    if (s.lookahead + s.insert >= MIN_MATCH$1) {\n      str = s.strstart - s.insert\n      s.ins_h = s.window[str]\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]) // #if MIN_MATCH != 3\n      //        Call update_hash() MIN_MATCH-3 more times\n      // #endif\n\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1])\n        s.prev[str & s.w_mask] = s.head[s.ins_h]\n        s.head[s.ins_h] = str\n        str++\n        s.insert--\n\n        if (s.lookahead + s.insert < MIN_MATCH$1) {\n          break\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n  //  if (s.high_water < s.window_size) {\n  //    const curr = s.strstart + s.lookahead;\n  //    let init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n}\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\n\nvar deflate_stored = function deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5\n  }\n  /* Copy as much as possible from input to output: */\n\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n      // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n      //        s.block_start >= s.w_size)) {\n      //        throw  new Error(\"slide too late\");\n      //      }\n      fill_window(s)\n\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n\n      if (s.lookahead === 0) {\n        break\n      }\n      /* flush the current block */\n    } // Assert(s->block_start >= 0L, \"block gone\");\n    //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead\n    s.lookahead = 0\n    /* Emit a stored block if pending_buf will be full: */\n\n    var max_start = s.block_start + max_block_size\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start\n      s.strstart = max_start\n      /** * FLUSH_BLOCK(s, 0); ** */\n\n      flush_block_only(s, false)\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n\n    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n      /** * FLUSH_BLOCK(s, 0); ** */\n      flush_block_only(s, false)\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0\n\n  if (flush === Z_FINISH) {\n    /** * FLUSH_BLOCK(s, 1); ** */\n    flush_block_only(s, true)\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n\n    return BS_FINISH_DONE\n  }\n\n  if (s.strstart > s.block_start) {\n    /** * FLUSH_BLOCK(s, 0); ** */\n    flush_block_only(s, false)\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE\n}\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\n\nvar deflate_fast = function deflate_fast(s, flush) {\n  var hash_head\n  /* head of the hash chain */\n\n  var bflush\n  /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s)\n\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n\n      if (s.lookahead === 0) {\n        break\n        /* flush the current block */\n      }\n    }\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n\n    hash_head = 0\n    /* NIL */\n\n    if (s.lookahead >= MIN_MATCH$1) {\n      /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n      s.head[s.ins_h] = s.strstart\n      /***/\n    }\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n\n    if (\n      hash_head !== 0 &&\n      /* NIL */\n      s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head)\n      /* longest_match() sets match_start */\n    }\n\n    if (s.match_length >= MIN_MATCH$1) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ** */\n      bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1)\n      s.lookahead -= s.match_length\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n\n      if (\n        s.match_length <= s.max_lazy_match &&\n        /* max_insert_length */\n        s.lookahead >= MIN_MATCH$1\n      ) {\n        s.match_length--\n        /* string at strstart already in table */\n\n        do {\n          s.strstart++\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0)\n\n        s.strstart++\n      } else {\n        s.strstart += s.match_length\n        s.match_length = 0\n        s.ins_h = s.window[s.strstart]\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]) // #if MIN_MATCH != 3\n        //                Call UPDATE_HASH() MIN_MATCH-3 more times\n        // #endif\n\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n      /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n      bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n      s.lookahead--\n      s.strstart++\n    }\n\n    if (bflush) {\n      /** * FLUSH_BLOCK(s, 0); ** */\n      flush_block_only(s, false)\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n\n  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1\n\n  if (flush === Z_FINISH) {\n    /** * FLUSH_BLOCK(s, 1); ** */\n    flush_block_only(s, true)\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n\n    return BS_FINISH_DONE\n  }\n\n  if (s.last_lit) {\n    /** * FLUSH_BLOCK(s, 0); ** */\n    flush_block_only(s, false)\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE\n}\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\n\nvar deflate_slow = function deflate_slow(s, flush) {\n  var hash_head\n  /* head of hash chain */\n\n  var bflush\n  /* set if current block must be flushed */\n\n  var max_insert\n  /* Process the input block. */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s)\n\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n\n      if (s.lookahead === 0) {\n        break\n      }\n      /* flush the current block */\n    }\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n\n    hash_head = 0\n    /* NIL */\n\n    if (s.lookahead >= MIN_MATCH$1) {\n      /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n      s.head[s.ins_h] = s.strstart\n      /***/\n    }\n    /* Find the longest match, discarding those <= prev_length.\n     */\n\n    s.prev_length = s.match_length\n    s.prev_match = s.match_start\n    s.match_length = MIN_MATCH$1 - 1\n\n    if (\n      hash_head !== 0 &&\n      /* NIL */\n      s.prev_length < s.max_lazy_match &&\n      s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n      /* MAX_DIST(s) */\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head)\n      /* longest_match() sets match_start */\n\n      if (\n        s.match_length <= 5 &&\n        (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096))\n        /* TOO_FAR */\n      ) {\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH$1 - 1\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n\n    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH$1\n      /* Do not insert strings in hash table beyond this. */\n      // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);** */\n\n      bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1)\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n\n      s.lookahead -= s.prev_length - 1\n      s.prev_length -= 2\n\n      do {\n        if (++s.strstart <= max_insert) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n        }\n      } while (--s.prev_length !== 0)\n\n      s.match_available = 0\n      s.match_length = MIN_MATCH$1 - 1\n      s.strstart++\n\n      if (bflush) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n      /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n      bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1])\n\n      if (bflush) {\n        /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n        flush_block_only(s, false)\n        /***/\n      }\n\n      s.strstart++\n      s.lookahead--\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1\n      s.strstart++\n      s.lookahead--\n    }\n  } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n  if (s.match_available) {\n    // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n    /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n    bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1])\n    s.match_available = 0\n  }\n\n  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1\n\n  if (flush === Z_FINISH) {\n    /** * FLUSH_BLOCK(s, 1); ** */\n    flush_block_only(s, true)\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n\n    return BS_FINISH_DONE\n  }\n\n  if (s.last_lit) {\n    /** * FLUSH_BLOCK(s, 0); ** */\n    flush_block_only(s, false)\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE\n}\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\n\nvar deflate_rle = function deflate_rle(s, flush) {\n  var bflush\n  /* set if current block must be flushed */\n\n  var prev\n  /* byte at distance one to match */\n\n  var scan\n  var strend\n  /* scan goes up to strend for length of run */\n\n  var _win = s.window\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH$1) {\n      fill_window(s)\n\n      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n\n      if (s.lookahead === 0) {\n        break\n      }\n      /* flush the current block */\n    }\n    /* See how many times the previous byte repeats */\n\n    s.match_length = 0\n\n    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n      scan = s.strstart - 1\n      prev = _win[scan]\n\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH$1\n\n        do {\n          /* jshint noempty:false */\n        } while (\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          scan < strend\n        )\n\n        s.match_length = MAX_MATCH$1 - (strend - scan)\n\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead\n        }\n      } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n    if (s.match_length >= MIN_MATCH$1) {\n      // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n      bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1)\n      s.lookahead -= s.match_length\n      s.strstart += s.match_length\n      s.match_length = 0\n    } else {\n      /* No match, output a literal byte */\n      // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n      /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n      bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n      s.lookahead--\n      s.strstart++\n    }\n\n    if (bflush) {\n      /** * FLUSH_BLOCK(s, 0); ** */\n      flush_block_only(s, false)\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0\n\n  if (flush === Z_FINISH) {\n    /** * FLUSH_BLOCK(s, 1); ** */\n    flush_block_only(s, true)\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n\n    return BS_FINISH_DONE\n  }\n\n  if (s.last_lit) {\n    /** * FLUSH_BLOCK(s, 0); ** */\n    flush_block_only(s, false)\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE\n}\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\n\nvar deflate_huff = function deflate_huff(s, flush) {\n  var bflush\n  /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s)\n\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE\n        }\n\n        break\n        /* flush the current block */\n      }\n    }\n    /* Output a literal byte */\n\n    s.match_length = 0 // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n    /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n\n    bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n    s.lookahead--\n    s.strstart++\n\n    if (bflush) {\n      /** * FLUSH_BLOCK(s, 0); ** */\n      flush_block_only(s, false)\n\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0\n\n  if (flush === Z_FINISH) {\n    /** * FLUSH_BLOCK(s, 1); ** */\n    flush_block_only(s, true)\n\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n\n    return BS_FINISH_DONE\n  }\n\n  if (s.last_lit) {\n    /** * FLUSH_BLOCK(s, 0); ** */\n    flush_block_only(s, false)\n\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE\n}\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\n\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length\n  this.max_lazy = max_lazy\n  this.nice_length = nice_length\n  this.max_chain = max_chain\n  this.func = func\n}\n\nvar configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),\n  /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),\n  /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),\n  /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),\n  /* 3 */\n  new Config(4, 4, 16, 16, deflate_slow),\n  /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),\n  /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),\n  /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),\n  /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),\n  /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow),\n  /* 9 max compression */\n]\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\n\nvar lm_init = function lm_init(s) {\n  s.window_size = 2 * s.w_size\n  /** * CLEAR_HASH(s); ** */\n\n  zero$1(s.head) // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n\n  s.max_lazy_match = configuration_table[s.level].max_lazy\n  s.good_match = configuration_table[s.level].good_length\n  s.nice_match = configuration_table[s.level].nice_length\n  s.max_chain_length = configuration_table[s.level].max_chain\n  s.strstart = 0\n  s.block_start = 0\n  s.lookahead = 0\n  s.insert = 0\n  s.match_length = s.prev_length = MIN_MATCH$1 - 1\n  s.match_available = 0\n  s.ins_h = 0\n}\n\nfunction DeflateState() {\n  this.strm = null\n  /* pointer back to this zlib stream */\n\n  this.status = 0\n  /* as the name implies */\n\n  this.pending_buf = null\n  /* output still pending */\n\n  this.pending_buf_size = 0\n  /* size of pending_buf */\n\n  this.pending_out = 0\n  /* next pending byte to output to the stream */\n\n  this.pending = 0\n  /* nb of bytes in the pending buffer */\n\n  this.wrap = 0\n  /* bit 0 true for zlib, bit 1 true for gzip */\n\n  this.gzhead = null\n  /* gzip header information to write */\n\n  this.gzindex = 0\n  /* where in extra, name, or comment */\n\n  this.method = Z_DEFLATED\n  /* can only be DEFLATED */\n\n  this.last_flush = -1\n  /* value of flush param for previous deflate call */\n\n  this.w_size = 0\n  /* LZ77 window size (32K by default) */\n\n  this.w_bits = 0\n  /* log2(w_size)  (8..16) */\n\n  this.w_mask = 0\n  /* w_size - 1 */\n\n  this.window = null\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null\n  /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0\n  /* hash index of string to be inserted */\n\n  this.hash_size = 0\n  /* number of elements in hash table */\n\n  this.hash_bits = 0\n  /* log2(hash_size) */\n\n  this.hash_mask = 0\n  /* hash_size-1 */\n\n  this.hash_shift = 0\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0\n  /* length of best match */\n\n  this.prev_match = 0\n  /* previous match */\n\n  this.match_available = 0\n  /* set if previous match exists */\n\n  this.strstart = 0\n  /* start of string to insert */\n\n  this.match_start = 0\n  /* start of matching string */\n\n  this.lookahead = 0\n  /* number of valid bytes ahead in window */\n\n  this.prev_length = 0\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  // this.max_insert_length = 0;\n\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0\n  /* compression level (1..9) */\n\n  this.strategy = 0\n  /* favor or force Huffman coding */\n\n  this.good_match = 0\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0\n  /* Stop searching when current match exceeds this */\n\n  /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n\n  this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2)\n  this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2)\n  this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2)\n  zero$1(this.dyn_ltree)\n  zero$1(this.dyn_dtree)\n  zero$1(this.bl_tree)\n  this.l_desc = null\n  /* desc. for literal tree */\n\n  this.d_desc = null\n  /* desc. for distance tree */\n\n  this.bl_desc = null\n  /* desc. for bit length tree */\n  // ush bl_count[MAX_BITS+1];\n\n  this.bl_count = new Uint16Array(MAX_BITS$1 + 1)\n  /* number of codes at each bit length for an optimal tree */\n  // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n  this.heap = new Uint16Array(2 * L_CODES$1 + 1)\n  /* heap used to build the Huffman trees */\n\n  zero$1(this.heap)\n  this.heap_len = 0\n  /* number of elements in the heap */\n\n  this.heap_max = 0\n  /* element of largest frequency */\n\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES$1 + 1) // uch depth[2*L_CODES+1];\n\n  zero$1(this.depth)\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0\n  /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0\n  /* running index in l_buf */\n\n  this.d_buf = 0\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0\n  /* bit length of current block with optimal trees */\n\n  this.static_len = 0\n  /* bit length of current block with static trees */\n\n  this.matches = 0\n  /* number of string matches in current block */\n\n  this.insert = 0\n  /* bytes at end of window left to insert */\n\n  this.bi_buf = 0\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n\n  this.bi_valid = 0\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  // this.high_water = 0;\n\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\nvar deflateResetKeep = function deflateResetKeep(strm) {\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR)\n  }\n\n  strm.total_in = strm.total_out = 0\n  strm.data_type = Z_UNKNOWN$1\n  var s = strm.state\n  s.pending = 0\n  s.pending_out = 0\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n\n  s.status = s.wrap ? INIT_STATE : BUSY_STATE\n  strm.adler =\n    s.wrap === 2\n      ? 0 // crc32(0, Z_NULL, 0)\n      : 1 // adler32(0, Z_NULL, 0)\n\n  s.last_flush = Z_NO_FLUSH\n\n  _tr_init$1(s)\n\n  return Z_OK\n}\n\nvar deflateReset = function deflateReset(strm) {\n  var ret = deflateResetKeep(strm)\n\n  if (ret === Z_OK) {\n    lm_init(strm.state)\n  }\n\n  return ret\n}\n\nvar deflateSetHeader = function deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR\n  }\n\n  if (strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR\n  }\n\n  strm.state.gzhead = head\n  return Z_OK\n}\n\nvar deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) {\n    // === Z_NULL\n    return Z_STREAM_ERROR\n  }\n\n  var wrap = 1\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6\n  }\n\n  if (windowBits < 0) {\n    /* suppress zlib wrapper */\n    wrap = 0\n    windowBits = -windowBits\n  } else if (windowBits > 15) {\n    wrap = 2\n    /* write gzip wrapper instead */\n\n    windowBits -= 16\n  }\n\n  if (\n    memLevel < 1 ||\n    memLevel > MAX_MEM_LEVEL ||\n    method !== Z_DEFLATED ||\n    windowBits < 8 ||\n    windowBits > 15 ||\n    level < 0 ||\n    level > 9 ||\n    strategy < 0 ||\n    strategy > Z_FIXED$1\n  ) {\n    return err(strm, Z_STREAM_ERROR)\n  }\n\n  if (windowBits === 8) {\n    windowBits = 9\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState()\n  strm.state = s\n  s.strm = strm\n  s.wrap = wrap\n  s.gzhead = null\n  s.w_bits = windowBits\n  s.w_size = 1 << s.w_bits\n  s.w_mask = s.w_size - 1\n  s.hash_bits = memLevel + 7\n  s.hash_size = 1 << s.hash_bits\n  s.hash_mask = s.hash_size - 1\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1)\n  s.window = new Uint8Array(s.w_size * 2)\n  s.head = new Uint16Array(s.hash_size)\n  s.prev = new Uint16Array(s.w_size) // Don't need mem init magic for JS.\n  // s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6)\n  /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4\n  // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  // s->pending_buf = (uchf *) overlay;\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  s.pending_buf = new Uint8Array(s.pending_buf_size)\n  // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n  s.d_buf = 1 * s.lit_bufsize // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n  s.l_buf = (1 + 2) * s.lit_bufsize\n  s.level = level\n  s.strategy = strategy\n  s.method = method\n  return deflateReset(strm)\n}\n\nvar deflateInit = function deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)\n}\n\nvar deflate = function deflate(strm, flush) {\n  var beg\n  var val // for gzip header write only\n\n  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR\n  }\n\n  var s = strm.state\n\n  if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)\n  }\n\n  s.strm = strm\n  /* just in case */\n\n  var old_flush = s.last_flush\n  s.last_flush = flush\n  /* Write the header */\n\n  if (s.status === INIT_STATE) {\n    if (s.wrap === 2) {\n      // GZIP header\n      strm.adler = 0 // crc32(0L, Z_NULL, 0);\n\n      put_byte(s, 31)\n      put_byte(s, 139)\n      put_byte(s, 8)\n\n      if (!s.gzhead) {\n        // s->gzhead == Z_NULL\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)\n        put_byte(s, OS_CODE)\n        s.status = BUSY_STATE\n      } else {\n        put_byte(\n          s,\n          (s.gzhead.text ? 1 : 0) +\n            (s.gzhead.hcrc ? 2 : 0) +\n            (!s.gzhead.extra ? 0 : 4) +\n            (!s.gzhead.name ? 0 : 8) +\n            (!s.gzhead.comment ? 0 : 16)\n        )\n        put_byte(s, s.gzhead.time & 0xff)\n        put_byte(s, (s.gzhead.time >> 8) & 0xff)\n        put_byte(s, (s.gzhead.time >> 16) & 0xff)\n        put_byte(s, (s.gzhead.time >> 24) & 0xff)\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)\n        put_byte(s, s.gzhead.os & 0xff)\n\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff)\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff)\n        }\n\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0)\n        }\n\n        s.gzindex = 0\n        s.status = EXTRA_STATE\n      }\n    } // DEFLATE header\n    else {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8\n      var level_flags = -1\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0\n      } else if (s.level < 6) {\n        level_flags = 1\n      } else if (s.level === 6) {\n        level_flags = 2\n      } else {\n        level_flags = 3\n      }\n\n      header |= level_flags << 6\n\n      if (s.strstart !== 0) {\n        header |= PRESET_DICT\n      }\n\n      header += 31 - (header % 31)\n      s.status = BUSY_STATE\n      putShortMSB(s, header)\n      /* Save the adler32 of the preset dictionary: */\n\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16)\n        putShortMSB(s, strm.adler & 0xffff)\n      }\n\n      strm.adler = 1 // adler32(0L, Z_NULL, 0);\n    }\n  } // #ifdef GZIP\n\n  if (s.status === EXTRA_STATE) {\n    if (\n      s.gzhead.extra\n      /* != Z_NULL */\n    ) {\n      beg = s.pending\n      /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          flush_pending(strm)\n          beg = s.pending\n\n          if (s.pending === s.pending_buf_size) {\n            break\n          }\n        }\n\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff)\n        s.gzindex++\n      }\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n      }\n\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0\n        s.status = NAME_STATE\n      }\n    } else {\n      s.status = NAME_STATE\n    }\n  }\n\n  if (s.status === NAME_STATE) {\n    if (\n      s.gzhead.name\n      /* != Z_NULL */\n    ) {\n      beg = s.pending\n      /* start of bytes to update crc */\n      // int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          flush_pending(strm)\n          beg = s.pending\n\n          if (s.pending === s.pending_buf_size) {\n            val = 1\n            break\n          }\n        } // JS specific: little magic to add zero terminator to end of string\n\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff\n        } else {\n          val = 0\n        }\n\n        put_byte(s, val)\n      } while (val !== 0)\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n      }\n\n      if (val === 0) {\n        s.gzindex = 0\n        s.status = COMMENT_STATE\n      }\n    } else {\n      s.status = COMMENT_STATE\n    }\n  }\n\n  if (s.status === COMMENT_STATE) {\n    if (\n      s.gzhead.comment\n      /* != Z_NULL */\n    ) {\n      beg = s.pending\n      /* start of bytes to update crc */\n      // int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          flush_pending(strm)\n          beg = s.pending\n\n          if (s.pending === s.pending_buf_size) {\n            val = 1\n            break\n          }\n        } // JS specific: little magic to add zero terminator to end of string\n\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff\n        } else {\n          val = 0\n        }\n\n        put_byte(s, val)\n      } while (val !== 0)\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n      }\n\n      if (val === 0) {\n        s.status = HCRC_STATE\n      }\n    } else {\n      s.status = HCRC_STATE\n    }\n  }\n\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm)\n      }\n\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff)\n        put_byte(s, (strm.adler >> 8) & 0xff)\n        strm.adler = 0 // crc32(0L, Z_NULL, 0);\n\n        s.status = BUSY_STATE\n      }\n    } else {\n      s.status = BUSY_STATE\n    }\n  } // #endif\n\n  /* Flush as much pending output as possible */\n\n  if (s.pending !== 0) {\n    flush_pending(strm)\n\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1\n      return Z_OK\n    }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR)\n  }\n  /* User must not provide more input after the first FINISH: */\n\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR)\n  }\n  /* Start a new block or continue the current one.\n   */\n\n  if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate =\n      s.strategy === Z_HUFFMAN_ONLY\n        ? deflate_huff(s, flush)\n        : s.strategy === Z_RLE\n        ? deflate_rle(s, flush)\n        : configuration_table[s.level].func(s, flush)\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE\n    }\n\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1\n        /* avoid BUF_ERROR next call, see above */\n      }\n\n      return Z_OK\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align$1(s)\n      } else if (flush !== Z_BLOCK) {\n        /* FULL_FLUSH or SYNC_FLUSH */\n        _tr_stored_block$1(s, 0, 0, false)\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n\n        if (flush === Z_FULL_FLUSH) {\n          /** * CLEAR_HASH(s); ** */\n\n          /* forget history */\n          zero$1(s.head) // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0\n            s.block_start = 0\n            s.insert = 0\n          }\n        }\n      }\n\n      flush_pending(strm)\n\n      if (strm.avail_out === 0) {\n        s.last_flush = -1\n        /* avoid BUF_ERROR at next call, see above */\n\n        return Z_OK\n      }\n    }\n  } // Assert(strm->avail_out > 0, \"bug2\");\n  // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) {\n    return Z_OK\n  }\n\n  if (s.wrap <= 0) {\n    return Z_STREAM_END\n  }\n  /* Write the trailer */\n\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff)\n    put_byte(s, (strm.adler >> 8) & 0xff)\n    put_byte(s, (strm.adler >> 16) & 0xff)\n    put_byte(s, (strm.adler >> 24) & 0xff)\n    put_byte(s, strm.total_in & 0xff)\n    put_byte(s, (strm.total_in >> 8) & 0xff)\n    put_byte(s, (strm.total_in >> 16) & 0xff)\n    put_byte(s, (strm.total_in >> 24) & 0xff)\n  } else {\n    putShortMSB(s, strm.adler >>> 16)\n    putShortMSB(s, strm.adler & 0xffff)\n  }\n\n  flush_pending(strm)\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n\n  if (s.wrap > 0) {\n    s.wrap = -s.wrap\n  }\n  /* write the trailer only once! */\n\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END\n}\n\nvar deflateEnd = function deflateEnd(strm) {\n  if (\n    !strm ||\n    /* == Z_NULL */\n    !strm.state\n    /* == Z_NULL */\n  ) {\n    return Z_STREAM_ERROR\n  }\n\n  var status = strm.state.status\n\n  if (\n    status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR)\n  }\n\n  strm.state = null\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK\n}\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\n\nvar deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length\n\n  if (\n    !strm ||\n    /* == Z_NULL */\n    !strm.state\n    /* == Z_NULL */\n  ) {\n    return Z_STREAM_ERROR\n  }\n\n  var s = strm.state\n  var wrap = s.wrap\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR\n  }\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0)\n  }\n\n  s.wrap = 0\n  /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {\n      /* already empty otherwise */\n\n      /** * CLEAR_HASH(s); ** */\n      zero$1(s.head) // Fill with NIL (= 0);\n\n      s.strstart = 0\n      s.block_start = 0\n      s.insert = 0\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n\n    var tmpDict = new Uint8Array(s.w_size)\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0)\n    dictionary = tmpDict\n    dictLength = s.w_size\n  }\n  /* insert dictionary into window and hash */\n\n  var avail = strm.avail_in\n  var next = strm.next_in\n  var input = strm.input\n  strm.avail_in = dictLength\n  strm.next_in = 0\n  strm.input = dictionary\n  fill_window(s)\n\n  while (s.lookahead >= MIN_MATCH$1) {\n    var str = s.strstart\n    var n = s.lookahead - (MIN_MATCH$1 - 1)\n\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1])\n      s.prev[str & s.w_mask] = s.head[s.ins_h]\n      s.head[s.ins_h] = str\n      str++\n    } while (--n)\n\n    s.strstart = str\n    s.lookahead = MIN_MATCH$1 - 1\n    fill_window(s)\n  }\n\n  s.strstart += s.lookahead\n  s.block_start = s.strstart\n  s.insert = s.lookahead\n  s.lookahead = 0\n  s.match_length = s.prev_length = MIN_MATCH$1 - 1\n  s.match_available = 0\n  strm.next_in = next\n  strm.input = input\n  strm.avail_in = avail\n  s.wrap = wrap\n  return Z_OK\n}\n\nvar deflateInit_1 = deflateInit\nvar deflateInit2_1 = deflateInit2\nvar deflateReset_1 = deflateReset\nvar deflateResetKeep_1 = deflateResetKeep\nvar deflateSetHeader_1 = deflateSetHeader\nvar deflate_2 = deflate\nvar deflateEnd_1 = deflateEnd\nvar deflateSetDictionary_1 = deflateSetDictionary\nvar deflateInfo = 'pako deflate (from Nodeca project)'\n/* Not implemented\n  module.exports.deflateBound = deflateBound;\n  module.exports.deflateCopy = deflateCopy;\n  module.exports.deflateParams = deflateParams;\n  module.exports.deflatePending = deflatePending;\n  module.exports.deflatePrime = deflatePrime;\n  module.exports.deflateTune = deflateTune;\n  */\n\nvar deflate_1 = {\n  deflateInit: deflateInit_1,\n  deflateInit2: deflateInit2_1,\n  deflateReset: deflateReset_1,\n  deflateResetKeep: deflateResetKeep_1,\n  deflateSetHeader: deflateSetHeader_1,\n  deflate: deflate_2,\n  deflateEnd: deflateEnd_1,\n  deflateSetDictionary: deflateSetDictionary_1,\n  deflateInfo,\n}\n\n// Join array of chunks to single array.\nfunction flattenChunks(chunks) {\n  // calculate data length\n  var len = 0\n\n  for (var i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length\n  } // join chunks\n\n  var result = new Uint8Array(len)\n\n  for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n    var chunk = chunks[_i]\n    result.set(chunk, pos)\n    pos += chunk.length\n  }\n\n  return result\n}\n\n// String encode/decode helpers\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\n\nvar _utf8len = new Uint8Array(256)\n\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1\n}\n\n_utf8len[254] = _utf8len[254] = 1 // Invalid sequence start\n// convert string to array (typed, when possible)\n\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null // JS specific, because we have no pointers\n\n  this.next_in = 0\n  /* number of bytes available at input */\n\n  this.avail_in = 0\n  /* total number of input bytes read so far */\n\n  this.total_in = 0\n  /* next output byte should be put there */\n\n  this.output = null // JS specific, because we have no pointers\n\n  this.next_out = 0\n  /* remaining free space at output */\n\n  this.avail_out = 0\n  /* total number of bytes output so far */\n\n  this.total_out = 0\n  /* last error message, NULL if no error */\n\n  this.msg = ''\n  /* Z_NULL */\n  /* not visible by applications */\n\n  this.state = null\n  /* best guess about the data type: binary or text */\n\n  this.data_type = 2\n  /* Z_UNKNOWN */\n  /* adler32 value of the uncompressed data */\n\n  this.adler = 0\n}\n\nvar zstream = ZStream\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nvar toString = Object.prototype.toString\n/* Public constants ========================================================== */\n\n/* =========================================================================== */\n\nvar Z_NO_FLUSH$1 = constants.Z_NO_FLUSH\nvar Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH\nvar Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH\nvar Z_FINISH$1 = constants.Z_FINISH\nvar Z_OK$1 = constants.Z_OK\nvar Z_STREAM_END$1 = constants.Z_STREAM_END\nvar Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION\nvar Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY\nvar Z_DEFLATED$1 = constants.Z_DEFLATED\n/* =========================================================================== */\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n * */\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n * */\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n * */\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n * */\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n * */\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * * `chunkSize` - size of generated data chunks (16K by default)\n * * `raw` (Boolean) - do raw deflate\n * * `gzip` (Boolean) - create gzip wrapper\n * * `header` (Object) - custom header for gzip\n * ** `text` (Boolean) - true if compressed data believed to be text\n * ** `time` (Number) - modification time, unix timestamp\n * ** `os` (Number) - operation system code\n * ** `extra` (Array) - array of bytes with extra data (max 65536)\n * ** `name` (String) - file name (binary string)\n * ** `comment` (String) - comment (binary string)\n * ** `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n * */\n\nexport function Deflate() {\n  this.options = {\n    level: Z_DEFAULT_COMPRESSION$1,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY$1,\n  }\n  var opt = this.options\n\n  if (opt.raw && opt.windowBits > 0) {\n    opt.windowBits = -opt.windowBits\n  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n    opt.windowBits += 16\n  }\n\n  this.err = 0 // error code, if happens (0 = Z_OK)\n\n  this.msg = '' // error message\n\n  this.ended = false // used to avoid multiple onEnd() calls\n\n  this.chunks = [] // chunks of compressed data\n\n  this.strm = new zstream()\n  this.strm.avail_out = 0\n  var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy)\n\n  if (status !== Z_OK$1) {\n    throw new Error(messages[status])\n  }\n\n  if (opt.header) {\n    deflate_1.deflateSetHeader(this.strm, opt.header)\n  }\n\n  if (opt.dictionary) {\n    var dict // Convert data if needed\n\n    if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary)\n    } else {\n      dict = opt.dictionary\n    }\n\n    status = deflate_1.deflateSetDictionary(this.strm, dict)\n\n    if (status !== Z_OK$1) {\n      throw new Error(messages[status])\n    }\n\n    this._dict_set = true\n  }\n}\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n * converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n * See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n * */\n\nDeflate.prototype.push = function (data, flush_mode) {\n  var strm = this.strm\n  var chunkSize = this.options.chunkSize\n\n  var status\n  var _flush_mode\n\n  if (this.ended) {\n    return false\n  }\n\n  if (flush_mode === ~~flush_mode) {\n    _flush_mode = flush_mode\n  } else {\n    _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1\n  } // Convert data if needed\n\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data)\n  } else {\n    strm.input = data\n  }\n\n  strm.next_in = 0\n  strm.avail_in = strm.input.length\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize)\n      strm.next_out = 0\n      strm.avail_out = chunkSize\n    } // Make sure avail_out > 6 to avoid repeating markers\n\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out))\n      strm.avail_out = 0\n      continue\n    }\n\n    status = deflate_1.deflate(strm, _flush_mode) // Ended => flush and finish\n\n    if (status === Z_STREAM_END$1) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out))\n      }\n\n      status = deflate_1.deflateEnd(this.strm)\n      this.onEnd(status)\n      this.ended = true\n      return status === Z_OK$1\n    } // Flush if out buffer full\n\n    if (strm.avail_out === 0) {\n      this.onData(strm.output)\n      continue\n    } // Flush if requested and has data\n\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out))\n      strm.avail_out = 0\n      continue\n    }\n\n    if (strm.avail_in === 0) {\n      break\n    }\n  }\n\n  return true\n}\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n * */\n\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk)\n}\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n * other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n * */\n\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$1) {\n    this.result = flattenChunks(this.chunks)\n  }\n\n  this.chunks = []\n  this.err = status\n  this.msg = this.strm.msg\n}\n\n// https://github.com/nodeca/pako/blob/26dff4fb3472c5532b3bd8856421146d35ab7592/lib/utils/strings.js#L26\nexport function string2buf(str) {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str)\n  }\n\n  let buf\n  let c\n  let c2\n  let m_pos\n  let i\n  let str_len = str.length\n  let buf_len = 0\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos)\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1)\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)\n        m_pos++\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len)\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos)\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1)\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)\n        m_pos++\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xc0 | (c >>> 6)\n      buf[i++] = 0x80 | (c & 0x3f)\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xe0 | (c >>> 12)\n      buf[i++] = 0x80 | ((c >>> 6) & 0x3f)\n      buf[i++] = 0x80 | (c & 0x3f)\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18)\n      buf[i++] = 0x80 | ((c >>> 12) & 0x3f)\n      buf[i++] = 0x80 | ((c >>> 6) & 0x3f)\n      buf[i++] = 0x80 | (c & 0x3f)\n    }\n  }\n\n  return buf\n}\n","/* eslint-disable local-rules/disallow-zone-js-patched-values */\nimport type { DeflateWorkerAction, DeflateWorkerResponse } from '@datadog/browser-core'\nimport { concatBuffers } from '@datadog/browser-core'\nimport { Deflate, constants, string2buf } from '../domain/deflate'\n\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport interface WorkerScope {\n  addEventListener(eventName: 'message', listener: (event: MessageEvent<DeflateWorkerAction>) => void): void\n  postMessage(response: DeflateWorkerResponse): void\n}\n\nexport function startWorker(workerScope: WorkerScope = self) {\n  try {\n    const streams = new Map<number, Deflate>()\n    workerScope.addEventListener('message', (event: MessageEvent<DeflateWorkerAction>) => {\n      try {\n        const response = handleAction(streams, event.data)\n        if (response) {\n          workerScope.postMessage(response)\n        }\n      } catch (error) {\n        sendError(workerScope, error, event.data && 'streamId' in event.data ? event.data.streamId : undefined)\n      }\n    })\n  } catch (error) {\n    sendError(workerScope, error)\n  }\n}\n\nfunction sendError(workerScope: WorkerScope, error: unknown, streamId?: number) {\n  try {\n    workerScope.postMessage({\n      type: 'errored',\n      error: error as Error,\n      streamId,\n    })\n  } catch (_) {\n    // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    workerScope.postMessage({\n      type: 'errored',\n      error: String(error),\n      streamId,\n    })\n  }\n}\n\nfunction handleAction(streams: Map<number, Deflate>, message: DeflateWorkerAction): DeflateWorkerResponse | undefined {\n  switch (message.action) {\n    case 'init':\n      return {\n        type: 'initialized',\n        version: __BUILD_ENV__SDK_VERSION__,\n      }\n\n    case 'write': {\n      let deflate = streams.get(message.streamId)\n      if (!deflate) {\n        deflate = new Deflate()\n        streams.set(message.streamId, deflate)\n      }\n      const previousChunksLength = deflate.chunks.length\n\n      // TextEncoder is not supported on old browser version like Edge 18, therefore we use string2buf\n      const binaryData = string2buf(message.data)\n      deflate.push(binaryData, constants.Z_SYNC_FLUSH)\n\n      return {\n        type: 'wrote',\n        id: message.id,\n        streamId: message.streamId,\n        result: concatBuffers(deflate.chunks.slice(previousChunksLength)),\n        trailer: makeTrailer(deflate),\n        additionalBytesCount: binaryData.length,\n      }\n    }\n\n    case 'reset':\n      streams.delete(message.streamId)\n      break\n  }\n}\n\n/**\n * Creates a buffer of bytes to append to the end of the Zlib stream to finish it. It is composed of\n * two parts:\n * * an empty deflate block as specified in https://www.rfc-editor.org/rfc/rfc1951.html#page-13 ,\n * which happens to be always 3, 0\n * * an adler32 checksum as specified in https://www.rfc-editor.org/rfc/rfc1950.html#page-4\n *\n * This is essentially what pako writes to the stream when invoking `deflate.push('',\n * constants.Z_FINISH)` operation after some data has been pushed with \"Z_SYNC_FLUSH\", but doing so\n * ends the stream and no more data can be pushed into it.\n *\n * Since we want to let the main thread end the stream synchronously at any point without needing to\n * send a message to the worker to flush it, we send back a trailer in each \"wrote\" response so the\n * main thread can just append it to the compressed data to end the stream.\n *\n * Beside creating a valid zlib stream, those 6 bits are expected to be here so the Datadog backend\n * can merge streams together (see internal doc).\n */\nfunction makeTrailer(deflate: Deflate): Uint8Array {\n  /* eslint-disable no-bitwise */\n  const adler = deflate.strm.adler\n  return new Uint8Array([\n    // Empty deflate block\n    3,\n    0,\n    // Adler32 checksum\n    (adler >>> 24) & 0xff,\n    (adler >>> 16) & 0xff,\n    (adler >>> 8) & 0xff,\n    adler & 0xff,\n  ])\n  /* eslint-enable no-bitwise */\n}\n","/* eslint-disable local-rules/disallow-side-effects */\nimport { startWorker } from '../boot/startWorker'\n\nstartWorker()\n"],"names":["concatBuffers","buffers","length","reduce","total","buffer","result","Uint8Array","offset","set","zero","buf","len","LITERALS","L_CODES","D_CODES","MAX_BITS","extra_lbits","extra_dbits","extra_blbits","bl_order","static_ltree","Array","static_dtree","_dist_code","_length_code","MAX_MATCH","base_length","static_l_desc","static_d_desc","static_bl_desc","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","bits","n","next_code","init_block","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","node","stree","heap_max","h","xbits","f","base","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block","stored_len","last","header","window","subarray","copy_block","_tr_flush_block_1","opt_lenb","static_lenb","max_blindex","level","strm","data_type","black_mask","detect_data_type","l_desc","d_desc","bl_desc","BL_CODES","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank","send_all_trees","trees","_tr_init","LENGTH_CODES","tr_static_init","_tr_flush_block","_tr_tally","lit_bufsize","_tr_align","STATIC_TREES","bi_flush","adler32_1","adler","pos","s1","s2","crcTable","Uint32Array","table","makeTable","crc32_1","crc","t","end","i","messages","constants","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_BINARY","Z_TEXT","Z_UNKNOWN","Z_DEFLATED","_tr_init$1","_tr_stored_block$1","_tr_flush_block$1","_tr_tally$1","_tr_align$1","Z_FIXED$1","Z_UNKNOWN$1","MAX_MATCH$1","MIN_LOOKAHEAD","HCRC_STATE","BUSY_STATE","FINISH_STATE","err","errorCode","msg","zero$1","HASH","prev","data","hash_shift","hash_mask","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","b","putShortMSB","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","p","more","str","start","size","_w_size","window_size","hash_size","head","avail_in","input","next_in","wrap","total_in","insert","ins_h","deflate_fast","flush","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH$1","deflate_slow","max_insert","prev_match","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","max_block_size","pending_buf_size","max_start","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","HEAP_SIZE$1","MAX_BITS$1","deflateResetKeep","deflateReset","ret","deflateInit2","windowBits","memLevel","deflate_1","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","text","hcrc","name","comment","time","os","charCodeAt","bstate","deflate_huff","deflate_rle","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo","_utf8len","q","zstream","Object","prototype","toString","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","Deflate","options","chunkSize","opt","raw","gzip","ended","chunks","Error","dict","call","_dict_set","sendError","workerScope","error","streamId","postMessage","type","_","String","makeTrailer","push","flush_mode","_flush_mode","onData","onEnd","chunk","l","_i","_l","flattenChunks","Map","addEventListener","event","response","streams","message","action","version","get","previousChunksLength","binaryData","TextEncoder","encode","c2","m_pos","str_len","buf_len","string2buf","id","slice","trailer","additionalBytesCount","delete","handleAction","undefined","startWorker"],"sourceRoot":""}