{"version":3,"file":"datadog-logs.js","mappings":"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","sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils/polyfills.ts","webpack:///../core/src/tools/getGlobalObject.ts","webpack:///../core/src/tools/utils/byteUtils.ts","webpack:///../core/src/tools/getZoneJsOriginalValue.ts","webpack:///../core/src/tools/timer.ts","webpack:///../core/src/tools/utils/functionUtils.ts","webpack:///../core/src/tools/serialisation/jsonStringify.ts","webpack:///../core/src/tools/utils/objectUtils.ts","webpack:///../core/src/domain/context/customerDataTracker.ts","webpack:///../core/src/tools/utils/typeUtils.ts","webpack:///../core/src/tools/mergeInto.ts","webpack:///../core/src/tools/serialisation/sanitize.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/context/contextManager.ts","webpack:///../core/src/domain/trackingConsent.ts","webpack:///../core/src/browser/addEventListener.ts","webpack:///../core/src/domain/context/storeContextManager.ts","webpack:///../core/src/tools/stackTrace/computeStackTrace.ts","webpack:///../core/src/tools/stackTrace/handlingStack.ts","webpack:///../core/src/domain/error/error.ts","webpack:///../core/src/tools/experimentalFeatures.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/tools/utils/timeUtils.ts","webpack:///../core/src/tools/sendToExtension.ts","webpack:///../core/src/tools/utils/numberUtils.ts","webpack:///../core/src/domain/connectivity/connectivity.ts","webpack:///../core/src/tools/utils/arrayUtils.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../core/src/domain/user/user.ts","webpack:///../core/src/boot/displayAlreadyInitializedError.ts","webpack:///../core/src/domain/error/error.types.ts","webpack:///./src/domain/logger/isAuthorized.ts","webpack:///./src/domain/logger.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/tools/utils/stringUtils.ts","webpack:///../core/src/tools/utils/browserDetection.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/session/storeStrategies/sessionStoreStrategy.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/domain/session/sessionState.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInCookie.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInLocalStorage.ts","webpack:///../core/src/domain/session/sessionStoreOperations.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/tools/utils/urlPolyfill.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///./src/domain/configuration.ts","webpack:///./src/boot/preStartLogs.ts","webpack:///./src/boot/logsPublicApi.ts","webpack:///../core/src/browser/pageExitObservable.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/tools/valueHistory.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///./src/domain/logsSessionManager.ts","webpack:///./src/domain/contexts/rumInternalContext.ts","webpack:///./src/domain/assembly.ts","webpack:///../core/src/domain/eventRateLimiter/createEventRateLimiter.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///./src/domain/console/consoleCollection.ts","webpack:///./src/domain/report/reportCollection.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///../core/src/tools/utils/responseUtils.ts","webpack:///./src/domain/networkError/networkErrorCollection.ts","webpack:///../core/src/tools/readBytesFromStream.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///../core/src/tools/abstractLifeCycle.ts","webpack:///./src/domain/lifeCycle.ts","webpack:///./src/domain/logger/loggerCollection.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../core/src/transport/flushController.ts","webpack:///../core/src/transport/startBatchWithReplica.ts","webpack:///../core/src/tools/encoder.ts","webpack:///./src/domain/logsTelemetry.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///./src/domain/contexts/commonContext.ts","webpack:///./src/boot/startLogs.ts","webpack:///./src/domain/reportError.ts","webpack:///./src/domain/runtimeError/runtimeErrorCollection.ts","webpack:///./src/domain/contexts/internalContext.ts","webpack:///./src/transport/startLogsBridge.ts","webpack:///./src/transport/startLogsBatch.ts"],"sourcesContent":["/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = (typeof ConsoleApiName)[keyof typeof ConsoleApiName]\n\ninterface Display {\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console\n\nexport const originalConsoleMethods = {} as Display\nObject.keys(ConsoleApiName).forEach((name) => {\n  originalConsoleMethods[name as ConsoleApiName] = globalConsole[name as ConsoleApiName]\n})\n\nconst PREFIX = 'Datadog Browser SDK:'\n\nexport const display: Display = {\n  debug: originalConsoleMethods.debug.bind(globalConsole, PREFIX),\n  log: originalConsoleMethods.log.bind(globalConsole, PREFIX),\n  info: originalConsoleMethods.info.bind(globalConsole, PREFIX),\n  warn: originalConsoleMethods.warn.bind(globalConsole, PREFIX),\n  error: originalConsoleMethods.error.bind(globalConsole, PREFIX),\n}\n\nexport const DOCS_ORIGIN = 'https://docs.datadoghq.com'\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(...args: any[]) {\n  if (debugMode) {\n    display.error('[MONITOR]', ...args)\n  }\n}\n","export function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(array: ArrayLike<unknown>, predicate: (item: unknown, index: number) => boolean): unknown {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function forEach<List extends { [index: number]: any }>(\n  list: List,\n  callback: (value: List[number], index: number, parent: List) => void\n) {\n  Array.prototype.forEach.call(list, callback as any)\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectEntries<T = unknown>(object: { [key: string]: T }): Array<[string, T]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign<T, U, V, W, X>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\n\nexport function getGlobalObject<T = typeof globalThis>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n","export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]) {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n","import { getGlobalObject } from './getGlobalObject'\n\nexport interface BrowserWindowWithZoneJs extends Window {\n  Zone?: {\n    // All Zone.js versions expose the __symbol__ method, but we observed that some website have a\n    // 'Zone' global variable unrelated to Zone.js, so let's consider this method optional\n    // nonetheless.\n    __symbol__?: (name: string) => string\n  }\n}\n\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue<Target, Name extends keyof Target & string>(\n  target: Target,\n  name: Name\n): Target[Name] {\n  const browserWindow = getGlobalObject<BrowserWindowWithZoneJs>()\n  let original: Target[Name] | undefined\n  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n    original = (target as any)[browserWindow.Zone.__symbol__(name)]\n  }\n  if (!original) {\n    original = target[name]\n  }\n  return original\n}\n","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue'\nimport { monitor } from './monitor'\nimport { getGlobalObject } from './getGlobalObject'\n\nexport type TimeoutId = ReturnType<typeof globalThis.setTimeout>\n\nexport function setTimeout(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay)\n}\n\nexport function clearTimeout(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId)\n}\n\nexport function setInterval(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay)\n}\n\nexport function clearInterval(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId)\n}\n","import type { TimeoutId } from '../timer'\nimport { setTimeout, clearTimeout } from '../timer'\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n","import { noop } from '../utils/functionUtils'\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(\n  value: unknown,\n  replacer?: Array<string | number>,\n  space?: string | number\n): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, replacer, space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\nexport interface ObjectWithToJsonMethod {\n  toJSON?: () => unknown\n}\n\nexport function detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n","import { assign } from './polyfills'\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n","import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport type { Context } from '../../tools/serialisation/context'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { DOCS_ORIGIN, display } from '../../tools/display'\nimport { isEmptyObject } from '../../tools/utils/objectUtils'\nimport type { CustomerDataType } from './contextConstants'\n\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE\n\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport const CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE\n\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type CustomerDataTracker = ReturnType<typeof createCustomerDataTracker>\nexport type CustomerDataTrackerManager = ReturnType<typeof createCustomerDataTrackerManager>\n\nexport const enum CustomerDataCompressionStatus {\n  Unknown,\n  Enabled,\n  Disabled,\n}\n\nexport function createCustomerDataTrackerManager(\n  compressionStatus: CustomerDataCompressionStatus = CustomerDataCompressionStatus.Disabled\n) {\n  const customerDataTrackers = new Map<CustomerDataType, CustomerDataTracker>()\n\n  let alreadyWarned = false\n  function checkCustomerDataLimit(initialBytesCount = 0) {\n    if (alreadyWarned || compressionStatus === CustomerDataCompressionStatus.Unknown) {\n      return\n    }\n\n    const bytesCountLimit =\n      compressionStatus === CustomerDataCompressionStatus.Disabled\n        ? CUSTOMER_DATA_BYTES_LIMIT\n        : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT\n\n    let bytesCount = initialBytesCount\n    customerDataTrackers.forEach((tracker) => {\n      bytesCount += tracker.getBytesCount()\n    })\n\n    if (bytesCount > bytesCountLimit) {\n      displayCustomerDataLimitReachedWarning(bytesCountLimit)\n      alreadyWarned = true\n    }\n  }\n\n  return {\n    /**\n     * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n     * bytes count will be counted independently from other detached trackers.\n     *\n     * This is particularly useful when we don't know when the tracker will be unused, so we don't\n     * leak memory (ex: when used in Logger instances).\n     */\n    createDetachedTracker: () => {\n      const tracker = createCustomerDataTracker(() => checkCustomerDataLimit(tracker.getBytesCount()))\n      return tracker\n    },\n\n    /**\n     * Creates a tracker if it doesn't exist, and returns it.\n     */\n    getOrCreateTracker: (type: CustomerDataType) => {\n      if (!customerDataTrackers.has(type)) {\n        customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit))\n      }\n      return customerDataTrackers.get(type)!\n    },\n\n    setCompressionStatus: (newCompressionStatus: CustomerDataCompressionStatus) => {\n      if (compressionStatus === CustomerDataCompressionStatus.Unknown) {\n        compressionStatus = newCompressionStatus\n        checkCustomerDataLimit()\n      }\n    },\n\n    getCompressionStatus: () => compressionStatus,\n\n    stop: () => {\n      customerDataTrackers.forEach((tracker) => tracker.stop())\n      customerDataTrackers.clear()\n    },\n  }\n}\n\nexport function createCustomerDataTracker(checkCustomerDataLimit: () => void) {\n  let bytesCountCache = 0\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled, cancel: cancelComputeBytesCount } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCount(jsonStringify(context)!)\n    checkCustomerDataLimit()\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  const resetBytesCount = () => {\n    cancelComputeBytesCount()\n    bytesCountCache = 0\n  }\n\n  return {\n    updateCustomerData: (context: Context) => {\n      if (isEmptyObject(context)) {\n        resetBytesCount()\n      } else {\n        computeBytesCountThrottled(context)\n      }\n    },\n    resetCustomerData: resetBytesCount,\n    getBytesCount: () => bytesCountCache,\n    stop: () => {\n      cancelComputeBytesCount()\n    },\n  }\n}\n\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit: number) {\n  display.warn(\n    `Customer data exceeds the recommended ${\n      bytesCountLimit / ONE_KIBI_BYTE\n    }KiB threshold. More details: ${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-threshold-warning`\n  )\n}\n","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n","import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n      TDestination extends undefined\n      ? TSource\n      : // case 3 - source is an array - see if it merges or overwrites\n        TSource extends any[]\n        ? TDestination extends any[]\n          ? TDestination & TSource\n          : TSource\n        : // case 4 - source is an object - see if it merges or overwrites\n          TSource extends object\n          ? TDestination extends object\n            ? TDestination extends any[]\n              ? TSource\n              : TDestination & TSource\n            : TSource\n          : // case 5 - cannot merge - return source\n            TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n","import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  let accumulatedCharacterCount = JSON.stringify(sanitizedData)?.length || 0\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value: object) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted,\n      }\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: (observable: Observable<T>) => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe(this) || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  return new Observable<T>((globalObservable) => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n}\n","import { deepClone } from '../../tools/mergeInto'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { Context } from '../../tools/serialisation/context'\nimport { Observable } from '../../tools/observable'\nimport type { CustomerDataTracker } from './customerDataTracker'\n\nexport type ContextManager = ReturnType<typeof createContextManager>\n\nexport function createContextManager(customerDataTracker: CustomerDataTracker) {\n  let context: Context = {}\n  const changeObservable = new Observable<void>()\n\n  const contextManager = {\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      if (getType(newContext) === 'object') {\n        context = sanitize(newContext)\n        customerDataTracker.updateCustomerData(context)\n      } else {\n        contextManager.clearContext()\n      }\n      changeObservable.notify()\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = sanitize(property)\n      customerDataTracker.updateCustomerData(context)\n      changeObservable.notify()\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n      customerDataTracker.updateCustomerData(context)\n      changeObservable.notify()\n    },\n\n    clearContext: () => {\n      context = {}\n      customerDataTracker.resetCustomerData()\n      changeObservable.notify()\n    },\n\n    changeObservable,\n  }\n  return contextManager\n}\n","import { Observable } from '../tools/observable'\n\nexport const TrackingConsent = {\n  GRANTED: 'granted',\n  NOT_GRANTED: 'not-granted',\n} as const\nexport type TrackingConsent = (typeof TrackingConsent)[keyof typeof TrackingConsent]\n\nexport interface TrackingConsentState {\n  tryToInit: (trackingConsent: TrackingConsent) => void\n  update: (trackingConsent: TrackingConsent) => void\n  isGranted: () => boolean\n  observable: Observable<void>\n}\n\nexport function createTrackingConsentState(currentConsent?: TrackingConsent): TrackingConsentState {\n  const observable = new Observable<void>()\n\n  return {\n    tryToInit(trackingConsent: TrackingConsent) {\n      if (!currentConsent) {\n        currentConsent = trackingConsent\n      }\n    },\n    update(trackingConsent: TrackingConsent) {\n      currentConsent = trackingConsent\n      observable.notify()\n    },\n    isGranted() {\n      return currentConsent === TrackingConsent.GRANTED\n    },\n    observable,\n  }\n}\n","import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { CookieStore, CookieStoreEventMap, VisualViewport, VisualViewportEventMap } from './types'\n\nexport type TrustableEvent<E extends Event = Event> = E & { __ddIsTrusted?: boolean }\n\n// We want to use a real enum (i.e. not a const enum) here, to be able to iterate over it to automatically add _ddIsTrusted in e2e tests\n// eslint-disable-next-line no-restricted-syntax\nexport enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n  STORAGE = 'storage',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n    ? DocumentEventMap\n    : T extends HTMLElement\n      ? HTMLElementEventMap\n      : T extends VisualViewport\n        ? VisualViewportEventMap\n        : T extends ShadowRoot\n          ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n            // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n            // through the ShadowRoot like \"change\" or \"input\"\n            GlobalEventHandlersEventMap\n          : T extends XMLHttpRequest\n            ? XMLHttpRequestEventMap\n            : T extends Performance\n              ? PerformanceEventMap\n              : T extends Worker\n                ? WorkerEventMap\n                : T extends CookieStore\n                  ? CookieStoreEventMap\n                  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: { allowUntrustedEvents?: boolean | undefined },\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: { allowUntrustedEvents?: boolean | undefined },\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const listenerWithMonitor = monitor((event: TrustableEvent) => {\n    if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n      return\n    }\n    if (once) {\n      stop()\n    }\n    listener(event as unknown as EventMapFor<Target>[EventName] & { type: EventName })\n  })\n\n  const options = passive ? { capture, passive } : capture\n\n  const add = getZoneJsOriginalValue(eventTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options))\n  }\n\n  return {\n    stop,\n  }\n}\n","import { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport type { Context } from '../../tools/serialisation/context'\nimport type { Configuration } from '../configuration'\nimport { combine } from '../../tools/mergeInto'\nimport type { ContextManager } from './contextManager'\nimport type { CustomerDataType } from './contextConstants'\n\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c'\n\nconst storageListeners: Array<{ stop: () => void }> = []\n\nexport function storeContextManager(\n  configuration: Configuration,\n  contextManager: ContextManager,\n  productKey: string,\n  customerDataType: CustomerDataType\n) {\n  const storageKey = buildStorageKey(productKey, customerDataType)\n\n  storageListeners.push(\n    addEventListener(configuration, window, DOM_EVENT.STORAGE, ({ key }) => {\n      if (storageKey === key) {\n        synchronizeWithStorage()\n      }\n    })\n  )\n  contextManager.changeObservable.subscribe(dumpToStorage)\n\n  contextManager.setContext(combine(getFromStorage(), contextManager.getContext()))\n\n  function synchronizeWithStorage() {\n    contextManager.setContext(getFromStorage())\n  }\n\n  function dumpToStorage() {\n    localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()))\n  }\n\n  function getFromStorage() {\n    const rawContext = localStorage.getItem(storageKey)\n    return rawContext !== null ? (JSON.parse(rawContext) as Context) : {}\n  }\n}\n\nexport function buildStorageKey(productKey: string, customerDataType: CustomerDataType) {\n  return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`\n}\n\nexport function removeStorageListeners() {\n  storageListeners.map((listener) => listener.stop())\n}\n","/**\n * Cross-browser stack trace computation.\n *\n * Reference implementation: https://github.com/csnover/TraceKit/blob/04530298073c3823de72deb0b97e7b38ca7bcb59/tracekit.js\n */\n\nimport { startsWith } from '../utils/polyfills'\n\nexport interface StackFrame {\n  url?: string\n  func?: string\n  /** The arguments passed to the function, if known. */\n  args?: string[]\n  line?: number\n  column?: number\n  /** An array of source code lines; the middle element corresponds to the correct line. */\n  context?: string[]\n}\n\nexport interface StackTrace {\n  name?: string\n  message?: string\n  url?: string\n  stack: StackFrame[]\n  incomplete?: boolean\n  partial?: boolean\n}\n\nconst UNKNOWN_FUNCTION = '?'\n\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function computeStackTraceFromOnErrorMessage(messageObj: unknown, url?: string, line?: number, column?: number) {\n  const stack = [{ url, column, line }]\n  const { name, message } = tryToParseMessage(messageObj)\n  return {\n    name,\n    message,\n    stack,\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/\n\nfunction tryToParseMessage(messageObj: unknown) {\n  let name\n  let message\n  if ({}.toString.call(messageObj) === '[object String]') {\n    ;[, name, message] = ERROR_TYPES_RE.exec(messageObj as string)!\n  }\n  return { name, message }\n}\n","import { callMonitored } from '../monitor'\nimport { noop } from '../utils/functionUtils'\nimport type { StackTrace } from './computeStackTrace'\nimport { computeStackTrace } from './computeStackTrace'\n\n/**\n * Creates a stacktrace without SDK internal frames.\n * Constraints:\n * - Has to be called at the utmost position of the call stack.\n * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n","import { sanitize } from '../../tools/serialisation/sanitize'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport type { ErrorSource, ErrorHandling, RawError, RawErrorCause, ErrorWithCause, NonErrorPrefix } from './error.types'\n\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error'\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: NonErrorPrefix\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  const isErrorInstance = originalError instanceof Error\n\n  const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError)\n  const stack = hasUsableStack(isErrorInstance, stackTrace)\n    ? toStackTraceString(stackTrace)\n    : NO_ERROR_STACK_PRESENT_MESSAGE\n  const causes = isErrorInstance ? flattenErrorCauses(originalError as ErrorWithCause, source) : undefined\n  const type = stackTrace?.name\n  const fingerprint = tryToGetFingerprint(originalError)\n\n  return {\n    startClocks,\n    source,\n    handling,\n    handlingStack,\n    originalError,\n    type,\n    message,\n    stack,\n    causes,\n    fingerprint,\n  }\n}\n\nfunction computeMessage(\n  stackTrace: StackTrace | undefined,\n  isErrorInstance: boolean,\n  nonErrorPrefix: NonErrorPrefix,\n  originalError: unknown\n) {\n  // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n  // TODO rework tracekit integration to avoid scattering error building logic\n  return stackTrace?.message && stackTrace?.name\n    ? stackTrace.message\n    : !isErrorInstance\n      ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))!}`\n      : 'Empty message'\n}\n\nfunction hasUsableStack(isErrorInstance: boolean, stackTrace?: StackTrace): stackTrace is StackTrace {\n  if (stackTrace === undefined) {\n    return false\n  }\n  if (isErrorInstance) {\n    return true\n  }\n  // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n  // TODO rework tracekit integration to avoid generating those unusable stack\n  return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined)\n}\n\nexport function tryToGetFingerprint(originalError: unknown) {\n  return originalError instanceof Error && 'dd_fingerprint' in originalError\n    ? String(originalError.dd_fingerprint)\n    : undefined\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\n\nimport { objectHasValue } from './utils/objectUtils'\n\n// eslint-disable-next-line no-restricted-syntax\nexport enum ExperimentalFeature {\n  WRITABLE_RESOURCE_GRAPHQL = 'writable_resource_graphql',\n  CUSTOM_VITALS = 'custom_vitals',\n  TOLERANT_RESOURCE_TIMINGS = 'tolerant_resource_timings',\n  REMOTE_CONFIGURATION = 'remote_configuration',\n  PLUGINS = 'plugins',\n}\n\nconst enabledExperimentalFeatures: Set<ExperimentalFeature> = new Set()\n\nexport function initFeatureFlags(enableExperimentalFeatures?: string[] | undefined) {\n  if (Array.isArray(enableExperimentalFeatures)) {\n    addExperimentalFeatures(\n      enableExperimentalFeatures.filter((flag): flag is ExperimentalFeature =>\n        objectHasValue(ExperimentalFeature, flag)\n      )\n    )\n  }\n}\n\nexport function addExperimentalFeatures(enabledFeatures: ExperimentalFeature[]): void {\n  enabledFeatures.forEach((flag) => {\n    enabledExperimentalFeatures.add(flag)\n  })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: ExperimentalFeature): boolean {\n  return enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures.clear()\n}\n\nexport function getExperimentalFeatures(): Set<ExperimentalFeature> {\n  return enabledExperimentalFeatures\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_FED_STAGING = 'dd0g-gov.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n\nexport const PCI_INTAKE_HOST_US1 = 'pci.browser-intake-datadoghq.com'\n","import { isNumber, round } from './numberUtils'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nexport function timeStampToClocks(timeStamp: TimeStamp) {\n  return { relative: getRelativeTime(timeStamp), timeStamp }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","interface BrowserWindow {\n  __ddBrowserSdkExtensionCallback?: (message: unknown) => void\n}\n\ntype ExtensionMessageType = 'logs' | 'record' | 'rum' | 'telemetry'\n\nexport function sendToExtension(type: ExtensionMessageType, payload: unknown) {\n  const callback = (window as BrowserWindow).__ddBrowserSdkExtensionCallback\n  if (callback) {\n    callback({ type, payload })\n  }\n}\n","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n","export type NetworkInterface = 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown'\nexport type EffectiveType = 'slow-2g' | '2g' | '3g' | '4g'\n\ninterface BrowserNavigator extends Navigator {\n  connection?: NetworkInformation\n}\n\nexport interface NetworkInformation {\n  type?: NetworkInterface\n  effectiveType?: EffectiveType\n}\n\nexport interface Connectivity {\n  status: 'connected' | 'not_connected'\n  interfaces?: NetworkInterface[]\n  effective_type?: EffectiveType\n  [key: string]: unknown\n}\n\nexport function getConnectivity(): Connectivity {\n  const navigator = window.navigator as BrowserNavigator\n  return {\n    status: navigator.onLine ? 'connected' : 'not_connected',\n    interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n    effective_type: navigator.connection?.effectiveType,\n  }\n}\n","import { arrayFrom } from './polyfills'\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n\nexport function removeItem<T>(array: T[], item: T) {\n  const index = array.indexOf(item)\n  if (index >= 0) {\n    array.splice(index, 1)\n  }\n}\n","import { removeItem } from './utils/arrayUtils'\n\nconst BUFFER_LIMIT = 500\n\nexport class BoundedBuffer<T = void> {\n  private buffer: Array<(arg: T) => void> = []\n\n  add(callback: (arg: T) => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  remove(callback: (arg: T) => void) {\n    removeItem(this.buffer, callback)\n  }\n\n  drain(arg: T) {\n    this.buffer.forEach((callback) => callback(arg))\n    this.buffer.length = 0\n  }\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent, TelemetryUsageEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n  usage: 'usage',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport interface RuntimeEnvInfo {\n  is_local_file: boolean\n  is_worker: boolean\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\nexport type RawTelemetryUsage = TelemetryUsageEvent['telemetry']['usage']\n","import type { Context } from '../../tools/serialisation/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { NO_ERROR_STACK_PRESENT_MESSAGE } from '../error/error'\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Configuration } from '../configuration'\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport { sendToExtension } from '../../tools/sendToExtension'\nimport { startsWith, arrayFrom, includes, assign } from '../../tools/utils/polyfills'\nimport { performDraw } from '../../tools/utils/numberUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { combine } from '../../tools/mergeInto'\nimport { NonErrorPrefix } from '../error/error.types'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { getConnectivity } from '../connectivity'\nimport { BoundedBuffer } from '../../tools/boundedBuffer'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type {\n  RawTelemetryConfiguration,\n  RawTelemetryEvent,\n  RuntimeEnvInfo,\n  RawTelemetryUsage,\n} from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'https://d3uc069fcn7uxw.cloudfront.net',\n  'https://d20xtzwzcl0ceb.cloudfront.net',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n  enabled: boolean\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\n// eslint-disable-next-line local-rules/disallow-side-effects\nlet preStartTelemetryBuffer = new BoundedBuffer()\nlet onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n  preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event))\n}\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n  const alreadySentEvents = new Set<string>()\n\n  const telemetryEnabled =\n    !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate)\n\n  const telemetryEnabledPerType = {\n    [TelemetryType.log]: telemetryEnabled,\n    [TelemetryType.configuration]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n    [TelemetryType.usage]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n  }\n\n  const runtimeEnvInfo = getRuntimeEnvInfo()\n  onRawTelemetryEventCollected = (rawEvent: RawTelemetryEvent) => {\n    const stringifiedEvent = jsonStringify(rawEvent)!\n    if (\n      telemetryEnabledPerType[rawEvent.type!] &&\n      alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&\n      !alreadySentEvents.has(stringifiedEvent)\n    ) {\n      const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo)\n      observable.notify(event)\n      sendToExtension('telemetry', event)\n      alreadySentEvents.add(stringifiedEvent)\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  function toTelemetryEvent(\n    telemetryService: TelemetryService,\n    event: RawTelemetryEvent,\n    runtimeEnvInfo: RuntimeEnvInfo\n  ): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: combine(event, {\n          runtime_env: runtimeEnvInfo,\n          connectivity: getConnectivity(),\n        }),\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    ) as TelemetryEvent & Context\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n    enabled: telemetryEnabled,\n  }\n}\nfunction getRuntimeEnvInfo(): RuntimeEnvInfo {\n  return {\n    is_local_file: window.location.protocol === 'file:',\n    is_worker: 'WorkerGlobalScope' in self,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\n// need to be called after telemetry context is provided and observers are registered\nexport function drainPreStartTelemetry() {\n  preStartTelemetryBuffer.drain()\n}\n\nexport function resetTelemetry() {\n  preStartTelemetryBuffer = new BoundedBuffer()\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event))\n  }\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  onRawTelemetryEventCollected(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown, context?: Context) {\n  onRawTelemetryEventCollected(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e),\n      context\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.configuration,\n    configuration,\n  })\n}\n\nexport function addTelemetryUsage(usage: RawTelemetryUsage) {\n  onRawTelemetryEventCollected({\n    type: TelemetryType.usage,\n    usage,\n  })\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n    },\n    message: `${NonErrorPrefix.UNCAUGHT} ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import type { Context } from '../../tools/serialisation/context'\nimport { display } from '../../tools/display'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { User } from './user.types'\n\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser: Context): Context {\n  // We shallow clone only to prevent mutation of user data.\n  const user = assign({}, newUser)\n  const keys = ['id', 'name', 'email']\n  keys.forEach((key) => {\n    if (key in user) {\n      user[key] = String(user[key])\n    }\n  })\n  return user\n}\n\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser: User): boolean {\n  const isValid = getType(newUser) === 'object'\n  if (!isValid) {\n    display.error('Unsupported user:', newUser)\n  }\n  return isValid\n}\n","import type { InitConfiguration } from '../domain/configuration'\nimport { display } from '../tools/display'\n\nexport function displayAlreadyInitializedError(sdkName: 'DD_RUM' | 'DD_LOGS', initConfiguration: InitConfiguration) {\n  if (!initConfiguration.silentMultipleInit) {\n    display.error(`${sdkName} is already initialized.`)\n  }\n}\n","import type { ClocksState } from '../../tools/utils/timeUtils'\n\n// TS v4.6 introduced Error.cause[1] typed as `Error`. TS v4.8 changed Error.cause to be\n// `unknown`[2].\n//\n// Because we still support TS 3.8, we need to declare our own type. We can remove it once we drop\n// support for TS v4.7 and before. The 'cause' property defined by TS needs to be omitted because\n// we define it with a type `unknown` which is incompatible with TS 4.6 and 4.7.\n//\n// [1]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/#target-es2022\n// [2]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#lib-d-ts-updates\nexport interface ErrorWithCause extends Omit<Error, 'cause'> {\n  cause?: unknown\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport type Csp = {\n  disposition: 'enforce' | 'report'\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n  fingerprint?: string\n  csp?: Csp\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum NonErrorPrefix {\n  UNCAUGHT = 'Uncaught',\n  PROVIDED = 'Provided',\n}\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = (typeof ErrorSource)[keyof typeof ErrorSource]\n","import { includes } from '@datadog/browser-core'\nimport type { Logger, HandlerType } from '../logger'\n\nexport function isAuthorized(status: StatusType, handlerType: HandlerType, logger: Logger) {\n  const loggerHandler = logger.getHandler()\n  const sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [loggerHandler]\n  return (\n    STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && includes(sanitizedHandlerType, handlerType)\n  )\n}\n\nexport const StatusType = {\n  ok: 'ok',\n  debug: 'debug',\n  info: 'info',\n  notice: 'notice',\n  warn: 'warn',\n  error: 'error',\n  critical: 'critical',\n  alert: 'alert',\n  emerg: 'emerg',\n} as const\n\nexport const STATUS_PRIORITIES: { [key in StatusType]: number } = {\n  [StatusType.ok]: 0,\n  [StatusType.debug]: 1,\n  [StatusType.info]: 2,\n  [StatusType.notice]: 4,\n  [StatusType.warn]: 5,\n  [StatusType.error]: 6,\n  [StatusType.critical]: 7,\n  [StatusType.alert]: 8,\n  [StatusType.emerg]: 9,\n}\n\nexport type StatusType = (typeof StatusType)[keyof typeof StatusType]\n","import type { Context, ContextManager, CustomerDataTracker } from '@datadog/browser-core'\nimport {\n  clocksNow,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  combine,\n  createContextManager,\n  ErrorSource,\n  monitored,\n  sanitize,\n  NonErrorPrefix,\n  createHandlingStack,\n} from '@datadog/browser-core'\n\nimport type { RawLoggerLogsEvent } from '../rawLogsEvent.types'\nimport { isAuthorized, StatusType } from './logger/isAuthorized'\n\nexport interface LogsMessage {\n  message: string\n  status: StatusType\n  context?: Context\n}\n\nexport const HandlerType = {\n  console: 'console',\n  http: 'http',\n  silent: 'silent',\n} as const\n\nexport type HandlerType = (typeof HandlerType)[keyof typeof HandlerType]\nexport const STATUSES = Object.keys(StatusType) as StatusType[]\n\n// note: it is safe to merge declarations as long as the methods are actually defined on the prototype\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class Logger {\n  private contextManager: ContextManager\n\n  constructor(\n    private handleLogStrategy: (logsMessage: LogsMessage, logger: Logger, handlingStack?: string) => void,\n    customerDataTracker: CustomerDataTracker,\n    name?: string,\n    private handlerType: HandlerType | HandlerType[] = HandlerType.http,\n    private level: StatusType = StatusType.debug,\n    loggerContext: object = {}\n  ) {\n    this.contextManager = createContextManager(customerDataTracker)\n    this.contextManager.setContext(loggerContext as Context)\n    if (name) {\n      this.contextManager.setContextProperty('logger', { name })\n    }\n  }\n\n  @monitored\n  logImplementation(\n    message: string,\n    messageContext?: object,\n    status: StatusType = StatusType.info,\n    error?: Error,\n    handlingStack?: string\n  ) {\n    let errorContext: RawLoggerLogsEvent['error']\n\n    if (error !== undefined && error !== null) {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.LOGGER,\n        handling: ErrorHandling.HANDLED,\n        startClocks: clocksNow(),\n      })\n\n      errorContext = {\n        stack: rawError.stack,\n        kind: rawError.type,\n        message: rawError.message,\n        causes: rawError.causes,\n      }\n    }\n\n    const sanitizedMessageContext = sanitize(messageContext) as Context\n\n    const context = errorContext\n      ? (combine({ error: errorContext }, sanitizedMessageContext) as Context)\n      : sanitizedMessageContext\n\n    this.handleLogStrategy(\n      {\n        message: sanitize(message)!,\n        context,\n        status,\n      },\n      this,\n      handlingStack\n    )\n  }\n\n  log(message: string, messageContext?: object, status: StatusType = StatusType.info, error?: Error) {\n    let handlingStack: string | undefined\n\n    if (isAuthorized(status, HandlerType.http, this)) {\n      handlingStack = createHandlingStack()\n    }\n\n    this.logImplementation(message, messageContext, status, error, handlingStack)\n  }\n\n  setContext(context: object) {\n    this.contextManager.setContext(context as Context)\n  }\n\n  getContext() {\n    return this.contextManager.getContext()\n  }\n\n  setContextProperty(key: string, value: any) {\n    this.contextManager.setContextProperty(key, value)\n  }\n\n  removeContextProperty(key: string) {\n    this.contextManager.removeContextProperty(key)\n  }\n\n  clearContext() {\n    this.contextManager.clearContext()\n  }\n\n  setHandler(handler: HandlerType | HandlerType[]) {\n    this.handlerType = handler\n  }\n\n  getHandler() {\n    return this.handlerType\n  }\n\n  setLevel(level: StatusType) {\n    this.level = level\n  }\n\n  getLevel() {\n    return this.level\n  }\n}\n\n/* eslint-disable local-rules/disallow-side-effects */\nLogger.prototype.ok = createLoggerMethod(StatusType.ok)\nLogger.prototype.debug = createLoggerMethod(StatusType.debug)\nLogger.prototype.info = createLoggerMethod(StatusType.info)\nLogger.prototype.notice = createLoggerMethod(StatusType.notice)\nLogger.prototype.warn = createLoggerMethod(StatusType.warn)\nLogger.prototype.error = createLoggerMethod(StatusType.error)\nLogger.prototype.critical = createLoggerMethod(StatusType.critical)\nLogger.prototype.alert = createLoggerMethod(StatusType.alert)\nLogger.prototype.emerg = createLoggerMethod(StatusType.emerg)\n/* eslint-enable local-rules/disallow-side-effects */\n\n// note: it is safe to merge declarations as long as the methods are actually defined on the prototype\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface Logger {\n  ok(message: string, messageContext?: object, error?: Error): void\n  debug(message: string, messageContext?: object, error?: Error): void\n  info(message: string, messageContext?: object, error?: Error): void\n  notice(message: string, messageContext?: object, error?: Error): void\n  warn(message: string, messageContext?: object, error?: Error): void\n  error(message: string, messageContext?: object, error?: Error): void\n  critical(message: string, messageContext?: object, error?: Error): void\n  alert(message: string, messageContext?: object, error?: Error): void\n  emerg(message: string, messageContext?: object, error?: Error): void\n}\n\nfunction createLoggerMethod(status: StatusType) {\n  return function (this: Logger, message: string, messageContext?: object, error?: Error) {\n    let handlingStack: string | undefined\n\n    if (isAuthorized(status, HandlerType.http, this)) {\n      handlingStack = createHandlingStack()\n    }\n\n    this.logImplementation(message, messageContext, status, error, handlingStack)\n  }\n}\n","import { endsWith, includes } from '../tools/utils/polyfills'\nimport { getGlobalObject } from '../tools/getGlobalObject'\nimport type { DefaultPrivacyLevel } from '../domain/configuration'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getCapabilities?(): string\n  getPrivacyLevel?(): DefaultPrivacyLevel\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport const enum BridgeCapability {\n  RECORDS = 'records',\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getCapabilities() {\n      return JSON.parse(eventBridgeGlobal.getCapabilities?.() || '[]') as BridgeCapability[]\n    },\n    getPrivacyLevel() {\n      return eventBridgeGlobal.getPrivacyLevel?.()\n    },\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E, viewId?: string) {\n      const view = viewId ? { id: viewId } : undefined\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event, view }))\n    },\n  }\n}\n\nexport function bridgeSupports(capability: BridgeCapability): boolean {\n  const bridge = getEventBridge()\n  return !!bridge && includes(bridge.getCapabilities(), capability)\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\nconst COMMA_SEPARATED_KEY_VALUE = /([\\w-]+)\\s*=\\s*([^;]+)/g\n\nexport function findCommaSeparatedValue(rawString: string, name: string): string | undefined {\n  COMMA_SEPARATED_KEY_VALUE.lastIndex = 0\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString)\n    if (match) {\n      if (match[1] === name) {\n        return match[2]\n      }\n    } else {\n      break\n    }\n  }\n}\n\nexport function findCommaSeparatedValues(rawString: string): Map<string, string> {\n  const result = new Map<string, string>()\n  COMMA_SEPARATED_KEY_VALUE.lastIndex = 0\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString)\n    if (match) {\n      result.set(match[1], match[2])\n    } else {\n      break\n    }\n  }\n  return result\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) {\n    return candidate\n  }\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n","// Exported only for tests\nexport const enum Browser {\n  IE,\n  CHROMIUM,\n  SAFARI,\n  OTHER,\n}\n\nexport function isIE() {\n  return detectBrowserCached() === Browser.IE\n}\n\nexport function isChromium() {\n  return detectBrowserCached() === Browser.CHROMIUM\n}\n\nexport function isSafari() {\n  return detectBrowserCached() === Browser.SAFARI\n}\n\nlet browserCache: Browser | undefined\nfunction detectBrowserCached() {\n  return browserCache ?? (browserCache = detectBrowser())\n}\n\n// Exported only for tests\nexport function detectBrowser(browserWindow: Window = window) {\n  const userAgent = browserWindow.navigator.userAgent\n  if ((browserWindow as any).chrome || /HeadlessChrome/.test(userAgent)) {\n    return Browser.CHROMIUM\n  }\n\n  if (\n    // navigator.vendor is deprecated, but it is the most resilient way we found to detect\n    // \"Apple maintained browsers\" (AKA Safari). If one day it gets removed, we still have the\n    // useragent test as a semi-working fallback.\n    browserWindow.navigator.vendor?.indexOf('Apple') === 0 ||\n    (/safari/i.test(userAgent) && !/chrome|android/i.test(userAgent))\n  ) {\n    return Browser.SAFARI\n  }\n\n  if ((browserWindow.document as any).documentMode) {\n    return Browser.IE\n  }\n\n  return Browser.OTHER\n}\n","import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  partitioned?: boolean\n  domain?: string\n}\n\nexport function setCookie(name: string, value: string, _expireDelay: number, _options?: CookieOptions) {\n  sessionStorage.setItem(name, value)\n}\n\nexport function getCookie(name: string) {\n  return sessionStorage.getItem(name)\n}\n\nlet initCookieParsed: Map<string, string> | undefined\n\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name: string) {\n  if (!initCookieParsed) {\n    initCookieParsed = findCommaSeparatedValues(document.cookie)\n  }\n  return initCookieParsed.get(name)\n}\n\nexport function resetInitCookies() {\n  initCookieParsed = undefined\n}\n\nexport function deleteCookie(name: string, _options?: CookieOptions) {\n  sessionStorage.removeItem(name)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","import type { CookieOptions } from '../../../browser/cookie'\nimport type { SessionState } from '../sessionState'\n\nexport const SESSION_STORE_KEY = '_dd_s'\n\nexport type SessionStoreStrategyType = { type: 'Cookie'; cookieOptions: CookieOptions } | { type: 'LocalStorage' }\n\nexport interface SessionStoreStrategy {\n  isLockEnabled: boolean\n  persistSession: (session: SessionState) => void\n  retrieveSession: () => SessionState\n  expireSession: () => void\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils/timeUtils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { objectEntries } from '../../tools/utils/polyfills'\nimport { dateNow } from '../../tools/utils/timeUtils'\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from './sessionConstants'\n\nconst SESSION_ENTRY_REGEXP = /^([a-zA-Z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport const EXPIRED = '1'\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  isExpired?: typeof EXPIRED\n\n  [key: string]: string | undefined\n}\n\nexport function getExpiredSessionState(): SessionState {\n  return {\n    isExpired: EXPIRED,\n  }\n}\n\nexport function isSessionInNotStartedState(session: SessionState) {\n  return isEmptyObject(session)\n}\n\nexport function isSessionStarted(session: SessionState) {\n  return !isSessionInNotStartedState(session)\n}\n\nexport function isSessionInExpiredState(session: SessionState) {\n  return session.isExpired !== undefined || !isActiveSession(session)\n}\n\n// An active session is a session in either `Tracked` or `NotTracked` state\nfunction isActiveSession(sessionState: SessionState) {\n  // created and expire can be undefined for versions which was not storing them\n  // these checks could be removed when older versions will not be available/live anymore\n  return (\n    (sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n    (sessionState.expire === undefined || dateNow() < Number(sessionState.expire))\n  )\n}\n\nexport function expandSessionState(session: SessionState) {\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n}\n\nexport function toSessionString(session: SessionState) {\n  return objectEntries(session)\n    .map(([key, value]) => `${key}=${value}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function toSessionState(sessionString: string | undefined | null) {\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined | null): sessionString is string {\n  return (\n    !!sessionString &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n","import { getInitCookie } from '../../browser/cookie'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionStarted } from './sessionState'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy: SessionStoreStrategy) {\n  const sessionString = getInitCookie(SESSION_STORE_KEY)\n  if (!sessionString) {\n    const oldSessionId = getInitCookie(OLD_SESSION_COOKIE_NAME)\n    const oldRumType = getInitCookie(OLD_RUM_COOKIE_NAME)\n    const oldLogsType = getInitCookie(OLD_LOGS_COOKIE_NAME)\n    const session: SessionState = {}\n\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n\n    if (isSessionStarted(session)) {\n      expandSessionState(session)\n      cookieStoreStrategy.persistSession(session)\n    }\n  }\n}\n","import { isChromium } from '../../../tools/utils/browserDetection'\nimport type { CookieOptions } from '../../../browser/cookie'\nimport { getCurrentSite, areCookiesAuthorized, getCookie, setCookie } from '../../../browser/cookie'\nimport type { InitConfiguration } from '../../configuration'\nimport { tryOldCookiesMigration } from '../oldCookiesMigration'\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nexport function selectCookieStrategy(initConfiguration: InitConfiguration): SessionStoreStrategyType | undefined {\n  const cookieOptions = buildCookieOptions(initConfiguration)\n  return areCookiesAuthorized(cookieOptions) ? { type: 'Cookie', cookieOptions } : undefined\n}\n\nexport function initCookieStrategy(cookieOptions: CookieOptions): SessionStoreStrategy {\n  const cookieStore = {\n    /**\n     * Lock strategy allows mitigating issues due to concurrent access to cookie.\n     * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n     */\n    isLockEnabled: isChromium(),\n    persistSession: persistSessionCookie(cookieOptions),\n    retrieveSession: retrieveSessionCookie,\n    expireSession: () => expireSessionCookie(cookieOptions),\n  }\n\n  tryOldCookiesMigration(cookieStore)\n\n  return cookieStore\n}\n\nfunction persistSessionCookie(options: CookieOptions) {\n  return (session: SessionState) => {\n    setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n  }\n}\n\nfunction expireSessionCookie(options: CookieOptions) {\n  setCookie(SESSION_STORE_KEY, toSessionString(getExpiredSessionState()), SESSION_TIME_OUT_DELAY, options)\n}\n\nfunction retrieveSessionCookie(): SessionState {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  cookieOptions.secure =\n    !!initConfiguration.useSecureSessionCookie ||\n    !!initConfiguration.usePartitionedCrossSiteSessionCookie ||\n    !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.crossSite =\n    !!initConfiguration.usePartitionedCrossSiteSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n","import { generateUUID } from '../../../tools/utils/stringUtils'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_'\n\nexport function selectLocalStorageStrategy(): SessionStoreStrategyType | undefined {\n  try {\n    const id = generateUUID()\n    const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`\n    localStorage.setItem(testKey, id)\n    const retrievedId = localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n    return id === retrievedId ? { type: 'LocalStorage' } : undefined\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function initLocalStorageStrategy(): SessionStoreStrategy {\n  return {\n    isLockEnabled: false,\n    persistSession: persistInLocalStorage,\n    retrieveSession: retrieveSessionFromLocalStorage,\n    expireSession: expireSessionFromLocalStorage,\n  }\n}\n\nfunction persistInLocalStorage(sessionState: SessionState) {\n  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState))\n}\n\nfunction retrieveSessionFromLocalStorage(): SessionState {\n  const sessionString = localStorage.getItem(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction expireSessionFromLocalStorage() {\n  persistInLocalStorage(getExpiredSessionState())\n}\n","import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { isLockEnabled, persistSession, expireSession } = sessionStoreStrategy\n  const persistWithLock = (session: SessionState) => persistSession(assign({}, session, { lock: currentLock }))\n  const retrieveStore = () => {\n    const session = sessionStoreStrategy.retrieveSession()\n    const lock = session.lock\n\n    if (session.lock) {\n      delete session.lock\n    }\n\n    return {\n      session,\n      lock,\n    }\n  }\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentStore = retrieveStore()\n  if (isLockEnabled) {\n    // if someone has lock, retry later\n    if (currentStore.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = generateUUID()\n    persistWithLock(currentStore.session)\n    // if lock is not acquired, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentStore.session)\n  if (isLockEnabled) {\n    // if lock corrupted after process, retry later\n    currentStore = retrieveStore()\n    if (currentStore.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      expireSession()\n    } else {\n      expandSessionState(processedSession)\n      isLockEnabled ? persistWithLock(processedSession) : persistSession(processedSession)\n    }\n  }\n  if (isLockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentStore = retrieveStore()\n      if (currentStore.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      persistSession(currentStore.session)\n      processedSession = currentStore.session\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentStore.session)\n  next(sessionStoreStrategy)\n}\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n","import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from '../configuration'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport {\n  getExpiredSessionState,\n  isSessionInExpiredState,\n  isSessionInNotStartedState,\n  isSessionStarted,\n} from './sessionState'\nimport type { SessionState } from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  restartSession: () => void\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  sessionStateUpdateObservable: Observable<{ previousState: SessionState; newState: SessionState }>\n  expire: () => void\n  stop: () => void\n  updateSessionState: (state: Partial<SessionState>) => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy()\n  }\n  return sessionStoreStrategyType\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n  const sessionStateUpdateObservable = new Observable<{ previousState: SessionState; newState: SessionState }>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === 'Cookie'\n      ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy()\n  const { expireSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState\n\n  startSession()\n\n  const { throttled: throttledExpandOrRenewSession, cancel: cancelExpandOrRenewSession } = throttle(() => {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return\n          }\n\n          const synchronizedSession = synchronizeSession(sessionState)\n          expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isSessionStarted(sessionState) && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }, STORAGE_POLL_DELAY)\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (isSessionInExpiredState(sessionState) ? getExpiredSessionState() : undefined),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (isSessionInExpiredState(sessionState)) {\n      sessionState = getExpiredSessionState()\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionStateUpdateObservable.notify({ previousState: sessionCache, newState: sessionState })\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function startSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          if (isSessionInNotStartedState(sessionState)) {\n            return getExpiredSessionState()\n          }\n        },\n        after: (sessionState) => {\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    if (isSessionInNotStartedState(sessionState)) {\n      return false\n    }\n\n    const { trackingType, isTracked } = computeSessionState(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    delete sessionState.isExpired\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = getExpiredSessionState()\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  function updateSessionState(partialSessionState: Partial<SessionState>) {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => assign({}, sessionState, partialSessionState),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  return {\n    expandOrRenewSession: throttledExpandOrRenewSession,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    sessionStateUpdateObservable,\n    restartSession: startSession,\n    expire: () => {\n      cancelExpandOrRenewSession()\n      expireSession()\n      synchronizeSession(getExpiredSessionState())\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n    updateSessionState,\n  }\n}\n","import { jsonStringify } from '../serialisation/jsonStringify'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, location.href).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function buildUrl(url: string, base?: string) {\n  const supportedURL = getSupportedUrl()\n  if (supportedURL) {\n    try {\n      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url)\n    } catch (error) {\n      throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })!}`)\n    }\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nconst originalURL = URL\nlet isURLSupported: boolean | undefined\nfunction getSupportedUrl(): typeof URL | undefined {\n  if (isURLSupported === undefined) {\n    try {\n      const url = new originalURL('http://test/path')\n      isURLSupported = url.href === 'http://test/path'\n    } catch {\n      isURLSupported = false\n    }\n  }\n  return isURLSupported ? originalURL : undefined\n}\n","import type { Payload } from '../../transport'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_US1, INTAKE_SITE_FED_STAGING, PCI_INTAKE_HOST_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport type TrackType = 'logs' | 'rum' | 'replay'\nexport type ApiType =\n  | 'xhr'\n  | 'fetch'\n  | 'beacon'\n  // 'manual' reflects that the request have been sent manually, outside of the SDK (ex: via curl or\n  // a Node.js script).\n  | 'manual'\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  trackType: TrackType,\n  configurationTags: string[]\n) {\n  const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, trackType)\n\n  return {\n    build(api: ApiType, payload: Payload) {\n      const parameters = buildEndpointParameters(initConfiguration, trackType, configurationTags, api, payload)\n      return buildUrlWithParameters(parameters)\n    },\n    urlPrefix: buildUrlWithParameters(''),\n    trackType,\n  }\n}\n\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(\n  initConfiguration: InitConfiguration,\n  trackType: TrackType\n): (parameters: string) => string {\n  const path = `/api/v2/${trackType}`\n  const proxy = initConfiguration.proxy\n  if (typeof proxy === 'string') {\n    const normalizedProxyUrl = normalizeUrl(proxy)\n    return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`\n  }\n  if (typeof proxy === 'function') {\n    return (parameters) => proxy({ path, parameters })\n  }\n  const host = buildEndpointHost(trackType, initConfiguration)\n  return (parameters) => `https://${host}${path}?${parameters}`\n}\n\nfunction buildEndpointHost(trackType: TrackType, initConfiguration: InitConfiguration & { usePciIntake?: boolean }) {\n  const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration\n\n  if (trackType === 'logs' && initConfiguration.usePciIntake && site === INTAKE_SITE_US1) {\n    return PCI_INTAKE_HOST_US1\n  }\n\n  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n    return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`\n  }\n\n  if (site === INTAKE_SITE_FED_STAGING) {\n    return `http-intake.logs.${site}`\n  }\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  return `browser-intake-${domainParts.join('-')}.${extension!}`\n}\n\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(\n  { clientToken, internalAnalyticsSubdomain }: InitConfiguration,\n  trackType: TrackType,\n  configurationTags: string[],\n  api: ApiType,\n  { retry, encoding }: Payload\n) {\n  const tags = [`sdk_version:${__BUILD_ENV__SDK_VERSION__}`, `api:${api}`].concat(configurationTags)\n  if (retry) {\n    tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`)\n  }\n\n  const parameters = [\n    'ddsource=browser',\n    `ddtags=${encodeURIComponent(tags.join(','))}`,\n    `dd-api-key=${clientToken}`,\n    `dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}`,\n    'dd-evp-origin=browser',\n    `dd-request-id=${generateUUID()}`,\n  ]\n\n  if (encoding) {\n    parameters.push(`dd-evp-encoding=${encoding}`)\n  }\n\n  if (trackType === 'rum') {\n    parameters.push(`batch_time=${timeStampNow()}`)\n  }\n\n  if (internalAnalyticsSubdomain) {\n    parameters.reverse()\n  }\n\n  return parameters.join('&')\n}\n","import { DOCS_ORIGIN, display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(\n      `${key} value doesn't meet tag requirements and will be sanitized. More details: ${DOCS_ORIGIN}/getting_started/tagging/#defining-tags`\n    )\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { objectValues, assign } from '../../tools/utils/polyfills'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1, PCI_INTAKE_HOST_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const site = initConfiguration.site || INTAKE_SITE_US1\n\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeUrlPrefixes = computeIntakeUrlPrefixes(endpointBuilders, site)\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeUrlPrefixes.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'replay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeUrlPrefixes: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeUrlPrefixes.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.urlPrefix))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n\nfunction computeIntakeUrlPrefixes(\n  endpointBuilders: ReturnType<typeof computeEndpointBuilders>,\n  site: string\n): string[] {\n  const intakeUrlPrefixes = objectValues(endpointBuilders).map((builder) => builder.urlPrefix)\n\n  if (site === INTAKE_SITE_US1) {\n    intakeUrlPrefixes.push(`https://${PCI_INTAKE_HOST_US1}/`)\n  }\n\n  return intakeUrlPrefixes\n}\n","import { catchUserErrors } from '../../tools/catchUserErrors'\nimport { DOCS_ORIGIN, display } from '../../tools/display'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport type { Duration } from '../../tools/utils/timeUtils'\nimport { ONE_SECOND } from '../../tools/utils/timeUtils'\nimport { isPercentage } from '../../tools/utils/numberUtils'\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { objectHasValue } from '../../tools/utils/objectUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectSessionStoreStrategyType } from '../session/sessionStore'\nimport type { SessionStoreStrategyType } from '../session/storeStrategies/sessionStoreStrategy'\nimport { TrackingConsent } from '../trackingConsent'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = (typeof DefaultPrivacyLevel)[keyof typeof DefaultPrivacyLevel]\n\nexport const TraceContextInjection = {\n  ALL: 'all',\n  SAMPLED: 'sampled',\n} as const\n\nexport type TraceContextInjection = (typeof TraceContextInjection)[keyof typeof TraceContextInjection]\n\nexport interface InitConfiguration {\n  /**\n   * The client token for Datadog. Required for authenticating your application with Datadog.\n   */\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  /**\n   * The percentage of sessions tracked. A value between 0 and 100.\n   * @default 100\n   */\n  sessionSampleRate?: number | undefined\n  /**\n   * The percentage of telemetry events sent. A value between 0 and 100.\n   * @default 20\n   */\n  telemetrySampleRate?: number | undefined\n  /**\n   * Initialization fails silently if the RUM Browser SDK is already initialized on the page.\n   * @default false\n   */\n  silentMultipleInit?: boolean | undefined\n  /**\n   * Allows the use of localStorage when cookies cannot be set. This enables the RUM Browser SDK to run in environments that do not provide cookie support.\n   * See [Monitor Electron Applications Using the Browser SDK](https://docs.datadoghq.com/real_user_monitoring/guide/monitor-electron-applications-using-browser-sdk) for further information.\n   * @default false\n   */\n  allowFallbackToLocalStorage?: boolean | undefined\n  /**\n   * Allow listening to DOM events dispatched programmatically ([untrusted events](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted)). Enabling this option can be useful if you heavily rely on programmatic events, such as in an automated UI test environment.\n   * @default false\n   */\n  allowUntrustedEvents?: boolean | undefined\n  /**\n   * Store global context and user context in localStorage to preserve them along the user navigation.\n   * See [Contexts life cycle](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#contexts-life-cycle) for further information.\n   * @default false\n   */\n  storeContextsAcrossPages?: boolean | undefined\n  /**\n   * Set the initial user tracking consent state.\n   * See [User tracking consent](https://docs.datadoghq.com/real_user_monitoring/browser/advanced_configuration/?tab=npm#user-tracking-consent) for further information.\n   * @default granted\n   */\n  trackingConsent?: TrackingConsent | undefined\n\n  // transport options\n  /**\n   * Optional proxy URL, for example: https://www.proxy.com/path.\n   * See [Proxy Your Browser RUM Data](https://docs.datadoghq.com/real_user_monitoring/guide/proxy-rum-data) for further information.\n   */\n  proxy?: string | ProxyFn | undefined\n  /**\n   * The Datadog [site](https://docs.datadoghq.com/getting_started/site) parameter of your organization.\n   * @default datadoghq.com\n   */\n  site?: string | undefined\n\n  // tag and context options\n  /**\n   * The service name for your application. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  service?: string | undefined | null\n  /**\n   * The application’s environment, for example: prod, pre-prod, and staging. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  env?: string | undefined | null\n  /**\n   * The application’s version, for example: 1.2.3, 6c44da20, and 2020.02.13. Follows the [tag syntax requirements](https://docs.datadoghq.com/getting_started/tagging/#define-tags).\n   */\n  version?: string | undefined | null\n\n  // cookie options\n  /**\n   * Whether a secure cross-site session cookie is used\n   * @default false\n   * @deprecated use usePartitionedCrossSiteSessionCookie instead\n   */\n  useCrossSiteSessionCookie?: boolean | undefined\n  /**\n   * Use a partitioned secure cross-site session cookie. This allows the RUM Browser SDK to run when the site is loaded from another one (iframe). Implies `useSecureSessionCookie`.\n   * @default false\n   */\n  usePartitionedCrossSiteSessionCookie?: boolean | undefined\n  /**\n   * Use a secure session cookie. This disables RUM events sent on insecure (non-HTTPS) connections.\n   * @default false\n   */\n  useSecureSessionCookie?: boolean | undefined\n  /**\n   * Preserve the session across subdomains for the same site.\n   * @default false\n   */\n  trackSessionAcrossSubdomains?: boolean | undefined\n\n  // internal options\n  /**\n   * [Internal option] Enable experimental features\n   */\n  enableExperimentalFeatures?: string[] | undefined\n  /**\n   * [Internal option] Configure the dual chipping to another datacenter\n   */\n  replica?: ReplicaUserConfiguration | undefined\n  /**\n   * [Internal option] Set the datacenter from where the data is dual chipped\n   */\n  datacenter?: string\n  /**\n   * [Internal option] Datadog internal analytics subdomain\n   */\n  // TODO next major: remove this option and replace usages by proxyFn\n  internalAnalyticsSubdomain?: string\n  /**\n   * [Internal option] The percentage of telemetry configuration sent. A value between 0 and 100.\n   * @default 5\n   */\n  telemetryConfigurationSampleRate?: number\n  /**\n   * [Internal option] The percentage of telemetry usage sent. A value between 0 and 100.\n   * @default 5\n   */\n  telemetryUsageSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\n/**\n * path: /api/vX/product\n * parameters: xxx=yyy&zzz=aaa\n */\ntype ProxyFn = (options: { path: string; parameters: string }) => string\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  sessionStoreStrategyType: SessionStoreStrategyType | undefined\n  sessionSampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  telemetryUsageSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n  allowUntrustedEvents: boolean\n  trackingConsent: TrackingConsent\n  storeContextsAcrossPages: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: Duration\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nfunction checkIfString(tag: unknown, tagName: string): tag is string | undefined | null {\n  if (tag !== undefined && tag !== null && typeof tag !== 'string') {\n    display.error(`${tagName} must be defined as a string`)\n    return false\n  }\n  return true\n}\n\nfunction isDatadogSite(site: string) {\n  return /(datadog|ddog|datad0g|dd0g)/.test(site)\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  if (initConfiguration.sessionSampleRate !== undefined && !isPercentage(initConfiguration.sessionSampleRate)) {\n    display.error('Session Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryUsageSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryUsageSampleRate)\n  ) {\n    display.error('Telemetry Usage Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (!checkIfString(initConfiguration.version, 'Version')) {\n    return\n  }\n\n  if (!checkIfString(initConfiguration.env, 'Env')) {\n    return\n  }\n\n  if (!checkIfString(initConfiguration.service, 'Service')) {\n    return\n  }\n\n  if (\n    initConfiguration.trackingConsent !== undefined &&\n    !objectHasValue(TrackingConsent, initConfiguration.trackingConsent)\n  ) {\n    display.error('Tracking Consent should be either \"granted\" or \"not-granted\"')\n    return\n  }\n\n  if (initConfiguration.site && !isDatadogSite(initConfiguration.site)) {\n    display.error(`Site should be a valid Datadog site. Learn more here: ${DOCS_ORIGIN}/getting_started/site/.`)\n    return\n  }\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n      sessionSampleRate: initConfiguration.sessionSampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      telemetryUsageSampleRate: initConfiguration.telemetryUsageSampleRate ?? 5,\n      service: initConfiguration.service || undefined,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n      allowUntrustedEvents: !!initConfiguration.allowUntrustedEvents,\n      trackingConsent: initConfiguration.trackingConsent ?? TrackingConsent.GRANTED,\n      storeContextsAcrossPages: !!initConfiguration.storeContextsAcrossPages,\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: (30 * ONE_SECOND) as Duration,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function serializeConfiguration(initConfiguration: InitConfiguration) {\n  return {\n    session_sample_rate: initConfiguration.sessionSampleRate,\n    telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n    telemetry_usage_sample_rate: initConfiguration.telemetryUsageSampleRate,\n    use_before_send: !!initConfiguration.beforeSend,\n    use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,\n    use_partitioned_cross_site_session_cookie: initConfiguration.usePartitionedCrossSiteSessionCookie,\n    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n    use_proxy: !!initConfiguration.proxy,\n    silent_multiple_init: initConfiguration.silentMultipleInit,\n    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n    store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n    allow_untrusted_events: !!initConfiguration.allowUntrustedEvents,\n    tracking_consent: initConfiguration.trackingConsent,\n  } satisfies RawTelemetryConfiguration\n}\n","import { toStackTraceString } from '../../tools/stackTrace/handlingStack'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport { includes } from '../../tools/utils/polyfills'\nimport { safeTruncate } from '../../tools/utils/stringUtils'\nimport type { Configuration } from '../configuration'\nimport type { ReportType, InterventionReport, DeprecationReport } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = (typeof RawReportType)[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  originalReport: SecurityPolicyViolationEvent | DeprecationReport | InterventionReport\n  stack?: string\n}\n\nexport function initReportObservable(configuration: Configuration, apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable(configuration))\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  return new Observable<RawReport>((observable) => {\n    if (!window.ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Array<DeprecationReport | InterventionReport>, _: ReportingObserver) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    ) as ReportingObserverCallback\n\n    const observer = new window.ReportingObserver(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n}\n\nfunction createCspViolationReportObservable(configuration: Configuration) {\n  return new Observable<RawReport>((observable) => {\n    const { stop } = addEventListener(configuration, document, DOM_EVENT.SECURITY_POLICY_VIOLATION, (event) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    return stop\n  })\n}\n\nfunction buildRawReportFromReport(report: DeprecationReport | InterventionReport): RawReport {\n  const { type, body } = report\n\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    originalReport: report,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n    originalReport: event,\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | null,\n  lineNumber: number | null,\n  columnNumber: number | null\n): string | undefined {\n  return sourceFile\n    ? toStackTraceString({\n        name,\n        message,\n        stack: [\n          {\n            func: '?',\n            url: sourceFile,\n            line: lineNumber ?? undefined,\n            column: columnNumber ?? undefined,\n          },\n        ],\n      })\n    : undefined\n}\n","import type { Configuration, InitConfiguration, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  serializeConfiguration,\n  assign,\n  ONE_KIBI_BYTE,\n  validateAndBuildConfiguration,\n  display,\n  removeDuplicates,\n  ConsoleApiName,\n  RawReportType,\n  includes,\n  objectValues,\n} from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\nimport type { LogsEventDomainContext } from '../domainContext.types'\n\nexport interface LogsInitConfiguration extends InitConfiguration {\n  /**\n   * Access to every logs collected by the Logs SDK before they are sent to Datadog.\n   * It allows:\n   * - Enrich your logs with additional context attributes\n   * - Modify your logs to modify their content, or redact sensitive sequences (see the list of editable properties)\n   * - Discard selected logs\n   */\n  beforeSend?: ((event: LogsEvent, context: LogsEventDomainContext) => boolean) | undefined\n  /**\n   * Forward console.error logs, uncaught exceptions and network errors to Datadog.\n   * @default true\n   */\n  forwardErrorsToLogs?: boolean | undefined\n  /**\n   * Forward logs from console.* to Datadog. Use \"all\" to forward everything or an array of console API names to forward only a subset.\n   */\n  forwardConsoleLogs?: ConsoleApiName[] | 'all' | undefined\n  /**\n   * Forward reports from the [Reporting API](https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API) to Datadog. Use \"all\" to forward everything or an array of report types to forward only a subset.\n   */\n  forwardReports?: RawReportType[] | 'all' | undefined\n  /**\n   * Use PCI-compliant intake. See [PCI DSS Compliance](https://docs.datadoghq.com/data_security/pci_compliance/?tab=logmanagement) for further information.\n   * @default false\n   */\n  usePciIntake?: boolean\n  /**\n   * Keep sending logs after the session expiration.\n   * @default false\n   */\n  sendLogsAfterSessionExpiration?: boolean | undefined // TODO next major: remove this option and make it the default behaviour\n}\n\nexport type HybridInitConfiguration = Omit<LogsInitConfiguration, 'clientToken'>\n\nexport interface LogsConfiguration extends Configuration {\n  forwardErrorsToLogs: boolean\n  forwardConsoleLogs: ConsoleApiName[]\n  forwardReports: RawReportType[]\n  requestErrorResponseLengthLimit: number\n  sendLogsAfterSessionExpiration: boolean\n}\n\n/**\n * arbitrary value, byte precision not needed\n */\nexport const DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * ONE_KIBI_BYTE\n\nexport function validateAndBuildLogsConfiguration(\n  initConfiguration: LogsInitConfiguration\n): LogsConfiguration | undefined {\n  if (initConfiguration.usePciIntake === true && initConfiguration.site && initConfiguration.site !== 'datadoghq.com') {\n    display.warn(\n      'PCI compliance for Logs is only available for Datadog organizations in the US1 site. Default intake will be used.'\n    )\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n\n  const forwardConsoleLogs = validateAndBuildForwardOption<ConsoleApiName>(\n    initConfiguration.forwardConsoleLogs,\n    objectValues(ConsoleApiName),\n    'Forward Console Logs'\n  )\n\n  const forwardReports = validateAndBuildForwardOption<RawReportType>(\n    initConfiguration.forwardReports,\n    objectValues(RawReportType),\n    'Forward Reports'\n  )\n\n  if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {\n    return\n  }\n\n  if (initConfiguration.forwardErrorsToLogs && !includes(forwardConsoleLogs, ConsoleApiName.error)) {\n    forwardConsoleLogs.push(ConsoleApiName.error)\n  }\n\n  return assign(\n    {\n      forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,\n      forwardConsoleLogs,\n      forwardReports,\n      requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT,\n      sendLogsAfterSessionExpiration: !!initConfiguration.sendLogsAfterSessionExpiration,\n    },\n    baseConfiguration\n  )\n}\n\nexport function validateAndBuildForwardOption<T>(\n  option: readonly T[] | 'all' | undefined,\n  allowedValues: T[],\n  label: string\n): T[] | undefined {\n  if (option === undefined) {\n    return []\n  }\n\n  if (!(option === 'all' || (Array.isArray(option) && option.every((api) => includes(allowedValues, api))))) {\n    display.error(`${label} should be \"all\" or an array with allowed values \"${allowedValues.join('\", \"')}\"`)\n    return\n  }\n\n  return option === 'all' ? allowedValues : removeDuplicates<T>(option)\n}\n\nexport function serializeLogsConfiguration(configuration: LogsInitConfiguration) {\n  const baseSerializedInitConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      forward_errors_to_logs: configuration.forwardErrorsToLogs,\n      forward_console_logs: configuration.forwardConsoleLogs,\n      forward_reports: configuration.forwardReports,\n      use_pci_intake: configuration.usePciIntake,\n      send_logs_after_session_expiration: configuration.sendLogsAfterSessionExpiration,\n    },\n    baseSerializedInitConfiguration\n  ) satisfies RawTelemetryConfiguration\n}\n","import type { TrackingConsentState } from '@datadog/browser-core'\nimport {\n  BoundedBuffer,\n  assign,\n  canUseEventBridge,\n  display,\n  displayAlreadyInitializedError,\n  initFeatureFlags,\n  noop,\n  timeStampNow,\n} from '@datadog/browser-core'\nimport {\n  validateAndBuildLogsConfiguration,\n  type LogsConfiguration,\n  type LogsInitConfiguration,\n} from '../domain/configuration'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { Strategy } from './logsPublicApi'\nimport type { StartLogsResult } from './startLogs'\n\nexport function createPreStartStrategy(\n  getCommonContext: () => CommonContext,\n  trackingConsentState: TrackingConsentState,\n  doStartLogs: (initConfiguration: LogsInitConfiguration, configuration: LogsConfiguration) => StartLogsResult\n): Strategy {\n  const bufferApiCalls = new BoundedBuffer<StartLogsResult>()\n  let cachedInitConfiguration: LogsInitConfiguration | undefined\n  let cachedConfiguration: LogsConfiguration | undefined\n  const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartLogs)\n\n  function tryStartLogs() {\n    if (!cachedConfiguration || !cachedInitConfiguration || !trackingConsentState.isGranted()) {\n      return\n    }\n\n    trackingConsentStateSubscription.unsubscribe()\n    const startLogsResult = doStartLogs(cachedInitConfiguration, cachedConfiguration)\n\n    bufferApiCalls.drain(startLogsResult)\n  }\n\n  return {\n    init(initConfiguration) {\n      if (!initConfiguration) {\n        display.error('Missing configuration')\n        return\n      }\n      // Set the experimental feature flags as early as possible, so we can use them in most places\n      initFeatureFlags(initConfiguration.enableExperimentalFeatures)\n\n      if (canUseEventBridge()) {\n        initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n      }\n\n      // Expose the initial configuration regardless of initialization success.\n      cachedInitConfiguration = initConfiguration\n\n      if (cachedConfiguration) {\n        displayAlreadyInitializedError('DD_LOGS', initConfiguration)\n        return\n      }\n\n      const configuration = validateAndBuildLogsConfiguration(initConfiguration)\n      if (!configuration) {\n        return\n      }\n\n      cachedConfiguration = configuration\n      trackingConsentState.tryToInit(configuration.trackingConsent)\n      tryStartLogs()\n    },\n\n    get initConfiguration() {\n      return cachedInitConfiguration\n    },\n\n    getInternalContext: noop as () => undefined,\n\n    handleLog(message, statusType, handlingStack, context = getCommonContext(), date = timeStampNow()) {\n      bufferApiCalls.add((startLogsResult) =>\n        startLogsResult.handleLog(message, statusType, handlingStack, context, date)\n      )\n    },\n  }\n}\n\nfunction overrideInitConfigurationForBridge(initConfiguration: LogsInitConfiguration): LogsInitConfiguration {\n  return assign({}, initConfiguration, { clientToken: 'empty' })\n}\n","import type { Context, TrackingConsent, User, PublicApi } from '@datadog/browser-core'\nimport {\n  addTelemetryUsage,\n  CustomerDataType,\n  assign,\n  createContextManager,\n  makePublicApi,\n  monitor,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n  createCustomerDataTrackerManager,\n  storeContextManager,\n  displayAlreadyInitializedError,\n  deepClone,\n  createTrackingConsentState,\n} from '@datadog/browser-core'\nimport type { LogsInitConfiguration } from '../domain/configuration'\nimport type { HandlerType } from '../domain/logger'\nimport type { StatusType } from '../domain/logger/isAuthorized'\nimport { Logger } from '../domain/logger'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport type { InternalContext } from '../domain/contexts/internalContext'\nimport type { StartLogs, StartLogsResult } from './startLogs'\nimport { createPreStartStrategy } from './preStartLogs'\n\nexport interface LoggerConfiguration {\n  level?: StatusType\n  handler?: HandlerType | HandlerType[]\n  context?: object\n}\n\nexport interface LogsPublicApi extends PublicApi {\n  logger: Logger\n\n  /**\n   * Init the Logs browser SDK.\n   * @param initConfiguration Configuration options of the SDK\n   *\n   * See [Browser Log Collection](https://docs.datadoghq.com/logs/log_collection/javascript) for further information.\n   */\n  init: (initConfiguration: LogsInitConfiguration) => void\n\n  /**\n   * Set the tracking consent of the current user.\n   *\n   * @param {\"granted\" | \"not-granted\"} trackingConsent The user tracking consent\n   *\n   * Logs will be sent only if it is set to \"granted\". This value won't be stored by the library\n   * across page loads: you will need to call this method or set the appropriate `trackingConsent`\n   * field in the init() method at each page load.\n   *\n   * If this method is called before the init() method, the provided value will take precedence\n   * over the one provided as initialization parameter.\n   */\n  setTrackingConsent: (trackingConsent: TrackingConsent) => void\n\n  /**\n   * Get the global Context\n   *\n   * See [Overwrite context](https://docs.datadoghq.com/logs/log_collection/javascript/#overwrite-context) for further information.\n   */\n  getGlobalContext: () => Context\n\n  /**\n   * Set the global context information to all logs, stored in `@context`\n   *\n   * @param context Global context\n   *\n   * See [Overwrite context](https://docs.datadoghq.com/logs/log_collection/javascript/#overwrite-context) for further information.\n   */\n  setGlobalContext: (context: any) => void\n\n  /**\n   * Set or update a global context property, stored in `@context.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   *\n   * See [Overwrite context](https://docs.datadoghq.com/logs/log_collection/javascript/#overwrite-context) for further information.\n   */\n  setGlobalContextProperty: (key: any, value: any) => void\n\n  /**\n   * Remove a global context property\n   *\n   * See [Overwrite context](https://docs.datadoghq.com/logs/log_collection/javascript/#overwrite-context) for further information.\n   */\n  removeGlobalContextProperty: (key: any) => void\n\n  /**\n   * Clear the global context\n   *\n   * See [Overwrite context](https://docs.datadoghq.com/logs/log_collection/javascript/#overwrite-context) for further information.\n   */\n  clearGlobalContext: () => void\n\n  /**\n   * The Datadog browser logs SDK contains a default logger `DD_LOGS.logger`, but this API allows to create different ones.\n   *\n   * See [Define multiple loggers](https://docs.datadoghq.com/logs/log_collection/javascript/#define-multiple-loggers) for further information.\n   */\n  createLogger: (name: string, conf?: LoggerConfiguration) => Logger\n\n  /**\n   * Get a logger\n   *\n   * See [Define multiple loggers](https://docs.datadoghq.com/logs/log_collection/javascript/#define-multiple-loggers) for further information.\n   */\n  getLogger: (name: string) => Logger | undefined\n\n  /**\n   * Get the init configuration\n   */\n  getInitConfiguration: () => LogsInitConfiguration | undefined\n\n  /**\n   * [Internal API] Get the internal SDK context\n   *\n   * See [Access internal context](https://docs.datadoghq.com/logs/log_collection/javascript/#access-internal-context) for further information.\n   */\n  getInternalContext: (startTime?: number | undefined) => InternalContext | undefined\n\n  /**\n   * Set user information to all events, stored in `@usr`\n   *\n   * See [User context](https://docs.datadoghq.com/logs/log_collection/javascript/#user-context) for further information.\n   */\n  setUser: (newUser: User) => void\n\n  /**\n   * Get user information\n   *\n   * See [User context](https://docs.datadoghq.com/logs/log_collection/javascript/#user-context) for further information.\n   */\n  getUser: () => Context\n\n  /**\n   * Set or update the user property, stored in `@usr.<key>`\n   *\n   * @param key Key of the property\n   * @param property Value of the property\n   *\n   * See [User context](https://docs.datadoghq.com/logs/log_collection/javascript/#user-context) for further information.\n   */\n  setUserProperty: (key: any, property: any) => void\n\n  /**\n   * Remove a user property\n   *\n   * See [User context](https://docs.datadoghq.com/logs/log_collection/javascript/#user-context) for further information.\n   */\n  removeUserProperty: (key: any) => void\n\n  /**\n   * Clear all user information\n   *\n   * See [User context](https://docs.datadoghq.com/logs/log_collection/javascript/#user-context) for further information.\n   */\n  clearUser: () => void\n}\n\nconst LOGS_STORAGE_KEY = 'logs'\n\nexport interface Strategy {\n  init: (initConfiguration: LogsInitConfiguration) => void\n  initConfiguration: LogsInitConfiguration | undefined\n  getInternalContext: StartLogsResult['getInternalContext']\n  handleLog: StartLogsResult['handleLog']\n}\n\nexport function makeLogsPublicApi(startLogsImpl: StartLogs): LogsPublicApi {\n  const customerDataTrackerManager = createCustomerDataTrackerManager()\n  const globalContextManager = createContextManager(\n    customerDataTrackerManager.getOrCreateTracker(CustomerDataType.GlobalContext)\n  )\n  const userContextManager = createContextManager(customerDataTrackerManager.getOrCreateTracker(CustomerDataType.User))\n  const trackingConsentState = createTrackingConsentState()\n\n  function getCommonContext() {\n    return buildCommonContext(globalContextManager, userContextManager)\n  }\n\n  let strategy = createPreStartStrategy(getCommonContext, trackingConsentState, (initConfiguration, configuration) => {\n    if (initConfiguration.storeContextsAcrossPages) {\n      storeContextManager(configuration, globalContextManager, LOGS_STORAGE_KEY, CustomerDataType.GlobalContext)\n      storeContextManager(configuration, userContextManager, LOGS_STORAGE_KEY, CustomerDataType.User)\n    }\n\n    const startLogsResult = startLogsImpl(initConfiguration, configuration, getCommonContext, trackingConsentState)\n\n    strategy = createPostStartStrategy(initConfiguration, startLogsResult)\n    return startLogsResult\n  })\n\n  const customLoggers: { [name: string]: Logger | undefined } = {}\n\n  const mainLogger = new Logger(\n    (...params) => strategy.handleLog(...params),\n    customerDataTrackerManager.createDetachedTracker()\n  )\n\n  return makePublicApi<LogsPublicApi>({\n    logger: mainLogger,\n\n    init: monitor((initConfiguration) => strategy.init(initConfiguration)),\n\n    setTrackingConsent: monitor((trackingConsent) => {\n      trackingConsentState.update(trackingConsent)\n      addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent })\n    }),\n\n    getGlobalContext: monitor(() => globalContextManager.getContext()),\n\n    setGlobalContext: monitor((context) => globalContextManager.setContext(context)),\n\n    setGlobalContextProperty: monitor((key, value) => globalContextManager.setContextProperty(key, value)),\n\n    removeGlobalContextProperty: monitor((key) => globalContextManager.removeContextProperty(key)),\n\n    clearGlobalContext: monitor(() => globalContextManager.clearContext()),\n\n    createLogger: monitor((name, conf = {}) => {\n      customLoggers[name] = new Logger(\n        (...params) => strategy.handleLog(...params),\n        customerDataTrackerManager.createDetachedTracker(),\n        sanitize(name),\n        conf.handler,\n        conf.level,\n        sanitize(conf.context) as object\n      )\n\n      return customLoggers[name]\n    }),\n\n    getLogger: monitor((name) => customLoggers[name]),\n\n    getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),\n\n    getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),\n\n    setUser: monitor((newUser) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(() => userContextManager.getContext()),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor((key) => userContextManager.removeContextProperty(key)),\n\n    clearUser: monitor(() => userContextManager.clearContext()),\n  })\n}\n\nfunction createPostStartStrategy(initConfiguration: LogsInitConfiguration, startLogsResult: StartLogsResult): Strategy {\n  return assign(\n    {\n      init: (initConfiguration: LogsInitConfiguration) => {\n        displayAlreadyInitializedError('DD_LOGS', initConfiguration)\n      },\n      initConfiguration,\n    },\n    startLogsResult\n  )\n}\n","import { Observable } from '../tools/observable'\nimport { objectValues, includes } from '../tools/utils/polyfills'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageExitObservable(configuration: Configuration): Observable<PageExitEvent> {\n  return new Observable<PageExitEvent>((observable) => {\n    const { stop: stopListeners } = addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE],\n      (event) => {\n        if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    const stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, () => {\n      observable.notify({ reason: PageExitReason.UNLOADING })\n    }).stop\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n}\n\nexport function isPageExitReason(reason: string | undefined): reason is PageExitReason {\n  return includes(objectValues(PageExitReason), reason)\n}\n","import { getInitCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value =\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport { removeItem } from './utils/arrayUtils'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ValueHistory<Value> {\n  private entries: Array<ValueHistoryEntry<Value>> = []\n  private clearOldValuesInterval: TimeoutId\n\n  constructor(\n    private expireDelay: number,\n    private maxEntries?: number\n  ) {\n    this.clearOldValuesInterval = setInterval(() => this.clearOldValues(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        removeItem(this.entries, entry)\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop()\n    }\n\n    this.entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   *\n   * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n   */\n  find(\n    startTime: RelativeTime = END_OF_TIMES,\n    options: { returnInactive: boolean } = { returnInactive: false }\n  ): Value | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (options.returnInactive || startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return this.entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldValuesInterval)\n  }\n\n  private clearOldValues() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { ValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport type { Configuration } from '../configuration'\nimport type { TrackingConsentState } from '../trackingConsent'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\nimport type { SessionState } from './sessionState'\n\nexport interface SessionManager<TrackingType extends string> {\n  findSession: (\n    startTime?: RelativeTime,\n    options?: { returnInactive: boolean }\n  ) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  sessionStateUpdateObservable: Observable<{ previousState: SessionState; newState: SessionState }>\n  expire: () => void\n  updateSessionState: (state: Partial<SessionState>) => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n  isReplayForced: boolean\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  configuration: Configuration,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean },\n  trackingConsentState: TrackingConsentState\n): SessionManager<TrackingType> {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  // TODO - Improve configuration type and remove assertion\n  const sessionStore = startSessionStore(configuration.sessionStoreStrategyType!, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ValueHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n    renewObservable.notify()\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    expireObservable.notify()\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  // We expand/renew session unconditionally as tracking consent is always granted when the session\n  // manager is started.\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackingConsentState.observable.subscribe(() => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    } else {\n      sessionStore.expire()\n    }\n  })\n\n  trackActivity(configuration, () => {\n    if (trackingConsentState.isGranted()) {\n      sessionStore.expandOrRenewSession()\n    }\n  })\n  trackVisibility(configuration, () => sessionStore.expandSession())\n  trackResume(configuration, () => sessionStore.restartSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n      isReplayForced: !!sessionStore.getSession().forcedReplay,\n    }\n  }\n\n  return {\n    findSession: (startTime, options) => sessionContextHistory.find(startTime, options),\n    renewObservable,\n    expireObservable,\n    sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n    expire: sessionStore.expire,\n    updateSessionState: sessionStore.updateSessionState,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(configuration: Configuration, expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(configuration: Configuration, expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n\nfunction trackResume(configuration: Configuration, cb: () => void) {\n  const { stop } = addEventListener(configuration, window, DOM_EVENT.RESUME, cb, { capture: true })\n  stopCallbacks.push(stop)\n}\n","import type { RelativeTime, TrackingConsentState } from '@datadog/browser-core'\nimport { Observable, performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { LogsConfiguration } from './configuration'\n\nexport const LOGS_SESSION_KEY = 'logs'\n\nexport interface LogsSessionManager {\n  findTrackedSession: (startTime?: RelativeTime, options?: { returnInactive: boolean }) => LogsSession | undefined\n  expireObservable: Observable<void>\n}\n\nexport type LogsSession = {\n  id?: string // session can be tracked without id\n}\n\nexport const enum LoggerTrackingType {\n  NOT_TRACKED = '0',\n  TRACKED = '1',\n}\n\nexport function startLogsSessionManager(\n  configuration: LogsConfiguration,\n  trackingConsentState: TrackingConsentState\n): LogsSessionManager {\n  const sessionManager = startSessionManager(\n    configuration,\n    LOGS_SESSION_KEY,\n    (rawTrackingType) => computeSessionState(configuration, rawTrackingType),\n    trackingConsentState\n  )\n  return {\n    findTrackedSession: (startTime?: RelativeTime, options = { returnInactive: false }) => {\n      const session = sessionManager.findSession(startTime, options)\n      return session && session.trackingType === LoggerTrackingType.TRACKED\n        ? {\n            id: session.id,\n          }\n        : undefined\n    },\n    expireObservable: sessionManager.expireObservable,\n  }\n}\n\nexport function startLogsSessionManagerStub(configuration: LogsConfiguration): LogsSessionManager {\n  const isTracked = computeTrackingType(configuration) === LoggerTrackingType.TRACKED\n  const session = isTracked ? {} : undefined\n  return {\n    findTrackedSession: () => session,\n    expireObservable: new Observable(),\n  }\n}\n\nfunction computeTrackingType(configuration: LogsConfiguration) {\n  if (!performDraw(configuration.sessionSampleRate)) {\n    return LoggerTrackingType.NOT_TRACKED\n  }\n  return LoggerTrackingType.TRACKED\n}\n\nfunction computeSessionState(configuration: LogsConfiguration, rawSessionType?: string) {\n  const trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration)\n  return {\n    trackingType,\n    isTracked: trackingType === LoggerTrackingType.TRACKED,\n  }\n}\n\nfunction hasValidLoggerSession(trackingType?: string): trackingType is LoggerTrackingType {\n  return trackingType === LoggerTrackingType.NOT_TRACKED || trackingType === LoggerTrackingType.TRACKED\n}\n","import type { RelativeTime, Context } from '@datadog/browser-core'\nimport {\n  willSyntheticsInjectRum,\n  addTelemetryDebug,\n  getSyntheticsTestId,\n  getSyntheticsResultId,\n} from '@datadog/browser-core'\n\ninterface Rum {\n  getInternalContext?: (startTime?: RelativeTime) => Context | undefined\n}\n\ninterface BrowserWindow {\n  DD_RUM?: Rum\n  DD_RUM_SYNTHETICS?: Rum\n}\n\nlet logsSentBeforeRumInjectionTelemetryAdded = false\n\nexport function getRUMInternalContext(startTime?: RelativeTime): Context | undefined {\n  const browserWindow = window as BrowserWindow\n\n  if (willSyntheticsInjectRum()) {\n    const context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS)\n    if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {\n      logsSentBeforeRumInjectionTelemetryAdded = true\n      addTelemetryDebug('Logs sent before RUM is injected by the synthetics worker', {\n        testId: getSyntheticsTestId(),\n        resultId: getSyntheticsResultId(),\n      })\n    }\n    return context\n  }\n\n  return getInternalContextFromRumGlobal(browserWindow.DD_RUM)\n\n  function getInternalContextFromRumGlobal(rumGlobal?: Rum): Context | undefined {\n    if (rumGlobal && rumGlobal.getInternalContext) {\n      return rumGlobal.getInternalContext(startTime)\n    }\n  }\n}\n\nexport function resetRUMInternalContext() {\n  logsSentBeforeRumInjectionTelemetryAdded = false\n}\n","import type { EventRateLimiter, RawError } from '@datadog/browser-core'\nimport { ErrorSource, combine, createEventRateLimiter, getRelativeTime, isEmptyObject } from '@datadog/browser-core'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { LogsConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { STATUSES } from './logger'\nimport type { LogsSessionManager } from './logsSessionManager'\nimport { getRUMInternalContext } from './contexts/rumInternalContext'\n\nexport function startLogsAssembly(\n  sessionManager: LogsSessionManager,\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const statusWithCustom = (STATUSES as string[]).concat(['custom'])\n  const logRateLimiters: { [key: string]: EventRateLimiter } = {}\n  statusWithCustom.forEach((status) => {\n    logRateLimiters[status] = createEventRateLimiter(status, configuration.eventRateLimiterThreshold, reportError)\n  })\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_LOG_COLLECTED,\n    ({ rawLogsEvent, messageContext = undefined, savedCommonContext = undefined, domainContext }) => {\n      const startTime = getRelativeTime(rawLogsEvent.date)\n      const session = sessionManager.findTrackedSession(startTime)\n\n      if (\n        !session &&\n        (!configuration.sendLogsAfterSessionExpiration ||\n          !sessionManager.findTrackedSession(startTime, { returnInactive: true }))\n      ) {\n        return\n      }\n\n      const commonContext = savedCommonContext || getCommonContext()\n      const log = combine(\n        {\n          service: configuration.service,\n          session_id: session?.id,\n          // Insert user first to allow overrides from global context\n          usr: !isEmptyObject(commonContext.user) ? commonContext.user : undefined,\n          view: commonContext.view,\n        },\n        commonContext.context,\n        getRUMInternalContext(startTime),\n        rawLogsEvent,\n        messageContext\n      )\n\n      if (\n        configuration.beforeSend?.(log, domainContext) === false ||\n        (log.origin !== ErrorSource.AGENT &&\n          (logRateLimiters[log.status] ?? logRateLimiters['custom']).isLimitReached())\n      ) {\n        return\n      }\n\n      lifeCycle.notify(LifeCycleEventType.LOG_COLLECTED, log)\n    }\n  )\n}\n","import { setTimeout } from '../../tools/timer'\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport type { RawError } from '../error/error.types'\nimport { ErrorSource } from '../error/error.types'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import { flattenErrorCauses, tryToGetFingerprint } from '../error/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { ConsoleApiName, globalConsole } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport { find } from '../../tools/utils/polyfills'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { RawErrorCause } from '../error/error.types'\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { createHandlingStack, toStackTraceString, formatErrorMessage } from '../../tools/stackTrace/handlingStack'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack: string\n  fingerprint?: string\n  causes?: RawErrorCause[]\n}\n\nlet consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\nexport function resetConsoleObservable() {\n  consoleObservablesByApi = {}\n}\n\nfunction createConsoleObservable(api: ConsoleApiName) {\n  return new Observable<ConsoleLog>((observable) => {\n    const originalConsoleApi = globalConsole[api]\n\n    globalConsole[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      globalConsole[api] = originalConsoleApi\n    }\n  })\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  const message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n  let fingerprint\n  let causes\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    fingerprint = tryToGetFingerprint(firstErrorParam)\n    causes = firstErrorParam ? flattenErrorCauses(firstErrorParam, 'console') : undefined\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n    fingerprint,\n    causes,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return sanitize(param)\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(sanitize(param), undefined, 2)\n}\n","import type { Context, ClocksState, ConsoleLog } from '@datadog/browser-core'\nimport { timeStampNow, ConsoleApiName, ErrorSource, initConsoleObservable } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle, RawLogsEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger/isAuthorized'\nimport type { RawLogsEvent } from '../../rawLogsEvent.types'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport const LogStatusForApi = {\n  [ConsoleApiName.log]: StatusType.info,\n  [ConsoleApiName.debug]: StatusType.debug,\n  [ConsoleApiName.info]: StatusType.info,\n  [ConsoleApiName.warn]: StatusType.warn,\n  [ConsoleApiName.error]: StatusType.error,\n}\nexport function startConsoleCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const consoleSubscription = initConsoleObservable(configuration.forwardConsoleLogs).subscribe((log: ConsoleLog) => {\n    const collectedData: RawLogsEventCollectedData<RawLogsEvent> = {\n      rawLogsEvent: {\n        date: timeStampNow(),\n        message: log.message,\n        origin: ErrorSource.CONSOLE,\n        error:\n          log.api === ConsoleApiName.error\n            ? {\n                stack: log.stack,\n                fingerprint: log.fingerprint,\n                causes: log.causes,\n              }\n            : undefined,\n        status: LogStatusForApi[log.api],\n      },\n      domainContext: {\n        handlingStack: log.handlingStack,\n      },\n    }\n\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, collectedData)\n  })\n\n  return {\n    stop: () => {\n      consoleSubscription.unsubscribe()\n    },\n  }\n}\n","import type { Context, ClocksState, RawReport } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  ErrorSource,\n  RawReportType,\n  getFileFromStackTraceString,\n  initReportObservable,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger/isAuthorized'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForReport = {\n  [RawReportType.cspViolation]: StatusType.error,\n  [RawReportType.intervention]: StatusType.error,\n  [RawReportType.deprecation]: StatusType.warn,\n}\n\nexport function startReportCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const reportSubscription = initReportObservable(configuration, configuration.forwardReports).subscribe(\n    (report: RawReport) => {\n      let message = report.message\n      const status = LogStatusForReport[report.type]\n      let error\n      if (status === StatusType.error) {\n        error = {\n          kind: report.subtype,\n          stack: report.stack,\n        }\n      } else if (report.stack) {\n        message += ` Found in ${getFileFromStackTraceString(report.stack)!}`\n      }\n\n      lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n        rawLogsEvent: {\n          date: timeStampNow(),\n          message,\n          origin: ErrorSource.REPORT,\n          error,\n          status,\n        },\n      })\n    }\n  )\n\n  return {\n    stop: () => {\n      reportSubscription.unsubscribe()\n    },\n  }\n}\n","import type { InstrumentedMethodCall } from '../tools/instrumentMethod'\nimport { instrumentMethod } from '../tools/instrumentMethod'\nimport { Observable } from '../tools/observable'\nimport type { Duration, ClocksState } from '../tools/utils/timeUtils'\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\nimport { shallowClone } from '../tools/utils/objectUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListener } from './addEventListener'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n  handlingStack?: string\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable(configuration: Configuration) {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable(configuration)\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable(configuration: Configuration) {\n  return new Observable<XhrContext>((observable) => {\n    const { stop: stopInstrumentingStart } = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr)\n\n    const { stop: stopInstrumentingSend } = instrumentMethod(\n      XMLHttpRequest.prototype,\n      'send',\n      (call) => {\n        sendXhr(call, configuration, observable)\n      },\n      { computeHandlingStack: true }\n    )\n\n    const { stop: stopInstrumentingAbort } = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr)\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n}\n\nfunction openXhr({ target: xhr, parameters: [method, url] }: InstrumentedMethodCall<XMLHttpRequest, 'open'>) {\n  xhrContexts.set(xhr, {\n    state: 'open',\n    method: String(method).toUpperCase(),\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(\n  { target: xhr, handlingStack }: InstrumentedMethodCall<XMLHttpRequest, 'send'>,\n  configuration: Configuration,\n  observable: Observable<XhrContext>\n) {\n  const context = xhrContexts.get(xhr)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = xhr\n  startContext.handlingStack = handlingStack\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethod(xhr, 'onreadystatechange', () => {\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n      // application during a future event. For example, Angular is calling .abort() on\n      // completed requests during an onreadystatechange event, so the status becomes '0'\n      // before the request is collected.\n      onEnd()\n    }\n  })\n\n  const onEnd = () => {\n    unsubscribeLoadEndListener()\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = xhr.status\n    observable.notify(shallowClone(completeContext))\n  }\n\n  const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, xhr, 'loadend', onEnd)\n\n  observable.notify(startContext)\n}\n\nfunction abortXhr({ target: xhr }: InstrumentedMethodCall<XMLHttpRequest, 'abort'>) {\n  const context = xhrContexts.get(xhr) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\nimport { arrayFrom, startsWith } from './utils/polyfills'\nimport { createHandlingStack } from './stackTrace/handlingStack'\n\n/**\n * Object passed to the callback of an instrumented method call. See `instrumentMethod` for more\n * info.\n */\nexport type InstrumentedMethodCall<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = {\n  /**\n   * The target object on which the method was called.\n   */\n  target: TARGET\n\n  /**\n   * The parameters with which the method was called.\n   *\n   * Note: if needed, parameters can be mutated by the instrumentation\n   */\n  parameters: Parameters<TARGET[METHOD]>\n\n  /**\n   * Registers a callback that will be called after the original method is called, with the method\n   * result passed as argument.\n   */\n  onPostCall: (callback: PostCallCallback<TARGET, METHOD>) => void\n\n  /**\n   * The stack trace of the method call.\n   */\n  handlingStack?: string\n}\n\ntype PostCallCallback<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET> = (\n  result: ReturnType<TARGET[METHOD]>\n) => void\n\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod<TARGET extends { [key: string]: any }, METHOD extends keyof TARGET & string>(\n  targetPrototype: TARGET,\n  method: METHOD,\n  onPreCall: (this: null, callInfos: InstrumentedMethodCall<TARGET, METHOD>) => void,\n  { computeHandlingStack }: { computeHandlingStack?: boolean } = {}\n) {\n  let original = targetPrototype[method]\n\n  if (typeof original !== 'function') {\n    if (startsWith(method, 'on')) {\n      original = noop as TARGET[METHOD]\n    } else {\n      return { stop: noop }\n    }\n  }\n\n  let stopped = false\n\n  const instrumentation = function (this: TARGET): ReturnType<TARGET[METHOD]> | undefined {\n    if (stopped) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n      return original.apply(this, arguments as unknown as Parameters<TARGET[METHOD]>)\n    }\n\n    const parameters = arrayFrom(arguments) as Parameters<TARGET[METHOD]>\n\n    let postCallCallback: PostCallCallback<TARGET, METHOD> | undefined\n\n    callMonitored(onPreCall, null, [\n      {\n        target: this,\n        parameters,\n        onPostCall: (callback) => {\n          postCallCallback = callback\n        },\n        handlingStack: computeHandlingStack ? createHandlingStack() : undefined,\n      },\n    ])\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const result = original.apply(this, parameters)\n\n    if (postCallCallback) {\n      callMonitored(postCallCallback, null, [result])\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return result\n  }\n\n  targetPrototype[method] = instrumentation as TARGET[METHOD]\n\n  return {\n    stop: () => {\n      stopped = true\n      // If the instrumentation has been removed by a third party, keep the last one\n      if (targetPrototype[method] === instrumentation) {\n        targetPrototype[method] = original\n      }\n    },\n  }\n}\n\nexport function instrumentSetter<TARGET extends { [key: string]: any }, PROPERTY extends keyof TARGET>(\n  targetPrototype: TARGET,\n  property: PROPERTY,\n  after: (target: TARGET, value: TARGET[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  const stoppedInstrumentation = noop\n  let instrumentation = (target: TARGET, value: TARGET[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      if (instrumentation !== stoppedInstrumentation) {\n        after(target, value)\n      }\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: TARGET, value: TARGET[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(targetPrototype, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(targetPrototype, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(targetPrototype, property, originalDescriptor)\n      }\n      instrumentation = stoppedInstrumentation\n    },\n  }\n}\n","import type { InstrumentedMethodCall } from '../tools/instrumentMethod'\nimport { instrumentMethod } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { ClocksState } from '../tools/utils/timeUtils'\nimport { clocksNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: unknown\n  init?: RequestInit\n  url: string\n  handlingStack?: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchResolveContext extends FetchContextBase {\n  state: 'resolve'\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchResolveContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  return new Observable<FetchContext>((observable) => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(window, 'fetch', (call) => beforeSend(call, observable), {\n      computeHandlingStack: true,\n    })\n\n    return stop\n  })\n}\n\nfunction beforeSend(\n  { parameters, onPostCall, handlingStack }: InstrumentedMethodCall<Window, 'fetch'>,\n  observable: Observable<FetchContext>\n) {\n  const [input, init] = parameters\n  let methodFromParams = init && init.method\n\n  if (methodFromParams === undefined && input instanceof Request) {\n    methodFromParams = input.method\n  }\n\n  const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET'\n  const url = input instanceof Request ? input.url : normalizeUrl(String(input))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n    handlingStack,\n  }\n\n  observable.notify(context)\n\n  // Those properties can be changed by observable subscribers\n  parameters[0] = context.input as RequestInfo | URL\n  parameters[1] = context.init\n\n  onPostCall((responsePromise) => afterSend(observable, responsePromise, context))\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchResolveContext\n    context.state = 'resolve'\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n    }\n    observable.notify(context)\n  }\n\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","export function isServerError(status: number) {\n  return status >= 500\n}\n\nexport function tryToClone(response: Response): Response | undefined {\n  try {\n    return response.clone()\n  } catch (e) {\n    // clone can throw if the response has already been used by another instrumentation or is disturbed\n    return\n  }\n}\n","import type { FetchResolveContext, XhrCompleteContext } from '@datadog/browser-core'\nimport {\n  ErrorSource,\n  initXhrObservable,\n  RequestType,\n  initFetchObservable,\n  computeStackTrace,\n  toStackTraceString,\n  monitor,\n  noop,\n  readBytesFromStream,\n  tryToClone,\n  isServerError,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport type { LogsEventDomainContext } from '../../domainContext.types'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger/isAuthorized'\n\nexport function startNetworkErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const xhrSubscription = initXhrObservable(configuration).subscribe((context) => {\n    if (context.state === 'complete') {\n      handleResponse(RequestType.XHR, context)\n    }\n  })\n  const fetchSubscription = initFetchObservable().subscribe((context) => {\n    if (context.state === 'resolve') {\n      handleResponse(RequestType.FETCH, context)\n    }\n  })\n\n  function handleResponse(type: RequestType, request: XhrCompleteContext | FetchResolveContext) {\n    if (!configuration.isIntakeUrl(request.url) && (isRejected(request) || isServerError(request.status))) {\n      if ('xhr' in request) {\n        computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable)\n      } else if (request.response) {\n        computeFetchResponseText(request.response, configuration, onResponseDataAvailable)\n      } else if (request.error) {\n        computeFetchErrorText(request.error, configuration, onResponseDataAvailable)\n      }\n    }\n\n    function onResponseDataAvailable(responseData: unknown) {\n      const domainContext: LogsEventDomainContext<typeof ErrorSource.NETWORK> = {\n        isAborted: request.isAborted,\n        handlingStack: request.handlingStack,\n      }\n\n      lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n        rawLogsEvent: {\n          message: `${format(type)} error ${request.method} ${request.url}`,\n          date: request.startClocks.timeStamp,\n          error: {\n            stack: (responseData as string) || 'Failed to load',\n          },\n          http: {\n            method: request.method as any, // Cast resource method because of case mismatch cf issue RUMF-1152\n            status_code: request.status,\n            url: request.url,\n          },\n          status: StatusType.error,\n          origin: ErrorSource.NETWORK,\n        },\n        domainContext,\n      })\n    }\n  }\n\n  return {\n    stop: () => {\n      xhrSubscription.unsubscribe()\n      fetchSubscription.unsubscribe()\n    },\n  }\n}\n\n// TODO: ideally, computeXhrResponseData should always call the callback with a string instead of\n// `unknown`. But to keep backward compatibility, in the case of XHR with a `responseType` different\n// than \"text\", the response data should be whatever `xhr.response` is. This is a bit confusing as\n// Logs event 'stack' is expected to be a string. This should be changed in a future major version\n// as it could be a breaking change.\nexport function computeXhrResponseData(\n  xhr: XMLHttpRequest,\n  configuration: LogsConfiguration,\n  callback: (responseData: unknown) => void\n) {\n  if (typeof xhr.response === 'string') {\n    callback(truncateResponseText(xhr.response, configuration))\n  } else {\n    callback(xhr.response)\n  }\n}\n\nexport function computeFetchErrorText(\n  error: Error,\n  configuration: LogsConfiguration,\n  callback: (errorText: string) => void\n) {\n  callback(truncateResponseText(toStackTraceString(computeStackTrace(error)), configuration))\n}\n\nexport function computeFetchResponseText(\n  response: Response,\n  configuration: LogsConfiguration,\n  callback: (responseText?: string) => void\n) {\n  const clonedResponse = tryToClone(response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // if the clone failed or if the body is null, let's not try to read it.\n    callback()\n  } else if (!window.TextDecoder) {\n    // If the browser doesn't support TextDecoder, let's read the whole response then truncate it.\n    //\n    // This should only be the case on early versions of Edge (before they migrated to Chromium).\n    // Even if it could be possible to implement a workaround for the missing TextDecoder API (using\n    // a Blob and FileReader), we found another issue preventing us from reading only the first\n    // bytes from the response: contrary to other browsers, when reading from the cloned response,\n    // if the original response gets canceled, the cloned response is also canceled and we can't\n    // know about it.  In the following illustration, the promise returned by `reader.read()` may\n    // never be fulfilled:\n    //\n    // fetch('/').then((response) => {\n    //   const reader = response.clone().body.getReader()\n    //   readMore()\n    //   function readMore() {\n    //     reader.read().then(\n    //       (result) => {\n    //         if (result.done) {\n    //           console.log('done')\n    //         } else {\n    //           readMore()\n    //         }\n    //       },\n    //       () => console.log('error')\n    //     )\n    //   }\n    //   response.body.getReader().cancel()\n    // })\n    clonedResponse.text().then(\n      monitor((text) => callback(truncateResponseText(text, configuration))),\n      monitor((error) => callback(`Unable to retrieve response: ${error as string}`))\n    )\n  } else {\n    truncateResponseStream(\n      clonedResponse.body,\n      configuration.requestErrorResponseLengthLimit,\n      (error, responseText) => {\n        if (error) {\n          callback(`Unable to retrieve response: ${error as unknown as string}`)\n        } else {\n          callback(responseText)\n        }\n      }\n    )\n  }\n}\n\nfunction isRejected(request: { status: number; responseType?: string }) {\n  return request.status === 0 && request.responseType !== 'opaque'\n}\n\nfunction truncateResponseText(responseText: string, configuration: LogsConfiguration) {\n  if (responseText.length > configuration.requestErrorResponseLengthLimit) {\n    return `${responseText.substring(0, configuration.requestErrorResponseLengthLimit)}...`\n  }\n  return responseText\n}\n\nfunction format(type: RequestType) {\n  if (RequestType.XHR === type) {\n    return 'XHR'\n  }\n  return 'Fetch'\n}\n\nfunction truncateResponseStream(\n  stream: ReadableStream<Uint8Array>,\n  bytesLimit: number,\n  callback: (error?: Error, responseText?: string) => void\n) {\n  readBytesFromStream(\n    stream,\n    (error, bytes, limitExceeded) => {\n      if (error) {\n        callback(error)\n      } else {\n        let responseText = new TextDecoder().decode(bytes)\n        if (limitExceeded) {\n          responseText += '...'\n        }\n        callback(undefined, responseText)\n      }\n    },\n    {\n      bytesLimit,\n      collectStreamBody: true,\n    }\n  )\n}\n","import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n","import { instrumentMethod } from '../../tools/instrumentMethod'\nimport type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport type { StackTrace } from '../../tools/stackTrace/computeStackTrace'\nimport { computeStackTrace, computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace'\nimport { computeRawError } from './error'\nimport type { RawError } from './error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from './error.types'\n\nexport type UnhandledErrorCallback = (stackTrace: StackTrace, originalError?: any) => any\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  const handleRuntimeError = (stackTrace: StackTrace, originalError?: any) => {\n    const rawError = computeRawError({\n      stackTrace,\n      originalError,\n      startClocks: clocksNow(),\n      nonErrorPrefix: NonErrorPrefix.UNCAUGHT,\n      source: ErrorSource.SOURCE,\n      handling: ErrorHandling.UNHANDLED,\n    })\n    errorObservable.notify(rawError)\n  }\n  const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\nexport function instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethod(window, 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {\n    let stackTrace\n    if (errorObj instanceof Error) {\n      stackTrace = computeStackTrace(errorObj)\n    } else {\n      stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column)\n    }\n    callback(stackTrace, errorObj ?? messageObj)\n  })\n}\n\nexport function instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethod(window, 'onunhandledrejection', ({ parameters: [e] }) => {\n    const reason = e.reason || 'Empty reason'\n    const stack = computeStackTrace(reason)\n    callback(stack, reason)\n  })\n}\n","import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n","import { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\nimport type { CommonContext, RawLogsEvent } from '../rawLogsEvent.types'\nimport type { LogsEventDomainContext } from '../domainContext.types'\n\nexport const enum LifeCycleEventType {\n  RAW_LOG_COLLECTED,\n  LOG_COLLECTED,\n}\n\ninterface LifeCycleEventMap {\n  [LifeCycleEventType.RAW_LOG_COLLECTED]: RawLogsEventCollectedData\n  [LifeCycleEventType.LOG_COLLECTED]: LogsEvent & Context\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n\nexport interface RawLogsEventCollectedData<E extends RawLogsEvent = RawLogsEvent> {\n  rawLogsEvent: E\n  messageContext?: object\n  savedCommonContext?: CommonContext\n  domainContext?: LogsEventDomainContext<E['origin']>\n}\n","import type { Context, TimeStamp } from '@datadog/browser-core'\nimport {\n  combine,\n  ErrorSource,\n  timeStampNow,\n  originalConsoleMethods,\n  globalConsole,\n  ConsoleApiName,\n} from '@datadog/browser-core'\nimport type { CommonContext, RawLogsEvent } from '../../rawLogsEvent.types'\nimport type { LifeCycle, RawLogsEventCollectedData } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { Logger, LogsMessage } from '../logger'\nimport { HandlerType } from '../logger'\nimport { isAuthorized, StatusType } from './isAuthorized'\n\nexport function startLoggerCollection(lifeCycle: LifeCycle) {\n  function handleLog(\n    logsMessage: LogsMessage,\n    logger: Logger,\n    handlingStack?: string,\n    savedCommonContext?: CommonContext,\n    savedDate?: TimeStamp\n  ) {\n    const messageContext = combine(logger.getContext(), logsMessage.context)\n\n    if (isAuthorized(logsMessage.status, HandlerType.console, logger)) {\n      displayInConsole(logsMessage, messageContext)\n    }\n\n    if (isAuthorized(logsMessage.status, HandlerType.http, logger)) {\n      const rawLogEventData: RawLogsEventCollectedData<RawLogsEvent> = {\n        rawLogsEvent: {\n          date: savedDate || timeStampNow(),\n          message: logsMessage.message,\n          status: logsMessage.status,\n          origin: ErrorSource.LOGGER,\n        },\n        messageContext,\n        savedCommonContext,\n      }\n\n      if (handlingStack) {\n        rawLogEventData.domainContext = { handlingStack }\n      }\n\n      lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, rawLogEventData)\n    }\n  }\n\n  return {\n    handleLog,\n  }\n}\nconst loggerToConsoleApiName: { [key in StatusType]: ConsoleApiName } = {\n  [StatusType.ok]: ConsoleApiName.debug,\n  [StatusType.debug]: ConsoleApiName.debug,\n  [StatusType.info]: ConsoleApiName.info,\n  [StatusType.notice]: ConsoleApiName.info,\n  [StatusType.warn]: ConsoleApiName.warn,\n  [StatusType.error]: ConsoleApiName.error,\n  [StatusType.critical]: ConsoleApiName.error,\n  [StatusType.alert]: ConsoleApiName.error,\n  [StatusType.emerg]: ConsoleApiName.error,\n}\n\nfunction displayInConsole({ status, message }: LogsMessage, messageContext: Context | undefined) {\n  originalConsoleMethods[loggerToConsoleApiName[status]].call(globalConsole, message, messageContext)\n}\n","import { DOCS_ORIGIN, display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageExitObservable'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { Subscription } from '../tools/observable'\nimport type { Encoder, EncoderResult } from '../tools/encoder'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport type { HttpRequest, Payload } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport class Batch {\n  private upsertBuffer: { [key: string]: string } = {}\n  private flushSubscription: Subscription\n\n  constructor(\n    private encoder: Encoder,\n    private request: HttpRequest,\n    public flushController: FlushController,\n    private messageBytesLimit: number\n  ) {\n    this.flushSubscription = this.flushController.flushObservable.subscribe((event) => this.flush(event))\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  stop() {\n    this.flushSubscription.unsubscribe()\n  }\n\n  private flush(event: FlushEvent) {\n    const upsertMessages = objectValues(this.upsertBuffer).join('\\n')\n    this.upsertBuffer = {}\n\n    const isPageExit = isPageExitReason(event.reason)\n    const send = isPageExit ? this.request.sendOnExit : this.request.send\n\n    if (\n      isPageExit &&\n      // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n      // if the encoder is async we need to send two requests in some cases (one for encoded data\n      // and the other for non-encoded data). But if it's not async, we don't have to worry about\n      // it and always send a single request.\n      this.encoder.isAsync\n    ) {\n      const encoderResult = this.encoder.finishSync()\n\n      // Send encoded messages\n      if (encoderResult.outputBytesCount) {\n        send(formatPayloadFromEncoder(encoderResult))\n      }\n\n      // Send messages that are not yet encoded at this point\n      const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n')\n      if (pendingMessages) {\n        send({\n          data: pendingMessages,\n          bytesCount: computeBytesCount(pendingMessages),\n        })\n      }\n    } else {\n      if (upsertMessages) {\n        this.encoder.write(this.encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`)\n      }\n      this.encoder.finish((encoderResult) => {\n        send(formatPayloadFromEncoder(encoderResult))\n      })\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const serializedMessage = jsonStringify(message)!\n\n    const estimatedMessageBytesCount = this.encoder.estimateEncodedBytesCount(serializedMessage)\n\n    if (estimatedMessageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB. More details: ${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting/#technical-limitations`\n      )\n      return\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n\n    this.push(serializedMessage, estimatedMessageBytesCount, key)\n  }\n\n  private push(serializedMessage: string, estimatedMessageBytesCount: number, key?: string) {\n    this.flushController.notifyBeforeAddMessage(estimatedMessageBytesCount)\n\n    if (key !== undefined) {\n      this.upsertBuffer[key] = serializedMessage\n      this.flushController.notifyAfterAddMessage()\n    } else {\n      this.encoder.write(\n        this.encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`,\n        (realMessageBytesCount) => {\n          this.flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount)\n        }\n      )\n    }\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = this.encoder.estimateEncodedBytesCount(removedMessage)\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount)\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n}\n\nfunction formatPayloadFromEncoder(encoderResult: EncoderResult): Payload {\n  let data: string | Blob\n  if (typeof encoderResult.output === 'string') {\n    data = encoderResult.output\n  } else {\n    data = new Blob([encoderResult.output], {\n      // This will set the 'Content-Type: text/plain' header. Reasoning:\n      // * The intake rejects the request if there is no content type.\n      // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n      // could induce higher intake load (and maybe has other impacts).\n      // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n      // new lines.\n      type: 'text/plain',\n    })\n  }\n\n  return {\n    data,\n    bytesCount: encoderResult.outputBytesCount,\n    encoding: encoderResult.encoding,\n  }\n}\n","import type { TrackType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, trackType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, trackType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, trackType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  trackType: TrackType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, trackType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder, Configuration } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor } from '../tools/monitor'\nimport { addEventListener } from '../browser/addEventListener'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData | Blob\n  bytesCount: number\n  retry?: RetryInfo\n  encoding?: 'deflate'\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload\n) {\n  const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', payload)\n      const isQueued = navigator.sendBeacon(beaconUrl, payload.data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  const xhrUrl = endpointBuilder.build('xhr', payload)\n  sendXHR(configuration, xhrUrl, payload.data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  payload: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch', payload)\n    fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })),\n      monitor(() => {\n        const xhrUrl = endpointBuilder.build('xhr', payload)\n        // failed to queue the request\n        sendXHR(configuration, xhrUrl, payload.data, onResponse)\n      })\n    )\n  } else {\n    const xhrUrl = endpointBuilder.build('xhr', payload)\n    sendXHR(configuration, xhrUrl, payload.data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(\n  configuration: Configuration,\n  url: string,\n  data: Payload['data'],\n  onResponse?: (r: HttpResponse) => void\n) {\n  const request = new XMLHttpRequest()\n  request.open('POST', url, true)\n  if (data instanceof Blob) {\n    // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n    // automatically, so the intake request ends up being rejected with an HTTP status 415\n    // Defining the header manually fixes this issue.\n    request.setRequestHeader('Content-Type', data.type)\n  }\n  addEventListener(\n    configuration,\n    request,\n    'loadend',\n    () => {\n      onResponse?.({ status: request.status })\n    },\n    {\n      // prevent multiple onResponse callbacks\n      // if the xhr instance is reused by a third party\n      once: true,\n    }\n  )\n  request.send(data)\n}\n","import type { PageExitEvent, PageExitReason } from '../browser/pageExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageExitObservable: Observable<PageExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const pageExitSubscription = pageExitObservable.subscribe((event) => flush(event.reason))\n  const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  const flushObservable = new Observable<FlushEvent>(() => () => {\n    pageExitSubscription.unsubscribe()\n    sessionExpireSubscription.unsubscribe()\n  })\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     *\n     * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n     * actually added.\n     */\n    notifyBeforeAddMessage(estimatedMessageBytesCount: number) {\n      if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += estimatedMessageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     *\n     * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n     * its actual bytes count once added to the pool.\n     */\n    notifyAfterAddMessage(messageBytesCountDiff = 0) {\n      currentBytesCount += messageBytesCountDiff\n\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     *\n     * @param messageBytesCount: the message bytes count that was added to the pool. Should\n     * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n     * `notifyAfterAddMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n","import type { Configuration, EndpointBuilder } from '../domain/configuration'\nimport type { Context } from '../tools/serialisation/context'\nimport type { Observable } from '../tools/observable'\nimport type { PageExitEvent } from '../browser/pageExitObservable'\nimport type { RawError } from '../domain/error/error.types'\nimport type { Encoder } from '../tools/encoder'\nimport { Batch } from './batch'\nimport { createHttpRequest } from './httpRequest'\nimport { createFlushController } from './flushController'\n\nexport interface BatchConfiguration {\n  endpoint: EndpointBuilder\n  encoder: Encoder\n}\n\ninterface ReplicaBatchConfiguration<T> extends BatchConfiguration {\n  transformMessage?: (message: T) => T\n}\n\nexport function startBatchWithReplica<T extends Context>(\n  configuration: Configuration,\n  primary: BatchConfiguration,\n  replica: ReplicaBatchConfiguration<T> | undefined,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const primaryBatch = createBatch(configuration, primary)\n  const replicaBatch = replica && createBatch(configuration, replica)\n\n  function createBatch(configuration: Configuration, { endpoint, encoder }: BatchConfiguration) {\n    return new Batch(\n      encoder,\n      createHttpRequest(configuration, endpoint, configuration.batchBytesLimit, reportError),\n      createFlushController({\n        messagesLimit: configuration.batchMessagesLimit,\n        bytesLimit: configuration.batchBytesLimit,\n        durationLimit: configuration.flushTimeout,\n        pageExitObservable,\n        sessionExpireObservable,\n      }),\n      configuration.messageBytesLimit\n    )\n  }\n\n  return {\n    flushObservable: primaryBatch.flushController.flushObservable,\n\n    add(message: T, replicated = true) {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message)\n      }\n    },\n\n    upsert: (message: T, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key)\n      }\n    },\n\n    stop: () => {\n      primaryBatch.stop()\n      replicaBatch?.stop()\n    },\n  }\n}\n","import { computeBytesCount } from './utils/byteUtils'\n\nexport interface Encoder<Output extends string | Uint8Array = string | Uint8Array> {\n  /**\n   * Whether this encoder might call the provided callbacks asynchronously\n   */\n  isAsync: boolean\n\n  /**\n   * Whether some data has been written since the last finish() or finishSync() call\n   */\n  isEmpty: boolean\n\n  /**\n   * Write a string to be encoded.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * If specified, the callback will be invoked when the operation finishes, unless the operation is\n   * asynchronous and finish() or finishSync() is called in the meantime.\n   */\n  write(data: string, callback?: (additionalEncodedBytesCount: number) => void): void\n\n  /**\n   * Waits for pending data to be encoded and resets the encoder state.\n   *\n   * This operation can be synchronous or asynchronous depending on the encoder implementation.\n   *\n   * The callback will be invoked when the operation finishes, unless the operation is asynchronous\n   * and another call to finish() or finishSync() occurs in the meantime.\n   */\n  finish(callback: (result: EncoderResult<Output>) => void): void\n\n  /**\n   * Resets the encoder state then returns the encoded data and any potential pending data directly,\n   * discarding all pending write operations and finish() callbacks.\n   */\n  finishSync(): EncoderResult<Output> & { pendingData: string }\n\n  /**\n   * Returns a rough estimation of the bytes count if the data was encoded.\n   */\n  estimateEncodedBytesCount(data: string): number\n}\n\nexport interface EncoderResult<Output extends string | Uint8Array = string | Uint8Array> {\n  output: Output\n  outputBytesCount: number\n\n  /**\n   * An encoding type supported by HTTP Content-Encoding, if applicable.\n   * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding#directives\n   */\n  encoding?: 'deflate'\n\n  /**\n   * Total bytes count of the input strings encoded to UTF-8.\n   */\n  rawBytesCount: number\n}\n\nexport function createIdentityEncoder(): Encoder<string> {\n  let output = ''\n  let outputBytesCount = 0\n\n  return {\n    isAsync: false,\n\n    get isEmpty() {\n      return !output\n    },\n\n    write(data, callback) {\n      const additionalEncodedBytesCount = computeBytesCount(data)\n      outputBytesCount += additionalEncodedBytesCount\n      output += data\n      if (callback) {\n        callback(additionalEncodedBytesCount)\n      }\n    },\n\n    finish(callback) {\n      callback(this.finishSync())\n    },\n\n    finishSync() {\n      const result = {\n        output,\n        outputBytesCount,\n        rawBytesCount: outputBytesCount,\n        pendingData: '',\n      }\n      output = ''\n      outputBytesCount = 0\n      return result\n    },\n\n    estimateEncodedBytesCount(data) {\n      return data.length\n    },\n  }\n}\n","import type { RawError, Observable, PageExitEvent, TelemetryEvent, Context } from '@datadog/browser-core'\nimport {\n  startTelemetry,\n  TelemetryService,\n  canUseEventBridge,\n  getEventBridge,\n  startBatchWithReplica,\n  createIdentityEncoder,\n  isTelemetryReplicationAllowed,\n  addTelemetryConfiguration,\n  drainPreStartTelemetry,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration, LogsInitConfiguration } from './configuration'\nimport { getRUMInternalContext } from './contexts/rumInternalContext'\nimport type { LogsSessionManager } from './logsSessionManager'\nimport { serializeLogsConfiguration } from './configuration'\n\nexport function startLogsTelemetry(\n  initConfiguration: LogsInitConfiguration,\n  configuration: LogsConfiguration,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  session: LogsSessionManager\n) {\n  const telemetry = startTelemetry(TelemetryService.LOGS, configuration)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: getRUMInternalContext()?.application_id,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: (getRUMInternalContext()?.view as Context)?.id,\n    },\n    action: {\n      id: (getRUMInternalContext()?.user_action as Context)?.id,\n    },\n  }))\n  const cleanupTasks: Array<() => void> = []\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    const telemetrySubscription = telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n    cleanupTasks.push(() => telemetrySubscription.unsubscribe())\n  } else {\n    const telemetryBatch = startBatchWithReplica(\n      configuration,\n      {\n        endpoint: configuration.rumEndpointBuilder,\n        encoder: createIdentityEncoder(),\n      },\n      configuration.replica && {\n        endpoint: configuration.replica.rumEndpointBuilder,\n        encoder: createIdentityEncoder(),\n      },\n      reportError,\n      pageExitObservable,\n      session.expireObservable\n    )\n    cleanupTasks.push(() => telemetryBatch.stop())\n    const telemetrySubscription = telemetry.observable.subscribe((event) =>\n      telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration))\n    )\n    cleanupTasks.push(() => telemetrySubscription.unsubscribe())\n  }\n  drainPreStartTelemetry()\n  addTelemetryConfiguration(serializeLogsConfiguration(initConfiguration))\n  return {\n    telemetry,\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n","import { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { LogsPublicApi } from '../boot/logsPublicApi'\nimport { makeLogsPublicApi } from '../boot/logsPublicApi'\nimport { startLogs } from '../boot/startLogs'\n\nexport { Logger, LogsMessage, HandlerType } from '../domain/logger'\nexport { StatusType } from '../domain/logger/isAuthorized'\nexport { LoggerConfiguration, LogsPublicApi as LogsGlobal } from '../boot/logsPublicApi'\nexport { LogsInitConfiguration } from '../domain/configuration'\nexport { LogsEvent } from '../logsEvent.types'\nexport { LogsEventDomainContext } from '../domainContext.types'\n\nexport const datadogLogs = makeLogsPublicApi(startLogs)\n\ninterface BrowserWindow extends Window {\n  DD_LOGS?: LogsPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_LOGS', datadogLogs)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils/polyfills'\nimport { display } from '../tools/display'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport interface PublicApi {\n  /**\n   * Version of the Logs browser SDK\n   */\n  version: string\n\n  /**\n   * [For CDN async setup] Early RUM API calls must be wrapped in the `window.DD_RUM.onReady()` callback. This ensures the code only gets executed once the SDK is properly loaded.\n   *\n   * See [CDN async setup](https://docs.datadoghq.com/real_user_monitoring/browser/#cdn-async) for further information.\n   */\n  onReady: (callback: () => void) => void\n}\n\nexport function makePublicApi<T extends PublicApi>(stub: Omit<T, keyof PublicApi>): T {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi as T\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable = global[name] as { q?: Array<() => void>; version?: string } | undefined\n  if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n    display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.')\n  }\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import type { ContextManager } from '@datadog/browser-core'\nimport type { CommonContext } from '../../rawLogsEvent.types'\n\nexport function buildCommonContext(\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager\n): CommonContext {\n  return {\n    view: {\n      referrer: document.referrer,\n      url: window.location.href,\n    },\n    context: globalContextManager.getContext(),\n    user: userContextManager.getContext(),\n  }\n}\n","import type { TrackingConsentState } from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageExitObservable,\n  willSyntheticsInjectRum,\n  canUseEventBridge,\n} from '@datadog/browser-core'\nimport { startLogsSessionManager, startLogsSessionManagerStub } from '../domain/logsSessionManager'\nimport type { LogsConfiguration, LogsInitConfiguration } from '../domain/configuration'\nimport { startLogsAssembly } from '../domain/assembly'\nimport { startConsoleCollection } from '../domain/console/consoleCollection'\nimport { startReportCollection } from '../domain/report/reportCollection'\nimport { startNetworkErrorCollection } from '../domain/networkError/networkErrorCollection'\nimport { startRuntimeErrorCollection } from '../domain/runtimeError/runtimeErrorCollection'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startLoggerCollection } from '../domain/logger/loggerCollection'\nimport { startLogsBatch } from '../transport/startLogsBatch'\nimport { startLogsBridge } from '../transport/startLogsBridge'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { startReportError } from '../domain/reportError'\nimport { startLogsTelemetry } from '../domain/logsTelemetry'\nimport type { CommonContext } from '../rawLogsEvent.types'\n\nexport type StartLogs = typeof startLogs\nexport type StartLogsResult = ReturnType<StartLogs>\n\nexport function startLogs(\n  initConfiguration: LogsInitConfiguration,\n  configuration: LogsConfiguration,\n  getCommonContext: () => CommonContext,\n\n  // `startLogs` and its subcomponents assume tracking consent is granted initially and starts\n  // collecting logs unconditionally. As such, `startLogs` should be called with a\n  // `trackingConsentState` set to \"granted\".\n  trackingConsentState: TrackingConsentState\n) {\n  const lifeCycle = new LifeCycle()\n  const cleanupTasks: Array<() => void> = []\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (log) => sendToExtension('logs', log))\n\n  const reportError = startReportError(lifeCycle)\n  const pageExitObservable = createPageExitObservable(configuration)\n\n  const session =\n    configuration.sessionStoreStrategyType && !canUseEventBridge() && !willSyntheticsInjectRum()\n      ? startLogsSessionManager(configuration, trackingConsentState)\n      : startLogsSessionManagerStub(configuration)\n\n  const { stop: stopLogsTelemetry } = startLogsTelemetry(\n    initConfiguration,\n    configuration,\n    reportError,\n    pageExitObservable,\n    session\n  )\n  cleanupTasks.push(() => stopLogsTelemetry())\n\n  startNetworkErrorCollection(configuration, lifeCycle)\n  startRuntimeErrorCollection(configuration, lifeCycle)\n  startConsoleCollection(configuration, lifeCycle)\n  startReportCollection(configuration, lifeCycle)\n  const { handleLog } = startLoggerCollection(lifeCycle)\n\n  startLogsAssembly(session, configuration, lifeCycle, getCommonContext, reportError)\n\n  if (!canUseEventBridge()) {\n    const { stop: stopLogsBatch } = startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable, session)\n    cleanupTasks.push(() => stopLogsBatch())\n  } else {\n    startLogsBridge(lifeCycle)\n  }\n\n  const internalContext = startInternalContext(session)\n\n  return {\n    handleLog,\n    getInternalContext: internalContext.get,\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n","import type { RawError } from '@datadog/browser-core'\nimport { ErrorSource, addTelemetryDebug } from '@datadog/browser-core'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { StatusType } from './logger/isAuthorized'\n\nexport function startReportError(lifeCycle: LifeCycle) {\n  return (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: error.message,\n        date: error.startClocks.timeStamp,\n        origin: ErrorSource.AGENT,\n        status: StatusType.error,\n      },\n    })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport { noop, ErrorSource, trackRuntimeError, Observable } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger/isAuthorized'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startRuntimeErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const rawErrorObservable = new Observable<RawError>()\n\n  const { stop: stopRuntimeErrorTracking } = trackRuntimeError(rawErrorObservable)\n\n  const rawErrorSubscription = rawErrorObservable.subscribe((rawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: rawError.message,\n        date: rawError.startClocks.timeStamp,\n        error: {\n          kind: rawError.type,\n          stack: rawError.stack,\n          causes: rawError.causes,\n        },\n        origin: ErrorSource.SOURCE,\n        status: StatusType.error,\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      stopRuntimeErrorTracking()\n      rawErrorSubscription.unsubscribe()\n    },\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { LogsSessionManager } from '../logsSessionManager'\n\nexport interface InternalContext {\n  session_id: string | undefined\n}\n\nexport function startInternalContext(sessionManager: LogsSessionManager) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const trackedSession = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (trackedSession) {\n        return {\n          session_id: trackedSession.id,\n        }\n      }\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'log', LogsEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    bridge.send('log', serverLogsEvent)\n  })\n}\n","import type { Context, Observable, PageExitEvent, RawError } from '@datadog/browser-core'\nimport { createIdentityEncoder, startBatchWithReplica } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\nimport type { LogsSessionManager } from '../domain/logsSessionManager'\n\nexport function startLogsBatch(\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  session: LogsSessionManager\n) {\n  const batch = startBatchWithReplica(\n    configuration,\n    {\n      endpoint: configuration.logsEndpointBuilder,\n      encoder: createIdentityEncoder(),\n    },\n    configuration.replica && {\n      endpoint: configuration.replica.logsEndpointBuilder,\n      encoder: createIdentityEncoder(),\n    },\n    reportError,\n    pageExitObservable,\n    session.expireObservable\n  )\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    batch.add(serverLogsEvent)\n  })\n\n  return batch\n}\n"],"names":["ConsoleApiName","log","debug","info","warn","error","globalConsole","console","originalConsoleMethods","Object","keys","forEach","name","PREFIX","display","bind","DOCS_ORIGIN","catchUserErrors","fn","errorMsg","args","err","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitored","_","__","descriptor","originalMethod","value","monitor","apply","this","callMonitored","arguments","context","e","displayIfDebugEnabled","candidate","search","indexOf","arrayFrom","arrayLike","Array","from","array","Set","item","push","i","length","objectValues","object","map","key","startsWith","slice","target","toAssign","source","prototype","hasOwnProperty","call","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","window","ONE_KIBI_BYTE","ONE_MEBI_BYTE","HAS_MULTI_BYTES_CHARACTERS","computeBytesCount","test","undefined","TextEncoder","encode","Blob","size","getZoneJsOriginalValue","original","browserWindow","Zone","__symbol__","callback","delay","timeoutId","throttle","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","cancel","jsonStringify","replacer","space","JSON","stringify","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","objectToJson","toJSON","objectHasValue","some","isEmptyObject","CUSTOMER_DATA_BYTES_LIMIT","CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT","BYTES_COMPUTATION_THROTTLING_DELAY","createCustomerDataTrackerManager","compressionStatus","customerDataTrackers","Map","alreadyWarned","checkCustomerDataLimit","initialBytesCount","bytesCountLimit","bytesCount","tracker","getBytesCount","displayCustomerDataLimitReachedWarning","createDetachedTracker","createCustomerDataTracker","getOrCreateTracker","type","has","set","setCompressionStatus","newCompressionStatus","getCompressionStatus","stop","clear","bytesCountCache","computeBytesCountThrottled","cancelComputeBytesCount","resetBytesCount","updateCustomerData","resetCustomerData","getType","isArray","mergeInto","destination","circularReferenceChecker","WeakSet","hasAlreadyBeenSeen","add","createCircularReferenceChecker","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","SANITIZE_DEFAULT_MAX_CHARACTER_COUNT","JSON_PATH_ROOT_ELEMENT","KEY_DECORATION_LENGTH","sanitize","maxCharacterCount","containerQueue","visitedObjectsWithPath","WeakMap","sanitizedData","sanitizeProcessor","accumulatedCharacterCount","containerToProcess","shift","separatorLength","targetData","path","warnOverCharacterLimit","parentPath","queue","sourceToSanitize","tryToApplyToJSON","toString","description","sanitizePrimitivesAndFunctions","sanitizedSource","Event","isTrusted","match","sanitizeObjects","sourceAsObject","currentPath","changeType","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","filter","other","notify","data","observer","mergeObservables","Observable","globalObservable","subscriptions","observables","observable","subscription","createContextManager","customerDataTracker","changeObservable","contextManager","getContext","setContext","newContext","clearContext","setContextProperty","property","removeContextProperty","DOM_EVENT","TrackingConsent","GRANTED","NOT_GRANTED","addEventListener","configuration","eventTarget","eventName","listener","addEventListeners","eventNames","once","capture","passive","listenerWithMonitor","event","__ddIsTrusted","allowUntrustedEvents","remove","CONTEXT_STORE_KEY_PREFIX","storageListeners","storeContextManager","productKey","customerDataType","storageKey","buildStorageKey","getFromStorage","rawContext","localStorage","getItem","parse","STORAGE","setItem","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","split","line","stackFrame","parts","CHROME_LINE_RE","exec","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","url","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","computeStackTraceFromOnErrorMessage","messageObj","ERROR_TYPES_RE","tryToParseMessage","createHandlingStack","formattedStack","Error","stackTrace","toStackTraceString","result","formatErrorMessage","frame","ExperimentalFeature","NO_ERROR_STACK_PRESENT_MESSAGE","computeRawError","originalError","handlingStack","startClocks","nonErrorPrefix","handling","isErrorInstance","computeMessage","hasUsableStack","causes","flattenErrorCauses","fingerprint","tryToGetFingerprint","dd_fingerprint","parentSource","currentError","cause","enabledExperimentalFeatures","initFeatureFlags","enableExperimentalFeatures","flag","getExperimentalFeatures","navigationStart","INTAKE_SITE_STAGING","INTAKE_SITE_FED_STAGING","INTAKE_SITE_US1","PCI_INTAKE_HOST_US1","ONE_SECOND","ONE_MINUTE","ONE_HOUR","dateNow","timeStampNow","relativeNow","performance","now","clocksNow","relative","timeStamp","addDuration","a","b","getRelativeTime","timestamp","getNavigationStart","timing","sendToExtension","payload","__ddBrowserSdkExtensionCallback","performDraw","threshold","Math","random","isPercentage","getConnectivity","navigator","status","onLine","interfaces","connection","effective_type","effectiveType","removeItem","index","splice","buffer","drain","arg","TelemetryType","usage","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","preStartTelemetryBuffer","onRawTelemetryEventCollected","startTelemetry","telemetryService","contextProvider","alreadySentEvents","telemetryEnabled","site","telemetrySampleRate","telemetryEnabledPerType","telemetryConfigurationSampleRate","telemetryUsageSampleRate","runtimeEnvInfo","is_local_file","location","protocol","is_worker","rawEvent","stringifiedEvent","maxTelemetryEventsPerPage","date","service","version","_dd","format_version","telemetry","runtime_env","connectivity","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","enabled","addTelemetryDebug","kind","scrubCustomerFrames","formatError","allowedFrameUrl","sanitizeUser","newUser","user","displayAlreadyInitializedError","sdkName","initConfiguration","silentMultipleInit","ErrorSource","AGENT","CONSOLE","CUSTOM","LOGGER","NETWORK","SOURCE","REPORT","isAuthorized","handlerType","logger","loggerHandler","getHandler","sanitizedHandlerType","STATUS_PRIORITIES","getLevel","StatusType","ok","notice","critical","alert","emerg","HandlerType","http","silent","STATUSES","handleLogStrategy","level","loggerContext","logImplementation","messageContext","errorContext","rawError","sanitizedMessageContext","setHandler","handler","setLevel","createLoggerMethod","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getCapabilities","getPrivacyLevel","getAllowedWebViewHosts","send","eventType","viewId","view","id","canUseEventBridge","currentHost","hostname","bridge","allowedHost","generateUUID","placeholder","parseInt","replace","Logger","browserCache","initCookieParsed","getCurrentSiteCache","COMMA_SEPARATED_KEY_VALUE","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","detectBrowserCached","userAgent","chrome","vendor","document","documentMode","detectBrowser","setCookie","_expireDelay","_options","sessionStorage","getCookie","getInitCookie","rawString","lastIndex","findCommaSeparatedValues","cookie","deleteCookie","SESSION_STORE_KEY","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","EXPIRED","getExpiredSessionState","isExpired","isSessionInNotStartedState","session","isSessionStarted","isSessionInExpiredState","sessionState","created","Number","expire","expandSessionState","toSessionString","toSessionState","sessionString","isValidSessionString","entry","matches","OLD_SESSION_COOKIE_NAME","OLD_RUM_COOKIE_NAME","OLD_LOGS_COOKIE_NAME","RUM_SESSION_KEY","LOGS_SESSION_KEY","selectCookieStrategy","cookieOptions","secure","useSecureSessionCookie","usePartitionedCrossSiteSessionCookie","useCrossSiteSessionCookie","crossSite","partitioned","trackSessionAcrossSubdomains","domain","testCookieName","domainLevels","candidateDomain","pop","getCurrentSite","buildCookieOptions","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","initCookieStrategy","cookieStore","isLockEnabled","persistSession","retrieveSession","retrieveSessionCookie","expireSession","cookieStoreStrategy","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","LOCAL_STORAGE_TEST_KEY","persistInLocalStorage","retrieveSessionFromLocalStorage","expireSessionFromLocalStorage","ongoingOperations","LOCK_RETRY_DELAY","LOCK_MAX_TRIES","bufferedOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","persistWithLock","lock","currentLock","retrieveStore","next","currentStore","retryLater","processedSession","process","after","sessionStore","currentNumberOfRetries","nextOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","sessionStoreStrategyType","allowFallbackToLocalStorage","testKey","retrievedId","selectLocalStorageStrategy","startSessionStore","computeSessionState","sessionCache","renewObservable","expireObservable","sessionStateUpdateObservable","watchSessionTimeoutId","synchronizeSession","startSession","synchronizedSession","trackingType","isTracked","expandOrRenewSessionState","hasSessionInCache","renewSessionInCache","throttledExpandOrRenewSession","cancelExpandOrRenewSession","isSessionInCacheOutdated","previousState","newState","expandOrRenewSession","expandSession","getSession","restartSession","updateSessionState","partialSessionState","normalizeUrl","buildUrl","href","base","supportedURL","isURLSupported","originalURL","getSupportedUrl","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","URL","createEndpointBuilder","trackType","configurationTags","buildUrlWithParameters","proxy","encodeURIComponent","host","internalAnalyticsSubdomain","usePciIntake","domainParts","extension","buildEndpointHost","createEndpointUrlWithParametersBuilder","build","api","clientToken","retry","encoding","tags","concat","count","lastFailureStatus","reverse","buildEndpointParameters","urlPrefix","TAG_SIZE_LIMIT","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","env","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeUrlPrefixes","builder","computeIntakeUrlPrefixes","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","checkIfString","tag","tagName","RawReportType","intervention","deprecation","cspViolation","initReportObservable","apis","SECURITY_POLICY_VIOLATION","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","originalReport","buildRawReportFromCspViolation","createCspViolationReportObservable","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportFromReport","types","buffered","observe","disconnect","createReportObservable","DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT","validateAndBuildLogsConfiguration","baseConfiguration","sessionSampleRate","trackingConsent","beforeSend","storeContextsAcrossPages","batchBytesLimit","eventRateLimiterThreshold","flushTimeout","batchMessagesLimit","messageBytesLimit","validateAndBuildConfiguration","forwardConsoleLogs","validateAndBuildForwardOption","forwardReports","forwardErrorsToLogs","requestErrorResponseLengthLimit","sendLogsAfterSessionExpiration","option","allowedValues","label","every","createPreStartStrategy","getCommonContext","trackingConsentState","doStartLogs","cachedInitConfiguration","cachedConfiguration","bufferApiCalls","trackingConsentStateSubscription","tryStartLogs","isGranted","startLogsResult","init","overrideInitConfigurationForBridge","tryToInit","getInternalContext","handleLog","statusType","LOGS_STORAGE_KEY","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","SYNTHETICS_TEST_ID_COOKIE_NAME","SYNTHETICS_RESULT_ID_COOKIE_NAME","SYNTHETICS_INJECTS_RUM_COOKIE_NAME","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getSyntheticsResultId","_DATADOG_SYNTHETICS_RESULT_ID","END_OF_TIMES","Infinity","CLEAR_OLD_VALUES_INTERVAL","expireDelay","maxEntries","entries","clearOldValuesInterval","clearOldValues","startTime","endTime","close","unshift","find","returnInactive","closeActive","latestEntry","findAll","duration","reset","oldTimeThreshold","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","stopCallbacks","startSessionManager","sessionContextHistory","ValueHistory","buildSessionContext","isReplayForced","forcedReplay","clocksOrigin","CLICK","TOUCH_START","KEY_DOWN","SCROLL","trackActivity","expandSessionWhenVisible","visibilityState","VISIBILITY_CHANGE","visibilityCheckInterval","trackVisibility","cb","RESUME","trackResume","findSession","startLogsSessionManager","sessionManager","rawTrackingType","rawSessionType","hasValidLoggerSession","computeTrackingType","findTrackedSession","logsSentBeforeRumInjectionTelemetryAdded","getRUMInternalContext","getInternalContextFromRumGlobal","DD_RUM_SYNTHETICS","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","DD_RUM","rumGlobal","startLogsAssembly","lifeCycle","reportError","statusWithCustom","logRateLimiters","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","rawLogsEvent","savedCommonContext","domainContext","commonContext","session_id","usr","origin","consoleObservablesByApi","initConsoleObservable","consoleObservables","originalConsoleApi","params","param","formatConsoleParameters","firstErrorParam","predicate","buildConsoleLog","createConsoleObservable","LogStatusForApi","xhrObservable","LogStatusForReport","instrumentMethod","targetPrototype","method","onPreCall","computeHandlingStack","stopped","instrumentation","postCallCallback","onPostCall","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","XMLHttpRequest","openXhr","stopInstrumentingSend","xhr","startContext","state","isAborted","hasBeenReported","stopInstrumentingOnReadyStateChange","readyState","DONE","onEnd","unsubscribeLoadEndListener","start","completeContext","sendXhr","stopInstrumentingAbort","abortXhr","createXhrObservable","toUpperCase","initFetchObservable","fetch","input","methodFromParams","Request","responsePromise","reportFetch","response","DOMException","code","ABORT_ERR","responseType","then","afterSend","isServerError","startNetworkErrorCollection","xhrSubscription","handleResponse","fetchSubscription","request","onResponseDataAvailable","responseData","format","status_code","isRejected","truncateResponseText","computeXhrResponseData","clonedResponse","clone","tryToClone","TextDecoder","stream","bytesLimit","reader","getReader","chunks","readBytesCount","onDone","bytes","limitExceeded","catch","collectStreamBody","Uint8Array","chunk","readMore","read","done","readBytesFromStream","responseText","decode","truncateResponseStream","text","computeFetchResponseText","computeFetchErrorText","substring","trackRuntimeError","errorObservable","handleRuntimeError","stopInstrumentingOnError","errorObj","stopInstrumentingOnUnhandledRejection","reason","instrumentUnhandledRejection","LifeCycle","callbacks","eventCallbacks","startLoggerCollection","logsMessage","savedDate","loggerToConsoleApiName","displayInConsole","rawLogEventData","encoder","flushController","upsertBuffer","flushSubscription","flushObservable","flush","addOrUpdate","upsert","upsertMessages","isPageExit","sendOnExit","isAsync","encoderResult","finishSync","outputBytesCount","formatPayloadFromEncoder","pendingMessages","pendingData","write","isEmpty","finish","serializedMessage","estimatedMessageBytesCount","estimateEncodedBytesCount","hasMessageFor","notifyBeforeAddMessage","notifyAfterAddMessage","realMessageBytesCount","removedMessage","messageBytesCount","notifyAfterRemoveMessage","output","MAX_ONGOING_BYTES_COUNT","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","MAX_BACKOFF_TIME","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","sendStrategy","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","first","dequeue","currentBackoffTime","min","shouldRetryRequest","ongoingRequestCount","isFull","queueFullReported","previousQueue","newPayloadQueue","createHttpRequest","endpointBuilder","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","canUseKeepAlive","isKeepAliveSupported","fetchUrl","keepalive","mode","xhrUrl","sendXHR","fetchKeepAliveStrategy","canUseBeacon","sendBeacon","beaconUrl","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","open","setRequestHeader","createFlushController","durationLimitTimeoutId","messagesLimit","durationLimit","pageExitObservable","sessionExpireObservable","pageExitSubscription","sessionExpireSubscription","currentBytesCount","currentMessagesCount","flushReason","messagesCount","cancelDurationLimitTimeout","messageBytesCountDiff","startBatchWithReplica","primary","primaryBatch","createBatch","replicaBatch","endpoint","Batch","replicated","transformMessage","createIdentityEncoder","additionalEncodedBytesCount","rawBytesCount","startLogsTelemetry","application","application_id","action","user_action","cleanupTasks","isTelemetryReplicationAllowed","addTelemetryConfiguration","baseSerializedInitConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","telemetry_usage_sample_rate","use_before_send","use_cross_site_session_cookie","use_partitioned_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","allow_fallback_to_local_storage","store_contexts_across_pages","allow_untrusted_events","tracking_consent","forward_errors_to_logs","forward_console_logs","forward_reports","use_pci_intake","send_logs_after_session_expiration","serializeLogsConfiguration","task","existingGlobalVariable","datadogLogs","startLogsImpl","currentConsent","customerDataTrackerManager","globalContextManager","userContextManager","update","referrer","buildCommonContext","stub","publicApi","strategy","createPostStartStrategy","customLoggers","mainLogger","setTrackingConsent","feature","getGlobalContext","setGlobalContext","setGlobalContextProperty","removeGlobalContextProperty","clearGlobalContext","createLogger","conf","getLogger","getInitConfiguration","setUser","isValid","checkUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","clearUser","onReady","enumerable","makeLogsPublicApi","startReportError","stopListeners","FREEZE","stopBeforeUnloadListener","BEFORE_UNLOAD","createPageExitObservable","startLogsSessionManagerStub","stopLogsTelemetry","rawErrorObservable","stopRuntimeErrorTracking","rawErrorSubscription","startRuntimeErrorCollection","consoleSubscription","collectedData","startConsoleCollection","reportSubscription","getFileFromStackTraceString","startReportCollection","serverLogsEvent","startLogsBridge","batch","startLogsBatch","trackedSession","q"],"sourceRoot":""}