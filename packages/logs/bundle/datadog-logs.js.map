{"version":3,"file":"datadog-logs.js","mappings":"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","sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils/polyfills.ts","webpack:///../core/src/tools/getGlobalObject.ts","webpack:///../core/src/tools/utils/byteUtils.ts","webpack:///../core/src/tools/getZoneJsOriginalValue.ts","webpack:///../core/src/tools/timer.ts","webpack:///../core/src/tools/utils/functionUtils.ts","webpack:///../core/src/tools/utils/typeUtils.ts","webpack:///../core/src/tools/mergeInto.ts","webpack:///../core/src/tools/serialisation/jsonStringify.ts","webpack:///../core/src/tools/serialisation/sanitize.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/context/heavyCustomerDataWarning.ts","webpack:///../core/src/domain/context/contextManager.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/tools/utils/timeUtils.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/browser/addEventListener.ts","webpack:///../core/src/domain/context/storedContextManager.ts","webpack:///../core/src/tools/experimentalFeatures.ts","webpack:///../core/src/domain/user/user.ts","webpack:///../core/src/tools/utils/numberUtils.ts","webpack:///../core/src/tools/utils/objectUtils.ts","webpack:///../core/src/tools/utils/stringUtils.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/session/storeStrategies/sessionStoreStrategy.ts","webpack:///../core/src/domain/session/sessionState.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInCookie.ts","webpack:///../core/src/domain/session/storeStrategies/sessionInLocalStorage.ts","webpack:///../core/src/domain/session/sessionStoreOperations.ts","webpack:///../core/src/tools/utils/browserDetection.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/tools/utils/urlPolyfill.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/domain/tracekit/computeStackTrace.ts","webpack:///../core/src/domain/error/error.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///./src/domain/configuration.ts","webpack:///../core/src/tools/utils/arrayUtils.ts","webpack:///../core/src/domain/error/error.types.ts","webpack:///./src/domain/logger.ts","webpack:///./src/boot/logsPublicApi.ts","webpack:///../core/src/tools/sendToExtension.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../core/src/browser/pageExitObservable.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/tools/utils/responseUtils.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../core/src/transport/flushController.ts","webpack:///../core/src/transport/startBatchWithReplica.ts","webpack:///../core/src/tools/valueHistory.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///./src/domain/logsSessionManager.ts","webpack:///./src/domain/logger/loggerCollection.ts","webpack:///./src/domain/assembly.ts","webpack:///../core/src/domain/eventRateLimiter/createEventRateLimiter.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///./src/domain/console/consoleCollection.ts","webpack:///./src/domain/report/reportCollection.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///./src/domain/networkError/networkErrorCollection.ts","webpack:///../core/src/tools/readBytesFromStream.ts","webpack:///../core/src/domain/tracekit/tracekit.ts","webpack:///./src/domain/runtimeError/runtimeErrorCollection.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///../core/src/tools/abstractLifeCycle.ts","webpack:///./src/domain/lifeCycle.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///./src/boot/startLogs.ts","webpack:///./src/domain/internalContext.ts","webpack:///./src/transport/startLogsBridge.ts","webpack:///./src/transport/startLogsBatch.ts"],"sourcesContent":["/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = (typeof ConsoleApiName)[keyof typeof ConsoleApiName]\n\ninterface Display {\n  (api: ConsoleApiName, ...args: any[]): void\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\nexport const display: Display = (api, ...args) => {\n  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {\n    api = ConsoleApiName.log\n  }\n  display[api](...args)\n}\n\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console\n\ndisplay.debug = globalConsole.debug.bind(globalConsole)\ndisplay.log = globalConsole.log.bind(globalConsole)\ndisplay.info = globalConsole.info.bind(globalConsole)\ndisplay.warn = globalConsole.warn.bind(globalConsole)\ndisplay.error = globalConsole.error.bind(globalConsole)\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { ConsoleApiName, display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(ConsoleApiName.error, e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(ConsoleApiName.error, e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(api: ConsoleApiName, ...args: any[]) {\n  if (debugMode) {\n    display(api, '[MONITOR]', ...args)\n  }\n}\n","export function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(array: ArrayLike<unknown>, predicate: (item: unknown, index: number) => boolean): unknown {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function forEach<List extends { [index: number]: any }>(\n  list: List,\n  callback: (value: List[number], index: number, parent: List) => void\n) {\n  Array.prototype.forEach.call(list, callback as any)\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectEntries<T = unknown>(object: { [key: string]: T }): Array<[string, T]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\n// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\n\nexport function getGlobalObject<T = typeof globalThis>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n","export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]) {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n","import { getGlobalObject } from './getGlobalObject'\n\nexport interface BrowserWindowWithZoneJs extends Window {\n  Zone?: {\n    // All Zone.js versions expose the __symbol__ method, but we observed that some website have a\n    // 'Zone' global variable unrelated to Zone.js, so let's consider this method optional\n    // nonetheless.\n    __symbol__?: (name: string) => string\n  }\n}\n\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue<Target, Name extends keyof Target & string>(\n  target: Target,\n  name: Name\n): Target[Name] {\n  const browserWindow = getGlobalObject<BrowserWindowWithZoneJs>()\n  let original: Target[Name] | undefined\n  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n    original = (target as any)[browserWindow.Zone.__symbol__(name)]\n  }\n  if (!original) {\n    original = target[name]\n  }\n  return original\n}\n","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue'\nimport { monitor } from './monitor'\nimport { getGlobalObject } from './getGlobalObject'\n\nexport type TimeoutId = ReturnType<typeof globalThis.setTimeout>\n\nexport function setTimeout(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay)\n}\n\nexport function clearTimeout(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId)\n}\n\nexport function setInterval(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay)\n}\n\nexport function clearInterval(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId)\n}\n","import type { TimeoutId } from '../timer'\nimport { setTimeout, clearTimeout } from '../timer'\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\nexport type ListenerHandler = () => void\n","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n","import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n    TDestination extends undefined\n    ? TSource\n    : // case 3 - source is an array - see if it merges or overwrites\n    TSource extends any[]\n    ? TDestination extends any[]\n      ? TDestination & TSource\n      : TSource\n    : // case 4 - source is an object - see if it merges or overwrites\n    TSource extends object\n    ? TDestination extends object\n      ? TDestination extends any[]\n        ? TSource\n        : TDestination & TSource\n      : TSource\n    : // case 5 - cannot merge - return source\n      TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n","import { noop } from '../utils/functionUtils'\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(\n  value: unknown,\n  replacer?: Array<string | number>,\n  space?: string | number\n): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, replacer, space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\nexport interface ObjectWithToJsonMethod {\n  toJSON?: () => unknown\n}\n\nexport function detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n","import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  let accumulatedCharacterCount = JSON.stringify(sanitizedData)?.length || 0\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value: object) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted,\n      }\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: () => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  const globalObservable = new Observable<T>(() => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n\n  return globalObservable\n}\n","import { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { display } from '../../tools/display'\nimport { CustomerDataType } from './contextConstants'\n\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE\n\nconst CustomerDataLabel = {\n  [CustomerDataType.FeatureFlag]: 'feature flag evaluation',\n  [CustomerDataType.User]: 'user',\n  [CustomerDataType.GlobalContext]: 'global context',\n  [CustomerDataType.LoggerContext]: 'logger context',\n}\nexport function warnIfCustomerDataLimitReached(bytesCount: number, customerDataType: CustomerDataType): boolean {\n  if (bytesCount > CUSTOMER_DATA_BYTES_LIMIT) {\n    display.warn(\n      `The ${CustomerDataLabel[customerDataType]} data exceeds the recommended ${\n        CUSTOMER_DATA_BYTES_LIMIT / ONE_KIBI_BYTE\n      }KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-3kib-warning`\n    )\n    return true\n  }\n  return false\n}\n","import { computeBytesCount } from '../../tools/utils/byteUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { deepClone } from '../../tools/mergeInto'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { Context, ContextValue } from '../../tools/serialisation/context'\nimport { Observable } from '../../tools/observable'\nimport { warnIfCustomerDataLimitReached } from './heavyCustomerDataWarning'\nimport type { CustomerDataType } from './contextConstants'\n\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type ContextManager = ReturnType<typeof createContextManager>\n\nexport function createContextManager(customerDataType: CustomerDataType, computeBytesCountImpl = computeBytesCount) {\n  let context: Context = {}\n  let bytesCountCache: number\n  let alreadyWarned = false\n  const changeObservable = new Observable<void>()\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCountImpl(jsonStringify(context)!)\n    if (!alreadyWarned) {\n      alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, customerDataType)\n    }\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  const contextManager = {\n    getBytesCount: () => bytesCountCache,\n    /** @deprecated use getContext instead */\n    get: () => context,\n\n    /** @deprecated use setContextProperty instead */\n    add: (key: string, value: any) => {\n      context[key] = value as ContextValue\n      computeBytesCountThrottled(context)\n      changeObservable.notify()\n    },\n\n    /** @deprecated renamed to removeContextProperty */\n    remove: (key: string) => {\n      delete context[key]\n      computeBytesCountThrottled(context)\n      changeObservable.notify()\n    },\n\n    /** @deprecated use setContext instead */\n    set: (newContext: object) => {\n      context = newContext as Context\n      computeBytesCountThrottled(context)\n      changeObservable.notify()\n    },\n\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      if (getType(newContext) === 'object') {\n        context = sanitize(newContext)\n        computeBytesCountThrottled(context)\n      } else {\n        contextManager.clearContext()\n      }\n      changeObservable.notify()\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = sanitize(property)\n      computeBytesCountThrottled(context)\n      changeObservable.notify()\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n      computeBytesCountThrottled(context)\n      changeObservable.notify()\n    },\n\n    clearContext: () => {\n      context = {}\n      bytesCountCache = 0\n      changeObservable.notify()\n    },\n\n    changeObservable,\n  }\n  return contextManager\n}\n","const BUFFER_LIMIT = 500\n\nexport class BoundedBuffer {\n  private buffer: Array<() => void> = []\n\n  add(callback: () => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  drain() {\n    this.buffer.forEach((callback) => callback())\n    this.buffer.length = 0\n  }\n}\n","import { isNumber, round } from './numberUtils'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","import { endsWith } from '../tools/utils/polyfills'\nimport { getGlobalObject } from '../tools/getGlobalObject'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E) {\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event }))\n    },\n  }\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { Configuration } from '../domain/configuration'\nimport type { VisualViewport, VisualViewportEventMap } from './types'\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n  STORAGE = 'storage',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n  ? DocumentEventMap\n  : T extends HTMLElement\n  ? HTMLElementEventMap\n  : T extends VisualViewport\n  ? VisualViewportEventMap\n  : T extends ShadowRoot\n  ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n    // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n    // through the ShadowRoot like \"change\" or \"input\"\n    GlobalEventHandlersEventMap\n  : T extends XMLHttpRequest\n  ? XMLHttpRequestEventMap\n  : T extends Performance\n  ? PerformanceEventMap\n  : T extends Worker\n  ? WorkerEventMap\n  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  configuration: Configuration,\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(configuration, eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  _: Configuration,\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName] & { type: EventName }) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const listenerWithMonitor = monitor(\n    once\n      ? (event: Event) => {\n          stop()\n          listener(event as unknown as EventMapFor<Target>[EventName] & { type: EventName })\n        }\n      : (listener as unknown as (event: Event) => void)\n  )\n\n  const options = passive ? { capture, passive } : capture\n\n  const add = getZoneJsOriginalValue(eventTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options))\n  }\n\n  return {\n    stop,\n  }\n}\n","import { computeBytesCount } from '../../tools/utils/byteUtils'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport type { Context } from '../../tools/serialisation/context'\nimport type { Configuration } from '../configuration'\nimport type { ContextManager } from './contextManager'\nimport { createContextManager } from './contextManager'\nimport type { CustomerDataType } from './contextConstants'\n\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c'\n\nconst storageListeners: Array<{ stop: () => void }> = []\n\nexport function createStoredContextManager(\n  configuration: Configuration,\n  productKey: string,\n  customerDataType: CustomerDataType,\n  computeBytesCountImpl = computeBytesCount\n): ContextManager {\n  const storageKey = buildStorageKey(productKey, customerDataType)\n  const contextManager = createContextManager(customerDataType, computeBytesCountImpl)\n\n  synchronizeWithStorage()\n  storageListeners.push(\n    addEventListener(configuration, window, DOM_EVENT.STORAGE, ({ key }) => {\n      if (storageKey === key) {\n        synchronizeWithStorage()\n      }\n    })\n  )\n  contextManager.changeObservable.subscribe(dumpToStorage)\n\n  return contextManager\n\n  function synchronizeWithStorage() {\n    const rawContext = localStorage.getItem(storageKey)\n    const context = rawContext !== null ? (JSON.parse(rawContext) as Context) : {}\n    contextManager.setContext(context)\n  }\n\n  function dumpToStorage() {\n    localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()))\n  }\n}\n\nexport function buildStorageKey(productKey: string, customerDataType: CustomerDataType) {\n  return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`\n}\n\nexport function removeStorageListeners() {\n  storageListeners.map((listener) => listener.stop())\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\n// eslint-disable-next-line no-restricted-syntax\nexport enum ExperimentalFeature {\n  PAGEHIDE = 'pagehide',\n  FEATURE_FLAGS = 'feature_flags',\n  RESOURCE_PAGE_STATES = 'resource_page_states',\n  PAGE_STATES = 'page_states',\n  COLLECT_FLUSH_REASON = 'collect_flush_reason',\n  NO_RESOURCE_DURATION_FROZEN_STATE = 'no_resource_duration_frozen_state',\n  SCROLLMAP = 'scrollmap',\n  INTERACTION_TO_NEXT_PAINT = 'interaction_to_next_paint',\n  DISABLE_REPLAY_INLINE_CSS = 'disable_replay_inline_css',\n}\n\nconst enabledExperimentalFeatures: Set<ExperimentalFeature> = new Set()\n\nexport function addExperimentalFeatures(enabledFeatures: ExperimentalFeature[]): void {\n  enabledFeatures.forEach((flag) => {\n    enabledExperimentalFeatures.add(flag)\n  })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: ExperimentalFeature): boolean {\n  return enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures.clear()\n}\n\nexport function getExperimentalFeatures(): Set<ExperimentalFeature> {\n  return enabledExperimentalFeatures\n}\n","import type { Context } from '../../tools/serialisation/context'\nimport { display } from '../../tools/display'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { User } from './user.types'\n\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser: Context): Context {\n  // We shallow clone only to prevent mutation of user data.\n  const user = assign({}, newUser)\n  const keys = ['id', 'name', 'email']\n  keys.forEach((key) => {\n    if (key in user) {\n      user[key] = String(user[key])\n    }\n  })\n  return user\n}\n\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser: User): boolean {\n  const isValid = getType(newUser) === 'object'\n  if (!isValid) {\n    display.error('Unsupported user:', newUser)\n  }\n  return isValid\n}\n","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n","import { assign } from './polyfills'\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\nexport function findCommaSeparatedValue(rawString: string, name: string) {\n  const regex = new RegExp(`(?:^|;)\\\\s*${name}\\\\s*=\\\\s*([^;]+)`)\n  const matches = regex.exec(rawString)\n  return matches ? matches[1] : undefined\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) {\n    return candidate\n  }\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils/timeUtils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  domain?: string\n}\n\nexport function setCookie(name: string, value: string, _expireDelay: number, _options?: CookieOptions) {\n  sessionStorage.setItem(name, value)\n}\n\nexport function getCookie(name: string) {\n  return sessionStorage.getItem(name)\n}\n\nexport function deleteCookie(name: string, _options?: CookieOptions) {\n  sessionStorage.removeItem(name)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","import type { CookieOptions } from '../../../browser/cookie'\nimport type { SessionState } from '../sessionState'\n\nexport const SESSION_STORE_KEY = '_dd_s'\n\nexport type SessionStoreStrategyType = { type: 'Cookie'; cookieOptions: CookieOptions } | { type: 'LocalStorage' }\n\nexport interface SessionStoreStrategy {\n  persistSession: (session: SessionState) => void\n  retrieveSession: () => SessionState\n  clearSession: () => void\n}\n","import { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { objectEntries } from '../../tools/utils/polyfills'\nimport { dateNow } from '../../tools/utils/timeUtils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\nexport function isSessionInExpiredState(session: SessionState) {\n  return isEmptyObject(session)\n}\n\nexport function expandSessionState(session: SessionState) {\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n}\n\nexport function toSessionString(session: SessionState) {\n  return objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function toSessionState(sessionString: string | undefined | null) {\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined | null): sessionString is string {\n  return (\n    !!sessionString &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n","import { getCookie } from '../../browser/cookie'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy: SessionStoreStrategy) {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  if (!sessionString) {\n    const oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME)\n    const oldRumType = getCookie(OLD_RUM_COOKIE_NAME)\n    const oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME)\n    const session: SessionState = {}\n\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n\n    if (!isSessionInExpiredState(session)) {\n      expandSessionState(session)\n      cookieStoreStrategy.persistSession(session)\n    }\n  }\n}\n","import type { CookieOptions } from '../../../browser/cookie'\nimport { getCurrentSite, areCookiesAuthorized, deleteCookie, getCookie, setCookie } from '../../../browser/cookie'\nimport type { InitConfiguration } from '../../configuration'\nimport { tryOldCookiesMigration } from '../oldCookiesMigration'\nimport { SESSION_EXPIRATION_DELAY } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nexport function selectCookieStrategy(initConfiguration: InitConfiguration): SessionStoreStrategyType | undefined {\n  const cookieOptions = buildCookieOptions(initConfiguration)\n  return areCookiesAuthorized(cookieOptions) ? { type: 'Cookie', cookieOptions } : undefined\n}\n\nexport function initCookieStrategy(cookieOptions: CookieOptions): SessionStoreStrategy {\n  const cookieStore = {\n    persistSession: persistSessionCookie(cookieOptions),\n    retrieveSession: retrieveSessionCookie,\n    clearSession: deleteSessionCookie(cookieOptions),\n  }\n\n  tryOldCookiesMigration(cookieStore)\n\n  return cookieStore\n}\n\nfunction persistSessionCookie(options: CookieOptions) {\n  return (session: SessionState) => {\n    setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n  }\n}\n\nfunction retrieveSessionCookie(): SessionState {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction deleteSessionCookie(options: CookieOptions) {\n  return () => {\n    deleteCookie(SESSION_STORE_KEY, options)\n  }\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  cookieOptions.secure = !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n","import { generateUUID } from '../../../tools/utils/stringUtils'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_'\n\nexport function selectLocalStorageStrategy(): SessionStoreStrategyType | undefined {\n  try {\n    const id = generateUUID()\n    const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`\n    localStorage.setItem(testKey, id)\n    const retrievedId = localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n    return id === retrievedId ? { type: 'LocalStorage' } : undefined\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function initLocalStorageStrategy(): SessionStoreStrategy {\n  return {\n    persistSession: persistInLocalStorage,\n    retrieveSession: retrieveSessionFromLocalStorage,\n    clearSession: clearSessionFromLocalStorage,\n  }\n}\n\nfunction persistInLocalStorage(sessionState: SessionState) {\n  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState))\n}\n\nfunction retrieveSessionFromLocalStorage(): SessionState {\n  const sessionString = localStorage.getItem(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction clearSessionFromLocalStorage() {\n  localStorage.removeItem(SESSION_STORE_KEY)\n}\n","import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { isChromium } from '../../tools/utils/browserDetection'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { retrieveSession, persistSession, clearSession } = sessionStoreStrategy\n  const lockEnabled = isLockEnabled()\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (lockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (lockEnabled) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = generateUUID()\n    currentSession.lock = currentLock\n    persistSession(currentSession)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (lockEnabled) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      clearSession()\n    } else {\n      expandSessionState(processedSession)\n      persistSession(processedSession)\n    }\n  }\n  if (lockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      persistSession(currentSession)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next(sessionStoreStrategy)\n}\n\n/**\n * Lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n */\nexport const isLockEnabled = () => isChromium()\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n","export function isIE() {\n  return Boolean((document as any).documentMode)\n}\n\nexport function isChromium() {\n  return !!(window as any).chrome || /HeadlessChrome/.test(window.navigator.userAgent)\n}\n","import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from '../configuration'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n  stop: () => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy()\n  }\n  return sessionStoreStrategyType\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === 'Cookie'\n      ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy()\n  const { clearSession, retrieveSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          const synchronizedSession = synchronizeSession(sessionState)\n          isTracked = expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isTracked && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (!isActiveSession(sessionState) ? {} : undefined),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (!isActiveSession(sessionState)) {\n      sessionState = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(sessionState: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n      (sessionState.expire === undefined || dateNow() < Number(sessionState.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: throttle(expandOrRenewSession, STORAGE_POLL_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    expire: () => {\n      clearSession()\n      synchronizeSession({})\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n","import { jsonStringify } from '../serialisation/jsonStringify'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, getLocationOrigin()).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function getOrigin(url: string) {\n  return getLinkElementOrigin(buildUrl(url))\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function getSearch(url: string) {\n  return buildUrl(url).search\n}\n\nexport function getHash(url: string) {\n  return buildUrl(url).hash\n}\n\nexport function buildUrl(url: string, base?: string) {\n  const supportedURL = getSupportedUrl()\n  if (supportedURL) {\n    try {\n      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url)\n    } catch (error) {\n      throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })!}`)\n    }\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nconst originalURL = URL\nlet isURLSupported: boolean | undefined\nfunction getSupportedUrl(): typeof URL | undefined {\n  if (isURLSupported === undefined) {\n    try {\n      const url = new originalURL('http://test/path')\n      isURLSupported = url.href === 'http://test/path'\n    } catch {\n      isURLSupported = false\n    }\n  }\n  return isURLSupported ? originalURL : undefined\n}\n\nexport function getLocationOrigin() {\n  return getLinkElementOrigin(window.location)\n}\n\n/**\n * Fallback\n * On IE HTMLAnchorElement origin is not supported: https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin\n * On Firefox window.location.origin is \"null\" for file: URIs: https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n */\nexport function getLinkElementOrigin(element: Location | HTMLAnchorElement | URL) {\n  if (element.origin && element.origin !== 'null') {\n    return element.origin\n  }\n  const sanitizedHost = element.host.replace(/(:80|:443)$/, '')\n  return `${element.protocol}//${sanitizedHost}`\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu'\nexport const INTAKE_SITE_AP1 = 'ap1.datadoghq.com'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n","import type { RetryInfo, FlushReason } from '../../transport'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill'\nimport { ExperimentalFeature, isExperimentalFeatureEnabled } from '../../tools/experimentalFeatures'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_AP1, INTAKE_SITE_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport const ENDPOINTS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'session-replay',\n} as const\n\nconst INTAKE_TRACKS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'replay',\n}\n\nexport type EndpointType = keyof typeof ENDPOINTS\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType,\n  configurationTags: string[]\n) {\n  const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, endpointType)\n\n  return {\n    build(api: 'xhr' | 'fetch' | 'beacon', flushReason?: FlushReason, retry?: RetryInfo) {\n      const parameters = buildEndpointParameters(\n        initConfiguration,\n        endpointType,\n        configurationTags,\n        api,\n        flushReason,\n        retry\n      )\n      return buildUrlWithParameters(parameters)\n    },\n    urlPrefix: buildUrlWithParameters(''),\n    endpointType,\n  }\n}\n\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType\n): (parameters: string) => string {\n  const path = `/api/v2/${INTAKE_TRACKS[endpointType]}`\n\n  const { proxy, proxyUrl } = initConfiguration\n  if (proxy) {\n    const normalizedProxyUrl = normalizeUrl(proxy)\n    return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`\n  }\n\n  const host = buildEndpointHost(initConfiguration, endpointType)\n\n  if (proxy === undefined && proxyUrl) {\n    // TODO: remove this in a future major.\n    const normalizedProxyUrl = normalizeUrl(proxyUrl)\n    return (parameters) =>\n      `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`https://${host}${path}?${parameters}`)}`\n  }\n\n  return (parameters) => `https://${host}${path}?${parameters}`\n}\n\nfunction buildEndpointHost(initConfiguration: InitConfiguration, endpointType: EndpointType) {\n  const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration\n\n  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n    return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`\n  }\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  const subdomain = site !== INTAKE_SITE_AP1 ? `${ENDPOINTS[endpointType]}.` : ''\n  return `${subdomain}browser-intake-${domainParts.join('-')}.${extension!}`\n}\n\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(\n  { clientToken, internalAnalyticsSubdomain }: InitConfiguration,\n  endpointType: EndpointType,\n  configurationTags: string[],\n  api: 'xhr' | 'fetch' | 'beacon',\n  flushReason: FlushReason | undefined,\n  retry: RetryInfo | undefined\n) {\n  const tags = [`sdk_version:${__BUILD_ENV__SDK_VERSION__}`, `api:${api}`].concat(configurationTags)\n  if (flushReason && isExperimentalFeatureEnabled(ExperimentalFeature.COLLECT_FLUSH_REASON)) {\n    tags.push(`flush_reason:${flushReason}`)\n  }\n  if (retry) {\n    tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`)\n  }\n  const parameters = [\n    'ddsource=browser',\n    `ddtags=${encodeURIComponent(tags.join(','))}`,\n    `dd-api-key=${clientToken}`,\n    `dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}`,\n    'dd-evp-origin=browser',\n    `dd-request-id=${generateUUID()}`,\n  ]\n\n  if (endpointType === 'rum') {\n    parameters.push(`batch_time=${timeStampNow()}`)\n  }\n  if (internalAnalyticsSubdomain) {\n    parameters.reverse()\n  }\n\n  return parameters.join('&')\n}\n","import { display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(`${key} value doesn't meet tag requirements and will be sanitized`)\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { objectValues, assign } from '../../tools/utils/polyfills'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeUrlPrefixes = objectValues(endpointBuilders).map((builder) => builder.urlPrefix)\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeUrlPrefixes.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site: initConfiguration.site || INTAKE_SITE_US1,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'sessionReplay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeUrlPrefixes: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeUrlPrefixes.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.urlPrefix))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n","import { catchUserErrors } from '../../tools/catchUserErrors'\nimport { display } from '../../tools/display'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport { ExperimentalFeature, addExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Duration } from '../../tools/utils/timeUtils'\nimport { ONE_SECOND } from '../../tools/utils/timeUtils'\nimport { isPercentage } from '../../tools/utils/numberUtils'\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { objectHasValue } from '../../tools/utils/objectUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectSessionStoreStrategyType } from '../session/sessionStore'\nimport type { SessionStoreStrategyType } from '../session/storeStrategies/sessionStoreStrategy'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = (typeof DefaultPrivacyLevel)[keyof typeof DefaultPrivacyLevel]\n\nexport interface InitConfiguration {\n  // global options\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  /**\n   * @deprecated use sessionSampleRate instead\n   */\n  sampleRate?: number | undefined\n  sessionSampleRate?: number | undefined\n  telemetrySampleRate?: number | undefined\n  silentMultipleInit?: boolean | undefined\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n  storeContextsAcrossPages?: boolean | undefined\n\n  // transport options\n  proxy?: string | undefined\n  /**\n   * @deprecated use `proxy` instead\n   */\n  proxyUrl?: string | undefined\n  site?: string | undefined\n\n  // tag and context options\n  service?: string | undefined\n  env?: string | undefined\n  version?: string | undefined\n\n  // cookie options\n  useCrossSiteSessionCookie?: boolean | undefined\n  useSecureSessionCookie?: boolean | undefined\n  trackSessionAcrossSubdomains?: boolean | undefined\n\n  // alternate storage option\n  allowFallbackToLocalStorage?: boolean | undefined\n\n  // internal options\n  enableExperimentalFeatures?: string[] | undefined\n  replica?: ReplicaUserConfiguration | undefined\n  datacenter?: string\n  internalAnalyticsSubdomain?: string\n\n  telemetryConfigurationSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  sessionStoreStrategyType: SessionStoreStrategyType | undefined\n  sessionSampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: Duration\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  const sessionSampleRate = initConfiguration.sessionSampleRate ?? initConfiguration.sampleRate\n  if (sessionSampleRate !== undefined && !isPercentage(sessionSampleRate)) {\n    display.error('Session Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // Set the experimental feature flags as early as possible, so we can use them in most places\n  if (Array.isArray(initConfiguration.enableExperimentalFeatures)) {\n    addExperimentalFeatures(\n      initConfiguration.enableExperimentalFeatures.filter((flag): flag is ExperimentalFeature =>\n        objectHasValue(ExperimentalFeature, flag)\n      )\n    )\n  }\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n      sessionSampleRate: sessionSampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      service: initConfiguration.service,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: (30 * ONE_SECOND) as Duration,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function serializeConfiguration(initConfiguration: InitConfiguration): Partial<RawTelemetryConfiguration> {\n  const proxy = initConfiguration.proxy ?? initConfiguration.proxyUrl\n  return {\n    session_sample_rate: initConfiguration.sessionSampleRate ?? initConfiguration.sampleRate,\n    telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n    use_before_send: !!initConfiguration.beforeSend,\n    use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,\n    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n    use_proxy: proxy !== undefined ? !!proxy : undefined,\n    silent_multiple_init: initConfiguration.silentMultipleInit,\n    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n    track_resources: initConfiguration.trackResources,\n    track_long_task: initConfiguration.trackLongTasks,\n    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n    store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n  }\n}\n","import { startsWith } from '../../tools/utils/polyfills'\nimport type { StackTrace, StackFrame } from './types'\n\nconst UNKNOWN_FUNCTION = '?'\n\n/**\n * Computes a stack trace for an exception.\n */\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n","import type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\nimport { noop } from '../../tools/utils/functionUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { ErrorSource, ErrorHandling, RawError, RawErrorCause, ErrorWithCause, NonErrorPrefix } from './error.types'\n\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error'\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: NonErrorPrefix\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  const isErrorInstance = originalError instanceof Error\n\n  const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError)\n  const stack = hasUsableStack(isErrorInstance, stackTrace)\n    ? toStackTraceString(stackTrace)\n    : NO_ERROR_STACK_PRESENT_MESSAGE\n  const causes = isErrorInstance ? flattenErrorCauses(originalError as ErrorWithCause, source) : undefined\n  const type = stackTrace?.name\n  const fingerprint = tryToGetFingerprint(originalError)\n\n  return {\n    startClocks,\n    source,\n    handling,\n    handlingStack,\n    originalError,\n    type,\n    message,\n    stack,\n    causes,\n    fingerprint,\n  }\n}\n\nfunction computeMessage(\n  stackTrace: StackTrace | undefined,\n  isErrorInstance: boolean,\n  nonErrorPrefix: NonErrorPrefix,\n  originalError: unknown\n) {\n  // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n  // TODO rework tracekit integration to avoid scattering error building logic\n  return stackTrace?.message && stackTrace?.name\n    ? stackTrace.message\n    : !isErrorInstance\n    ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))!}`\n    : 'Empty message'\n}\n\nfunction hasUsableStack(isErrorInstance: boolean, stackTrace?: StackTrace): stackTrace is StackTrace {\n  if (stackTrace === undefined) {\n    return false\n  }\n  if (isErrorInstance) {\n    return true\n  }\n  // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n  // TODO rework tracekit integration to avoid generating those unusable stack\n  return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined)\n}\n\nexport function tryToGetFingerprint(originalError: unknown) {\n  return originalError instanceof Error && 'dd_fingerprint' in originalError\n    ? String(originalError.dd_fingerprint)\n    : undefined\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","import { toStackTraceString } from '../error/error'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport { includes } from '../../tools/utils/polyfills'\nimport { safeTruncate } from '../../tools/utils/stringUtils'\nimport type { Configuration } from '../configuration'\nimport type { ReportType, InterventionReport, DeprecationReport } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = (typeof RawReportType)[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  stack?: string\n}\n\nexport function initReportObservable(configuration: Configuration, apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable(configuration))\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  const observable = new Observable<RawReport>(() => {\n    if (!window.ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Array<DeprecationReport | InterventionReport>, _: ReportingObserver) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    ) as ReportingObserverCallback\n\n    const observer = new window.ReportingObserver(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n\n  return observable\n}\n\nfunction createCspViolationReportObservable(configuration: Configuration) {\n  const observable = new Observable<RawReport>(() => {\n    const { stop } = addEventListener(configuration, document, DOM_EVENT.SECURITY_POLICY_VIOLATION, (event) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    return stop\n  })\n  return observable\n}\n\nfunction buildRawReportFromReport({ type, body }: DeprecationReport | InterventionReport): RawReport {\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | null,\n  lineNumber: number | null,\n  columnNumber: number | null\n): string | undefined {\n  return sourceFile\n    ? toStackTraceString({\n        name,\n        message,\n        stack: [\n          {\n            func: '?',\n            url: sourceFile,\n            line: lineNumber ?? undefined,\n            column: columnNumber ?? undefined,\n          },\n        ],\n      })\n    : undefined\n}\n","import type { Configuration, InitConfiguration, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  serializeConfiguration,\n  assign,\n  ONE_KIBI_BYTE,\n  validateAndBuildConfiguration,\n  display,\n  removeDuplicates,\n  ConsoleApiName,\n  RawReportType,\n  includes,\n  objectValues,\n} from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport interface LogsInitConfiguration extends InitConfiguration {\n  beforeSend?: ((event: LogsEvent) => void | boolean) | undefined\n  forwardErrorsToLogs?: boolean | undefined\n  forwardConsoleLogs?: ConsoleApiName[] | 'all' | undefined\n  forwardReports?: RawReportType[] | 'all' | undefined\n}\n\nexport type HybridInitConfiguration = Omit<LogsInitConfiguration, 'clientToken'>\n\nexport interface LogsConfiguration extends Configuration {\n  forwardErrorsToLogs: boolean\n  forwardConsoleLogs: ConsoleApiName[]\n  forwardReports: RawReportType[]\n  requestErrorResponseLengthLimit: number\n}\n\n/**\n * arbitrary value, byte precision not needed\n */\nexport const DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * ONE_KIBI_BYTE\n\nexport function validateAndBuildLogsConfiguration(\n  initConfiguration: LogsInitConfiguration\n): LogsConfiguration | undefined {\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n\n  const forwardConsoleLogs = validateAndBuildForwardOption<ConsoleApiName>(\n    initConfiguration.forwardConsoleLogs,\n    objectValues(ConsoleApiName),\n    'Forward Console Logs'\n  )\n\n  const forwardReports = validateAndBuildForwardOption<RawReportType>(\n    initConfiguration.forwardReports,\n    objectValues(RawReportType),\n    'Forward Reports'\n  )\n\n  if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {\n    return\n  }\n\n  if (initConfiguration.forwardErrorsToLogs && !includes(forwardConsoleLogs, ConsoleApiName.error)) {\n    forwardConsoleLogs.push(ConsoleApiName.error)\n  }\n\n  return assign(\n    {\n      forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,\n      forwardConsoleLogs,\n      forwardReports,\n      requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT,\n    },\n    baseConfiguration\n  )\n}\n\nexport function validateAndBuildForwardOption<T>(\n  option: readonly T[] | 'all' | undefined,\n  allowedValues: T[],\n  label: string\n): T[] | undefined {\n  if (option === undefined) {\n    return []\n  }\n\n  if (!(option === 'all' || (Array.isArray(option) && option.every((api) => includes(allowedValues, api))))) {\n    display.error(`${label} should be \"all\" or an array with allowed values \"${allowedValues.join('\", \"')}\"`)\n    return\n  }\n\n  return option === 'all' ? allowedValues : removeDuplicates<T>(option)\n}\n\nexport function serializeLogsConfiguration(configuration: LogsInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedInitConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      forward_errors_to_logs: configuration.forwardErrorsToLogs,\n      forward_console_logs: configuration.forwardConsoleLogs,\n      forward_reports: configuration.forwardReports,\n    },\n    baseSerializedInitConfiguration\n  )\n}\n","import { arrayFrom } from './polyfills'\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n","import type { ClocksState } from '../../tools/utils/timeUtils'\n\nexport interface ErrorWithCause extends Error {\n  cause?: Error\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n  fingerprint?: string\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum NonErrorPrefix {\n  UNCAUGHT = 'Uncaught',\n  PROVIDED = 'Provided',\n}\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = (typeof ErrorSource)[keyof typeof ErrorSource]\n","import type { Context } from '@datadog/browser-core'\nimport {\n  clocksNow,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  CustomerDataType,\n  assign,\n  combine,\n  createContextManager,\n  ErrorSource,\n  monitored,\n  sanitize,\n  NonErrorPrefix,\n} from '@datadog/browser-core'\n\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport interface LogsMessage {\n  message: string\n  status: StatusType\n  context?: Context\n}\n\nexport const StatusType = {\n  debug: 'debug',\n  error: 'error',\n  info: 'info',\n  warn: 'warn',\n} as const\n\nexport type StatusType = (typeof StatusType)[keyof typeof StatusType]\n\nexport const HandlerType = {\n  console: 'console',\n  http: 'http',\n  silent: 'silent',\n} as const\n\nexport type HandlerType = (typeof HandlerType)[keyof typeof HandlerType]\nexport const STATUSES = Object.keys(StatusType) as StatusType[]\n\nexport class Logger {\n  private contextManager = createContextManager(CustomerDataType.LoggerContext)\n\n  constructor(\n    private handleLogStrategy: (logsMessage: LogsMessage, logger: Logger) => void,\n    name?: string,\n    private handlerType: HandlerType | HandlerType[] = HandlerType.http,\n    private level: StatusType = StatusType.debug,\n    loggerContext: object = {}\n  ) {\n    this.contextManager.set(assign({}, loggerContext, name ? { logger: { name } } : undefined))\n  }\n\n  @monitored\n  log(message: string, messageContext?: object, status: StatusType = StatusType.info, error?: Error) {\n    let errorContext: LogsEvent['error']\n\n    if (status === StatusType.error) {\n      // Always add origin if status is error (backward compatibility - Remove in next major)\n      errorContext = { origin: ErrorSource.LOGGER }\n    }\n\n    if (error !== undefined && error !== null) {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.LOGGER,\n        handling: ErrorHandling.HANDLED,\n        startClocks: clocksNow(),\n      })\n\n      errorContext = {\n        origin: ErrorSource.LOGGER, // Remove in next major\n        stack: rawError.stack,\n        kind: rawError.type,\n        message: rawError.message,\n      }\n    }\n\n    const sanitizedMessageContext = sanitize(messageContext) as Context\n\n    const context = errorContext\n      ? (combine({ error: errorContext }, sanitizedMessageContext) as Context)\n      : sanitizedMessageContext\n\n    this.handleLogStrategy(\n      {\n        message: sanitize(message)!,\n        context,\n        status,\n      },\n      this\n    )\n  }\n\n  debug(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.debug, error)\n  }\n\n  info(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.info, error)\n  }\n\n  warn(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.warn, error)\n  }\n\n  error(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.error, error)\n  }\n\n  setContext(context: object) {\n    this.contextManager.set(context)\n  }\n\n  getContext() {\n    return this.contextManager.get()\n  }\n\n  addContext(key: string, value: any) {\n    this.contextManager.add(key, value)\n  }\n\n  removeContext(key: string) {\n    this.contextManager.remove(key)\n  }\n\n  setHandler(handler: HandlerType | HandlerType[]) {\n    this.handlerType = handler\n  }\n\n  getHandler() {\n    return this.handlerType\n  }\n\n  setLevel(level: StatusType) {\n    this.level = level\n  }\n\n  getLevel() {\n    return this.level\n  }\n}\n","import type { Context, InitConfiguration, User } from '@datadog/browser-core'\nimport {\n  CustomerDataType,\n  assign,\n  BoundedBuffer,\n  createContextManager,\n  makePublicApi,\n  monitor,\n  display,\n  deepClone,\n  canUseEventBridge,\n  timeStampNow,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n  createStoredContextManager,\n  combine,\n} from '@datadog/browser-core'\nimport type { LogsInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildLogsConfiguration } from '../domain/configuration'\nimport type { HandlerType, StatusType, LogsMessage } from '../domain/logger'\nimport { Logger } from '../domain/logger'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { startLogs } from './startLogs'\n\nexport interface LoggerConfiguration {\n  level?: StatusType\n  handler?: HandlerType | HandlerType[]\n  context?: object\n}\n\nexport type LogsPublicApi = ReturnType<typeof makeLogsPublicApi>\n\nexport type StartLogs = typeof startLogs\n\ntype StartLogsResult = ReturnType<typeof startLogs>\n\nconst LOGS_STORAGE_KEY = 'logs'\n\nexport function makeLogsPublicApi(startLogsImpl: StartLogs) {\n  let isAlreadyInitialized = false\n\n  let globalContextManager = createContextManager(CustomerDataType.GlobalContext)\n  let userContextManager = createContextManager(CustomerDataType.User)\n\n  const customLoggers: { [name: string]: Logger | undefined } = {}\n  let getInternalContextStrategy: StartLogsResult['getInternalContext'] = () => undefined\n\n  const beforeInitLoggerLog = new BoundedBuffer()\n\n  let handleLogStrategy: StartLogsResult['handleLog'] = (\n    logsMessage: LogsMessage,\n    logger: Logger,\n    savedCommonContext = deepClone(buildCommonContext()),\n    date = timeStampNow()\n  ) => {\n    beforeInitLoggerLog.add(() => handleLogStrategy(logsMessage, logger, savedCommonContext, date))\n  }\n\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n  const mainLogger = new Logger((...params) => handleLogStrategy(...params))\n\n  function buildCommonContext(): CommonContext {\n    return {\n      view: {\n        referrer: document.referrer,\n        url: window.location.href,\n      },\n      context: globalContextManager.getContext(),\n      user: userContextManager.getContext(),\n    }\n  }\n\n  return makePublicApi({\n    logger: mainLogger,\n\n    init: monitor((initConfiguration: LogsInitConfiguration) => {\n      if (!initConfiguration) {\n        display.error('Missing configuration')\n        return\n      }\n      // This function should be available, regardless of initialization success.\n      getInitConfigurationStrategy = () => deepClone(initConfiguration)\n\n      if (canUseEventBridge()) {\n        initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n      }\n\n      if (!canInitLogs(initConfiguration)) {\n        return\n      }\n\n      const configuration = validateAndBuildLogsConfiguration(initConfiguration)\n      if (!configuration) {\n        return\n      }\n\n      if (initConfiguration.storeContextsAcrossPages) {\n        const beforeInitGlobalContext = globalContextManager.getContext()\n        globalContextManager = createStoredContextManager(\n          configuration,\n          LOGS_STORAGE_KEY,\n          CustomerDataType.GlobalContext\n        )\n        globalContextManager.setContext(combine(globalContextManager.getContext(), beforeInitGlobalContext))\n\n        const beforeInitUserContext = userContextManager.getContext()\n        userContextManager = createStoredContextManager(configuration, LOGS_STORAGE_KEY, CustomerDataType.User)\n        userContextManager.setContext(combine(userContextManager.getContext(), beforeInitUserContext))\n      }\n\n      ;({ handleLog: handleLogStrategy, getInternalContext: getInternalContextStrategy } = startLogsImpl(\n        initConfiguration,\n        configuration,\n        buildCommonContext,\n        mainLogger\n      ))\n\n      beforeInitLoggerLog.drain()\n\n      isAlreadyInitialized = true\n    }),\n\n    /** @deprecated: use getGlobalContext instead */\n    getLoggerGlobalContext: monitor(() => globalContextManager.get()),\n    getGlobalContext: monitor(() => globalContextManager.getContext()),\n\n    /** @deprecated: use setGlobalContext instead */\n    setLoggerGlobalContext: monitor((context) => globalContextManager.set(context)),\n    setGlobalContext: monitor((context) => globalContextManager.setContext(context)),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addLoggerGlobalContext: monitor((key, value) => globalContextManager.add(key, value)),\n    setGlobalContextProperty: monitor((key, value) => globalContextManager.setContextProperty(key, value)),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeLoggerGlobalContext: monitor((key) => globalContextManager.remove(key)),\n    removeGlobalContextProperty: monitor((key) => globalContextManager.removeContextProperty(key)),\n\n    clearGlobalContext: monitor(() => globalContextManager.clearContext()),\n\n    createLogger: monitor((name: string, conf: LoggerConfiguration = {}) => {\n      customLoggers[name] = new Logger(\n        (...params) => handleLogStrategy(...params),\n        sanitize(name),\n        conf.handler,\n        conf.level,\n        sanitize(conf.context) as object\n      )\n\n      return customLoggers[name]!\n    }),\n\n    getLogger: monitor((name: string) => customLoggers[name]),\n\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    getInternalContext: monitor((startTime?: number | undefined) => getInternalContextStrategy(startTime)),\n\n    setUser: monitor((newUser: User) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(() => userContextManager.getContext()),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor((key) => userContextManager.removeContextProperty(key)),\n\n    clearUser: monitor(() => userContextManager.clearContext()),\n  })\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, { clientToken: 'empty' })\n  }\n\n  function canInitLogs(initConfiguration: LogsInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_LOGS is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n}\n","interface BrowserWindow {\n  __ddBrowserSdkExtensionCallback?: (message: unknown) => void\n}\n\ntype ExtensionMessageType = 'logs' | 'record' | 'rum' | 'telemetry'\n\nexport function sendToExtension(type: ExtensionMessageType, payload: unknown) {\n  const callback = (window as BrowserWindow).__ddBrowserSdkExtensionCallback\n  if (callback) {\n    callback({ type, payload })\n  }\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport interface RuntimeEnvInfo {\n  is_local_file: boolean\n  is_worker: boolean\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\n","import type { Context } from '../../tools/serialisation/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { toStackTraceString, NO_ERROR_STACK_PRESENT_MESSAGE } from '../error/error'\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Configuration } from '../configuration'\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport { sendToExtension } from '../../tools/sendToExtension'\nimport { startsWith, arrayFrom, includes, assign } from '../../tools/utils/polyfills'\nimport { performDraw } from '../../tools/utils/numberUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { combine } from '../../tools/mergeInto'\nimport { NonErrorPrefix } from '../error/error.types'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type { RawTelemetryConfiguration, RawTelemetryEvent, RuntimeEnvInfo } from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'https://d3uc069fcn7uxw.cloudfront.net',\n  'https://d20xtzwzcl0ceb.cloudfront.net',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n  enabled: boolean\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\nconst telemetryConfiguration: {\n  maxEventsPerPage: number\n  sentEventCount: number\n  telemetryEnabled: boolean\n  telemetryConfigurationEnabled: boolean\n} = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false }\n\nlet onRawTelemetryEventCollected: ((event: RawTelemetryEvent) => void) | undefined\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  telemetryConfiguration.telemetryEnabled =\n    !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate)\n  telemetryConfiguration.telemetryConfigurationEnabled =\n    telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate)\n\n  const runtimeEnvInfo = getRuntimeEnvInfo()\n  onRawTelemetryEventCollected = (rawEvent: RawTelemetryEvent) => {\n    if (telemetryConfiguration.telemetryEnabled) {\n      const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo)\n      observable.notify(event)\n      sendToExtension('telemetry', event)\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,\n    sentEventCount: 0,\n  })\n\n  function toTelemetryEvent(\n    telemetryService: TelemetryService,\n    event: RawTelemetryEvent,\n    runtimeEnvInfo: RuntimeEnvInfo\n  ): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: combine(event, {\n          runtime_env: runtimeEnvInfo,\n        }),\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    ) as TelemetryEvent & Context\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n    enabled: telemetryConfiguration.telemetryEnabled,\n  }\n}\nfunction getRuntimeEnvInfo(): RuntimeEnvInfo {\n  return {\n    is_local_file: window.location.protocol === 'file:',\n    is_worker: 'WorkerGlobalScope' in self,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: Infinity,\n    sentEventCount: 0,\n  })\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  onRawTelemetryEventCollected = undefined\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown, context?: Context) {\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e),\n      context\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  if (telemetryConfiguration.telemetryConfigurationEnabled) {\n    addTelemetry({\n      type: TelemetryType.configuration,\n      configuration,\n    })\n  }\n}\n\nfunction addTelemetry(event: RawTelemetryEvent) {\n  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {\n    telemetryConfiguration.sentEventCount += 1\n    onRawTelemetryEventCollected(event)\n  }\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n    },\n    message: `${NonErrorPrefix.UNCAUGHT} ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures'\nimport { Observable } from '../tools/observable'\nimport { objectValues, includes } from '../tools/utils/polyfills'\nimport { noop } from '../tools/utils/functionUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageExitObservable(configuration: Configuration): Observable<PageExitEvent> {\n  const observable = new Observable<PageExitEvent>(() => {\n    const pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE)\n    const { stop: stopListeners } = addEventListeners(\n      configuration,\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE, DOM_EVENT.PAGE_HIDE],\n      (event) => {\n        if (event.type === DOM_EVENT.PAGE_HIDE && pagehideEnabled) {\n          /**\n           * Only event that detect page unload events while being compatible with the back/forward cache (bfcache)\n           */\n          observable.notify({ reason: PageExitReason.PAGEHIDE })\n        } else if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    let stopBeforeUnloadListener = noop\n    if (!pagehideEnabled) {\n      stopBeforeUnloadListener = addEventListener(configuration, window, DOM_EVENT.BEFORE_UNLOAD, () => {\n        observable.notify({ reason: PageExitReason.UNLOADING })\n      }).stop\n    }\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n\n  return observable\n}\n\nexport function isPageExitReason(reason: string | undefined): reason is PageExitReason {\n  return includes(objectValues(PageExitReason), reason)\n}\n","import { getCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","import { display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageExitObservable'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { Subscription } from '../tools/observable'\nimport type { HttpRequest } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport class Batch {\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n  private flushSubscription: Subscription\n\n  constructor(\n    private request: HttpRequest,\n    public flushController: FlushController,\n    private messageBytesLimit: number\n  ) {\n    this.flushSubscription = this.flushController.flushObservable.subscribe((event) => this.flush(event))\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  stop() {\n    this.flushSubscription.unsubscribe()\n  }\n\n  private flush(event: FlushEvent) {\n    const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n\n    this.pushOnlyBuffer = []\n    this.upsertBuffer = {}\n\n    const payload = { data: messages.join('\\n'), bytesCount: event.bytesCount, flushReason: event.reason }\n    if (isPageExitReason(event.reason)) {\n      this.request.sendOnExit(payload)\n    } else {\n      this.request.send(payload)\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    // If there are other messages, a '\\n' will be added at serialization\n    const separatorBytesCount = this.flushController.messagesCount > 0 ? 1 : 0\n\n    this.flushController.notifyBeforeAddMessage(messageBytesCount + separatorBytesCount)\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.flushController.notifyAfterAddMessage()\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = computeBytesCount(removedMessage)\n    // If there are other messages, a '\\n' will be added at serialization\n    const separatorBytesCount = this.flushController.messagesCount > 1 ? 1 : 0\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount + separatorBytesCount)\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n}\n","export function isServerError(status: number) {\n  return status >= 500\n}\n\nexport function tryToClone(response: Response): Response | undefined {\n  try {\n    return response.clone()\n  } catch (e) {\n    // clone can throw if the response has already been used by another instrumentation or is disturbed\n    return\n  }\n}\n","import type { EndpointType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder, Configuration } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor } from '../tools/monitor'\nimport { addEventListener } from '../browser/addEventListener'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\nimport type { FlushReason } from './flushController'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData\n  bytesCount: number\n  retry?: RetryInfo\n  flushReason?: FlushReason\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(configuration, endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(configuration, endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount, flushReason }: Payload\n) {\n  const canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', flushReason)\n      const isQueued = navigator.sendBeacon(beaconUrl, data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  const xhrUrl = endpointBuilder.build('xhr', flushReason)\n  sendXHR(configuration, xhrUrl, data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  configuration: Configuration,\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount, flushReason, retry }: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch', flushReason, retry)\n    fetch(fetchUrl, { method: 'POST', body: data, keepalive: true, mode: 'cors' }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })),\n      monitor(() => {\n        const xhrUrl = endpointBuilder.build('xhr', flushReason, retry)\n        // failed to queue the request\n        sendXHR(configuration, xhrUrl, data, onResponse)\n      })\n    )\n  } else {\n    const xhrUrl = endpointBuilder.build('xhr', flushReason, retry)\n    sendXHR(configuration, xhrUrl, data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(\n  configuration: Configuration,\n  url: string,\n  data: Payload['data'],\n  onResponse?: (r: HttpResponse) => void\n) {\n  const request = new XMLHttpRequest()\n  request.open('POST', url, true)\n  addEventListener(\n    configuration,\n    request,\n    'loadend',\n    () => {\n      onResponse?.({ status: request.status })\n    },\n    {\n      // prevent multiple onResponse callbacks\n      // if the xhr instance is reused by a third party\n      once: true,\n    }\n  )\n  request.send(data)\n}\n","import type { PageExitEvent, PageExitReason } from '../browser/pageExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageExitObservable: Observable<PageExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const pageExitSubscription = pageExitObservable.subscribe((event) => flush(event.reason))\n  const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  const flushObservable = new Observable<FlushEvent>(() => () => {\n    pageExitSubscription.unsubscribe()\n    sessionExpireSubscription.unsubscribe()\n  })\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     */\n    notifyBeforeAddMessage(messageBytesCount: number) {\n      if (currentBytesCount + messageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += messageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     */\n    notifyAfterAddMessage() {\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n","import type { Configuration, EndpointBuilder } from '../domain/configuration'\nimport type { Context } from '../tools/serialisation/context'\nimport type { Observable } from '../tools/observable'\nimport type { PageExitEvent } from '../browser/pageExitObservable'\nimport type { RawError } from '../domain/error/error.types'\nimport { Batch } from './batch'\nimport { createHttpRequest } from './httpRequest'\nimport { createFlushController } from './flushController'\n\nexport function startBatchWithReplica<T extends Context>(\n  configuration: Configuration,\n  primary: { endpoint: EndpointBuilder },\n  replica: { endpoint: EndpointBuilder; transformMessage?: (message: T) => T } | undefined,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const primaryBatch = createBatch(configuration, primary.endpoint)\n  const replicaBatch = replica && createBatch(configuration, replica.endpoint)\n\n  function createBatch(configuration: Configuration, endpointBuilder: EndpointBuilder) {\n    return new Batch(\n      createHttpRequest(configuration, endpointBuilder, configuration.batchBytesLimit, reportError),\n      createFlushController({\n        messagesLimit: configuration.batchMessagesLimit,\n        bytesLimit: configuration.batchBytesLimit,\n        durationLimit: configuration.flushTimeout,\n        pageExitObservable,\n        sessionExpireObservable,\n      }),\n      configuration.messageBytesLimit\n    )\n  }\n\n  return {\n    flushObservable: primaryBatch.flushController.flushObservable,\n\n    add(message: T, replicated = true) {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message)\n      }\n    },\n\n    upsert: (message: T, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key)\n      }\n    },\n\n    stop: () => {\n      primaryBatch.stop()\n      replicaBatch?.stop()\n    },\n  }\n}\n","import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ValueHistory<Value> {\n  private entries: Array<ValueHistoryEntry<Value>> = []\n  private clearOldValuesInterval: TimeoutId\n\n  constructor(\n    private expireDelay: number,\n    private maxEntries?: number\n  ) {\n    this.clearOldValuesInterval = setInterval(() => this.clearOldValues(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop()\n    }\n\n    this.entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Value | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return this.entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldValuesInterval)\n  }\n\n  private clearOldValues() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import type { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { ValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport type { Configuration } from '../configuration'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  configuration: Configuration,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionManager<TrackingType> {\n  // TODO - Improve configuration type and remove assertion\n  const sessionStore = startSessionStore(configuration.sessionStoreStrategyType!, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ValueHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackActivity(configuration, () => sessionStore.expandOrRenewSession())\n  trackVisibility(configuration, () => sessionStore.expandSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable: sessionStore.renewObservable,\n    expireObservable: sessionStore.expireObservable,\n    expire: sessionStore.expire,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(configuration: Configuration, expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    configuration,\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(configuration: Configuration, expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(configuration, document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { Observable, performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { LogsConfiguration } from './configuration'\n\nexport const LOGS_SESSION_KEY = 'logs'\n\nexport interface LogsSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => LogsSession | undefined\n  expireObservable: Observable<void>\n}\n\nexport type LogsSession = {\n  id?: string // session can be tracked without id\n}\n\nexport const enum LoggerTrackingType {\n  NOT_TRACKED = '0',\n  TRACKED = '1',\n}\n\nexport function startLogsSessionManager(configuration: LogsConfiguration): LogsSessionManager {\n  const sessionManager = startSessionManager(configuration, LOGS_SESSION_KEY, (rawTrackingType) =>\n    computeSessionState(configuration, rawTrackingType)\n  )\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      return session && session.trackingType === LoggerTrackingType.TRACKED\n        ? {\n            id: session.id,\n          }\n        : undefined\n    },\n    expireObservable: sessionManager.expireObservable,\n  }\n}\n\nexport function startLogsSessionManagerStub(configuration: LogsConfiguration): LogsSessionManager {\n  const isTracked = computeTrackingType(configuration) === LoggerTrackingType.TRACKED\n  const session = isTracked ? {} : undefined\n  return {\n    findTrackedSession: () => session,\n    expireObservable: new Observable(),\n  }\n}\n\nfunction computeTrackingType(configuration: LogsConfiguration) {\n  if (!performDraw(configuration.sessionSampleRate)) {\n    return LoggerTrackingType.NOT_TRACKED\n  }\n  return LoggerTrackingType.TRACKED\n}\n\nfunction computeSessionState(configuration: LogsConfiguration, rawSessionType?: string) {\n  const trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration)\n  return {\n    trackingType,\n    isTracked: trackingType === LoggerTrackingType.TRACKED,\n  }\n}\n\nfunction hasValidLoggerSession(trackingType?: string): trackingType is LoggerTrackingType {\n  return trackingType === LoggerTrackingType.NOT_TRACKED || trackingType === LoggerTrackingType.TRACKED\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { includes, display, combine, ErrorSource, timeStampNow } from '@datadog/browser-core'\nimport type { CommonContext } from '../../rawLogsEvent.types'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { Logger, LogsMessage } from '../logger'\nimport { StatusType, HandlerType } from '../logger'\n\nexport const STATUS_PRIORITIES: { [key in StatusType]: number } = {\n  [StatusType.debug]: 0,\n  [StatusType.info]: 1,\n  [StatusType.warn]: 2,\n  [StatusType.error]: 3,\n}\n\nexport function startLoggerCollection(lifeCycle: LifeCycle) {\n  function handleLog(\n    logsMessage: LogsMessage,\n    logger: Logger,\n    savedCommonContext?: CommonContext,\n    savedDate?: TimeStamp\n  ) {\n    const messageContext = logsMessage.context\n\n    if (isAuthorized(logsMessage.status, HandlerType.console, logger)) {\n      display(logsMessage.status, logsMessage.message, combine(logger.getContext(), messageContext))\n    }\n\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: savedDate || timeStampNow(),\n        message: logsMessage.message,\n        status: logsMessage.status,\n        origin: ErrorSource.LOGGER,\n      },\n      messageContext,\n      savedCommonContext,\n      logger,\n    })\n  }\n\n  return {\n    handleLog,\n  }\n}\n\nexport function isAuthorized(status: StatusType, handlerType: HandlerType, logger: Logger) {\n  const loggerHandler = logger.getHandler()\n  const sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [loggerHandler]\n  return (\n    STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && includes(sanitizedHandlerType, handlerType)\n  )\n}\n","import type { Context, EventRateLimiter, RawError, RelativeTime } from '@datadog/browser-core'\nimport {\n  getSyntheticsResultId,\n  getSyntheticsTestId,\n  addTelemetryDebug,\n  willSyntheticsInjectRum,\n  ErrorSource,\n  combine,\n  createEventRateLimiter,\n  getRelativeTime,\n  isEmptyObject,\n} from '@datadog/browser-core'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { LogsConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { Logger } from './logger'\nimport { STATUSES, HandlerType } from './logger'\nimport { isAuthorized } from './logger/loggerCollection'\nimport type { LogsSessionManager } from './logsSessionManager'\n\nexport function startLogsAssembly(\n  sessionManager: LogsSessionManager,\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  buildCommonContext: () => CommonContext,\n  mainLogger: Logger, // Todo: [RUMF-1230] Remove this parameter in the next major release\n  reportError: (error: RawError) => void\n) {\n  const statusWithCustom = (STATUSES as string[]).concat(['custom'])\n  const logRateLimiters: { [key: string]: EventRateLimiter } = {}\n  statusWithCustom.forEach((status) => {\n    logRateLimiters[status] = createEventRateLimiter(status, configuration.eventRateLimiterThreshold, reportError)\n  })\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_LOG_COLLECTED,\n    ({ rawLogsEvent, messageContext = undefined, savedCommonContext = undefined, logger = mainLogger }) => {\n      const startTime = getRelativeTime(rawLogsEvent.date)\n      const session = sessionManager.findTrackedSession(startTime)\n\n      if (!session) {\n        return\n      }\n\n      const commonContext = savedCommonContext || buildCommonContext()\n      const log = combine(\n        {\n          service: configuration.service,\n          session_id: session.id,\n          // Insert user first to allow overrides from global context\n          usr: !isEmptyObject(commonContext.user) ? commonContext.user : undefined,\n          view: commonContext.view,\n        },\n        commonContext.context,\n        getRUMInternalContext(startTime),\n        rawLogsEvent,\n        logger.getContext(),\n        messageContext\n      )\n\n      if (\n        // Todo: [RUMF-1230] Move this check to the logger collection in the next major release\n        !isAuthorized(rawLogsEvent.status, HandlerType.http, logger) ||\n        configuration.beforeSend?.(log) === false ||\n        (log.error?.origin !== ErrorSource.AGENT &&\n          (logRateLimiters[log.status] ?? logRateLimiters['custom']).isLimitReached())\n      ) {\n        return\n      }\n\n      lifeCycle.notify(LifeCycleEventType.LOG_COLLECTED, log)\n    }\n  )\n}\n\ninterface Rum {\n  getInternalContext?: (startTime?: RelativeTime) => Context | undefined\n}\n\ninterface BrowserWindow {\n  DD_RUM?: Rum\n  DD_RUM_SYNTHETICS?: Rum\n}\n\nlet logsSentBeforeRumInjectionTelemetryAdded = false\n\nexport function getRUMInternalContext(startTime?: RelativeTime): Context | undefined {\n  const browserWindow = window as BrowserWindow\n\n  if (willSyntheticsInjectRum()) {\n    const context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS)\n    if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {\n      logsSentBeforeRumInjectionTelemetryAdded = true\n      addTelemetryDebug('Logs sent before RUM is injected by the synthetics worker', {\n        testId: getSyntheticsTestId(),\n        resultId: getSyntheticsResultId(),\n      })\n    }\n    return context\n  }\n\n  return getInternalContextFromRumGlobal(browserWindow.DD_RUM)\n\n  function getInternalContextFromRumGlobal(rumGlobal?: Rum): Context | undefined {\n    if (rumGlobal && rumGlobal.getInternalContext) {\n      return rumGlobal.getInternalContext(startTime)\n    }\n  }\n}\n\nexport function resetRUMInternalContext() {\n  logsSentBeforeRumInjectionTelemetryAdded = false\n}\n","import { setTimeout } from '../../tools/timer'\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport type { RawError } from '../error/error.types'\nimport { ErrorSource } from '../error/error.types'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import { computeStackTrace } from '../tracekit'\nimport { createHandlingStack, formatErrorMessage, toStackTraceString, tryToGetFingerprint } from '../error/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { ConsoleApiName, globalConsole } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport { find } from '../../tools/utils/polyfills'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack?: string\n  fingerprint?: string\n}\n\nlet consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]!\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\nexport function resetConsoleObservable() {\n  consoleObservablesByApi = {}\n}\n\nfunction createConsoleObservable(api: ConsoleApiName) {\n  const observable = new Observable<ConsoleLog>(() => {\n    const originalConsoleApi = globalConsole[api]\n\n    globalConsole[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      globalConsole[api] = originalConsoleApi\n    }\n  })\n\n  return observable\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  // Todo: remove console error prefix in the next major version\n  let message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n  let fingerprint\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    fingerprint = tryToGetFingerprint(firstErrorParam)\n    message = `console error: ${message}`\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n    fingerprint,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return sanitize(param)\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(sanitize(param), undefined, 2)\n}\n","import type { Context, ClocksState, ConsoleLog } from '@datadog/browser-core'\nimport { timeStampNow, ConsoleApiName, ErrorSource, initConsoleObservable } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForApi = {\n  [ConsoleApiName.log]: StatusType.info,\n  [ConsoleApiName.debug]: StatusType.debug,\n  [ConsoleApiName.info]: StatusType.info,\n  [ConsoleApiName.warn]: StatusType.warn,\n  [ConsoleApiName.error]: StatusType.error,\n}\nexport function startConsoleCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const consoleSubscription = initConsoleObservable(configuration.forwardConsoleLogs).subscribe((log: ConsoleLog) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: timeStampNow(),\n        message: log.message,\n        origin: ErrorSource.CONSOLE,\n        error:\n          log.api === ConsoleApiName.error\n            ? {\n                origin: ErrorSource.CONSOLE, // Todo: Remove in the next major release\n                stack: log.stack,\n                fingerprint: log.fingerprint,\n              }\n            : undefined,\n        status: LogStatusForApi[log.api],\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      consoleSubscription.unsubscribe()\n    },\n  }\n}\n","import type { Context, ClocksState, RawReport } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  ErrorSource,\n  RawReportType,\n  getFileFromStackTraceString,\n  initReportObservable,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForReport = {\n  [RawReportType.cspViolation]: StatusType.error,\n  [RawReportType.intervention]: StatusType.error,\n  [RawReportType.deprecation]: StatusType.warn,\n}\n\nexport function startReportCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const reportSubscription = initReportObservable(configuration, configuration.forwardReports).subscribe(\n    (report: RawReport) => {\n      let message = report.message\n      const status = LogStatusForReport[report.type]\n      let error\n      if (status === StatusType.error) {\n        error = {\n          kind: report.subtype,\n          origin: ErrorSource.REPORT, // Todo: Remove in the next major release\n          stack: report.stack,\n        }\n      } else if (report.stack) {\n        message += ` Found in ${getFileFromStackTraceString(report.stack)!}`\n      }\n\n      lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n        rawLogsEvent: {\n          date: timeStampNow(),\n          message,\n          origin: ErrorSource.REPORT,\n          error,\n          status,\n        },\n      })\n    }\n  )\n\n  return {\n    stop: () => {\n      reportSubscription.unsubscribe()\n    },\n  }\n}\n","import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/utils/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\nimport { shallowClone } from '../tools/utils/objectUtils'\nimport type { Configuration } from '../domain/configuration'\nimport { addEventListener } from './addEventListener'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable(configuration: Configuration) {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable(configuration)\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable(configuration: Configuration) {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, configuration, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, configuration: Configuration, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = () => {\n    unsubscribeLoadEndListener()\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  }\n\n  const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, this, 'loadend', onEnd)\n\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\n\nexport function instrumentMethod<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  instrumentationFactory: (\n    original: OBJECT[METHOD]\n  ) => (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => ReturnType<OBJECT[METHOD]>\n) {\n  const original = object[method]\n\n  let instrumentation = instrumentationFactory(original)\n\n  const instrumentationWrapper = function (this: OBJECT): ReturnType<OBJECT[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return instrumentation.apply(this, arguments as unknown as Parameters<OBJECT[METHOD]>)\n  }\n  object[method] = instrumentationWrapper as OBJECT[METHOD]\n\n  return {\n    stop: () => {\n      if (object[method] === instrumentationWrapper) {\n        object[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nexport function instrumentMethodAndCallOriginal<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  {\n    before,\n    after,\n  }: {\n    before?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n    after?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n  }\n) {\n  return instrumentMethod(\n    object,\n    method,\n    (original) =>\n      function () {\n        const args = arguments as unknown as Parameters<OBJECT[METHOD]>\n        let result\n\n        if (before) {\n          callMonitored(before, this, args)\n        }\n\n        if (typeof original === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          result = original.apply(this, args)\n        }\n\n        if (after) {\n          callMonitored(after, this, args)\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result\n      }\n  )\n}\n\nexport function instrumentSetter<OBJECT extends { [key: string]: any }, PROPERTY extends keyof OBJECT>(\n  object: OBJECT,\n  property: PROPERTY,\n  after: (thisObject: OBJECT, value: OBJECT[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(object, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  let instrumentation = (thisObject: OBJECT, value: OBJECT[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      after(thisObject, value)\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: OBJECT, value: OBJECT[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(object, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(object, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(object, property, originalDescriptor)\n      } else {\n        instrumentation = noop\n      }\n    },\n  }\n}\n","import { instrumentMethod } from '../tools/instrumentMethod'\nimport { callMonitored, monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { ClocksState } from '../tools/utils/timeUtils'\nimport { clocksNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: unknown\n  init?: RequestInit\n  url: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchResolveContext extends FetchContextBase {\n  state: 'resolve'\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchResolveContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  const observable = new Observable<FetchContext>(() => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(\n      window,\n      'fetch',\n      (originalFetch) =>\n        function (input, init) {\n          let responsePromise: Promise<Response>\n\n          const context = callMonitored(beforeSend, null, [observable, input, init])\n          if (context) {\n            responsePromise = originalFetch.call(this, context.input as RequestInfo, context.init)\n            callMonitored(afterSend, null, [observable, responsePromise, context])\n          } else {\n            responsePromise = originalFetch.call(this, input, init)\n          }\n\n          return responsePromise\n        }\n    )\n\n    return stop\n  })\n\n  return observable\n}\n\nfunction beforeSend(observable: Observable<FetchContext>, input: unknown, init?: RequestInit) {\n  const method = (init && init.method) || (input instanceof Request && input.method) || 'GET'\n  const url = input instanceof Request ? input.url : normalizeUrl(String(input))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n  }\n\n  observable.notify(context)\n\n  return context\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchResolveContext\n    context.state = 'resolve'\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n    }\n    observable.notify(context)\n  }\n\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","import type { FetchResolveContext, XhrCompleteContext } from '@datadog/browser-core'\nimport {\n  ErrorSource,\n  initXhrObservable,\n  RequestType,\n  initFetchObservable,\n  computeStackTrace,\n  toStackTraceString,\n  monitor,\n  noop,\n  readBytesFromStream,\n  tryToClone,\n  isServerError,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger'\n\nexport function startNetworkErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const xhrSubscription = initXhrObservable(configuration).subscribe((context) => {\n    if (context.state === 'complete') {\n      handleResponse(RequestType.XHR, context)\n    }\n  })\n  const fetchSubscription = initFetchObservable().subscribe((context) => {\n    if (context.state === 'resolve') {\n      handleResponse(RequestType.FETCH, context)\n    }\n  })\n\n  function handleResponse(type: RequestType, request: XhrCompleteContext | FetchResolveContext) {\n    if (!configuration.isIntakeUrl(request.url) && (isRejected(request) || isServerError(request.status))) {\n      if ('xhr' in request) {\n        computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable)\n      } else if (request.response) {\n        computeFetchResponseText(request.response, configuration, onResponseDataAvailable)\n      } else if (request.error) {\n        computeFetchErrorText(request.error, configuration, onResponseDataAvailable)\n      }\n    }\n\n    function onResponseDataAvailable(responseData: unknown) {\n      lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n        rawLogsEvent: {\n          message: `${format(type)} error ${request.method} ${request.url}`,\n          date: request.startClocks.timeStamp,\n          error: {\n            origin: ErrorSource.NETWORK, // Todo: Remove in the next major release\n            stack: (responseData as string) || 'Failed to load',\n          },\n          http: {\n            method: request.method as any, // Cast resource method because of case mismatch cf issue RUMF-1152\n            status_code: request.status,\n            url: request.url,\n          },\n          status: StatusType.error,\n          origin: ErrorSource.NETWORK,\n        },\n      })\n    }\n  }\n\n  return {\n    stop: () => {\n      xhrSubscription.unsubscribe()\n      fetchSubscription.unsubscribe()\n    },\n  }\n}\n\n// TODO: ideally, computeXhrResponseData should always call the callback with a string instead of\n// `unknown`. But to keep backward compatibility, in the case of XHR with a `responseType` different\n// than \"text\", the response data should be whatever `xhr.response` is. This is a bit confusing as\n// Logs event 'stack' is expected to be a string. This should be changed in a future major version\n// as it could be a breaking change.\nexport function computeXhrResponseData(\n  xhr: XMLHttpRequest,\n  configuration: LogsConfiguration,\n  callback: (responseData: unknown) => void\n) {\n  if (typeof xhr.response === 'string') {\n    callback(truncateResponseText(xhr.response, configuration))\n  } else {\n    callback(xhr.response)\n  }\n}\n\nexport function computeFetchErrorText(\n  error: Error,\n  configuration: LogsConfiguration,\n  callback: (errorText: string) => void\n) {\n  callback(truncateResponseText(toStackTraceString(computeStackTrace(error)), configuration))\n}\n\nexport function computeFetchResponseText(\n  response: Response,\n  configuration: LogsConfiguration,\n  callback: (responseText?: string) => void\n) {\n  const clonedResponse = tryToClone(response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // if the clone failed or if the body is null, let's not try to read it.\n    callback()\n  } else if (!window.TextDecoder) {\n    // If the browser doesn't support TextDecoder, let's read the whole response then truncate it.\n    //\n    // This should only be the case on early versions of Edge (before they migrated to Chromium).\n    // Even if it could be possible to implement a workaround for the missing TextDecoder API (using\n    // a Blob and FileReader), we found another issue preventing us from reading only the first\n    // bytes from the response: contrary to other browsers, when reading from the cloned response,\n    // if the original response gets canceled, the cloned response is also canceled and we can't\n    // know about it.  In the following illustration, the promise returned by `reader.read()` may\n    // never be fulfilled:\n    //\n    // fetch('/').then((response) => {\n    //   const reader = response.clone().body.getReader()\n    //   readMore()\n    //   function readMore() {\n    //     reader.read().then(\n    //       (result) => {\n    //         if (result.done) {\n    //           console.log('done')\n    //         } else {\n    //           readMore()\n    //         }\n    //       },\n    //       () => console.log('error')\n    //     )\n    //   }\n    //   response.body.getReader().cancel()\n    // })\n    clonedResponse.text().then(\n      monitor((text) => callback(truncateResponseText(text, configuration))),\n      monitor((error) => callback(`Unable to retrieve response: ${error as string}`))\n    )\n  } else {\n    truncateResponseStream(\n      clonedResponse.body,\n      configuration.requestErrorResponseLengthLimit,\n      (error, responseText) => {\n        if (error) {\n          callback(`Unable to retrieve response: ${error as unknown as string}`)\n        } else {\n          callback(responseText)\n        }\n      }\n    )\n  }\n}\n\nfunction isRejected(request: { status: number; responseType?: string }) {\n  return request.status === 0 && request.responseType !== 'opaque'\n}\n\nfunction truncateResponseText(responseText: string, configuration: LogsConfiguration) {\n  if (responseText.length > configuration.requestErrorResponseLengthLimit) {\n    return `${responseText.substring(0, configuration.requestErrorResponseLengthLimit)}...`\n  }\n  return responseText\n}\n\nfunction format(type: RequestType) {\n  if (RequestType.XHR === type) {\n    return 'XHR'\n  }\n  return 'Fetch'\n}\n\nfunction truncateResponseStream(\n  stream: ReadableStream<Uint8Array>,\n  bytesLimit: number,\n  callback: (error?: Error, responseText?: string) => void\n) {\n  readBytesFromStream(\n    stream,\n    (error, bytes, limitExceeded) => {\n      if (error) {\n        callback(error)\n      } else {\n        let responseText = new TextDecoder().decode(bytes)\n        if (limitExceeded) {\n          responseText += '...'\n        }\n        callback(undefined, responseText)\n      }\n    },\n    {\n      bytesLimit,\n      collectStreamBody: true,\n    }\n  )\n}\n","import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n","import { instrumentMethodAndCallOriginal } from '../../tools/instrumentMethod'\nimport { computeStackTrace } from './computeStackTrace'\nimport type { UnhandledErrorCallback, StackTrace } from './types'\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/\n\n/**\n * Cross-browser collection of unhandled errors\n *\n * Supports:\n * - Firefox: full stack trace with line numbers, plus column number\n * on top frame; column number is not guaranteed\n * - Opera: full stack trace with line and column numbers\n * - Chrome: full stack trace with line and column numbers\n * - Safari: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n * - IE: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n * - IE5.5+ (only 8.0 tested)\n * - Firefox 0.9+ (only 3.5+ tested)\n * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n * Exceptions Have Stacktrace to be enabled in opera:config)\n * - Safari 3+ (only 4+ tested)\n * - Chrome 1+ (only 5+ tested)\n * - Konqueror 3.5+ (untested)\n *\n * Tries to catch all unhandled errors and report them to the\n * callback.\n *\n * Callbacks receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport function startUnhandledErrorCollection(callback: UnhandledErrorCallback) {\n  const { stop: stopInstrumentingOnError } = instrumentOnError(callback)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(callback)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\n/**\n * Install a global onerror handler\n */\nfunction instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onerror', {\n    before(this: any, messageObj: unknown, url?: string, line?: number, column?: number, errorObj?: unknown) {\n      let stackTrace: StackTrace\n      if (errorObj instanceof Error) {\n        stackTrace = computeStackTrace(errorObj)\n      } else {\n        const stack = [{ url, column, line }]\n        const { name, message } = tryToParseMessage(messageObj)\n        stackTrace = {\n          name,\n          message,\n          stack,\n        }\n      }\n      callback(stackTrace, errorObj ?? messageObj)\n    },\n  })\n}\n\nfunction tryToParseMessage(messageObj: unknown) {\n  let name\n  let message\n  if ({}.toString.call(messageObj) === '[object String]') {\n    ;[, name, message] = ERROR_TYPES_RE.exec(messageObj as string)!\n  }\n  return { name, message }\n}\n\n/**\n * Install a global onunhandledrejection handler\n */\nfunction instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onunhandledrejection', {\n    before(e: PromiseRejectionEvent) {\n      const reason = e.reason || 'Empty reason'\n      const stack = computeStackTrace(reason)\n      callback(stack, reason)\n    },\n  })\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport { noop, ErrorSource, trackRuntimeError, Observable } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../configuration'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport { StatusType } from '../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startRuntimeErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const rawErrorObservable = new Observable<RawError>()\n\n  const { stop: stopRuntimeErrorTracking } = trackRuntimeError(rawErrorObservable)\n\n  const rawErrorSubscription = rawErrorObservable.subscribe((rawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: rawError.message,\n        date: rawError.startClocks.timeStamp,\n        error: {\n          kind: rawError.type,\n          origin: ErrorSource.SOURCE, // Todo: Remove in the next major release\n          stack: rawError.stack,\n        },\n        origin: ErrorSource.SOURCE,\n        status: StatusType.error,\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      stopRuntimeErrorTracking()\n      rawErrorSubscription.unsubscribe()\n    },\n  }\n}\n","import type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport { startUnhandledErrorCollection } from '../tracekit'\nimport { computeRawError } from './error'\nimport type { RawError } from './error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from './error.types'\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  return startUnhandledErrorCollection((stackTrace, originalError) => {\n    errorObservable.notify(\n      computeRawError({\n        stackTrace,\n        originalError,\n        startClocks: clocksNow(),\n        nonErrorPrefix: NonErrorPrefix.UNCAUGHT,\n        source: ErrorSource.SOURCE,\n        handling: ErrorHandling.UNHANDLED,\n      })\n    )\n  })\n}\n","import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n","import { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\nimport type { CommonContext, RawLogsEvent } from '../rawLogsEvent.types'\nimport type { Logger } from './logger'\n\nexport const enum LifeCycleEventType {\n  RAW_LOG_COLLECTED,\n  LOG_COLLECTED,\n}\n\ninterface LifeCycleEventMap {\n  [LifeCycleEventType.RAW_LOG_COLLECTED]: RawLogsEventCollectedData\n  [LifeCycleEventType.LOG_COLLECTED]: LogsEvent & Context\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n\nexport interface RawLogsEventCollectedData<E extends RawLogsEvent = RawLogsEvent> {\n  rawLogsEvent: E\n  messageContext?: object\n  savedCommonContext?: CommonContext\n  logger?: Logger\n}\n","import { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { LogsPublicApi } from '../boot/logsPublicApi'\nimport { makeLogsPublicApi } from '../boot/logsPublicApi'\nimport { startLogs } from '../boot/startLogs'\n\nexport { Logger, LogsMessage, StatusType, HandlerType } from '../domain/logger'\nexport { LoggerConfiguration, LogsPublicApi as LogsGlobal } from '../boot/logsPublicApi'\nexport { LogsInitConfiguration } from '../domain/configuration'\nexport { LogsEvent } from '../logsEvent.types'\n\nexport const datadogLogs = makeLogsPublicApi(startLogs)\n\ninterface BrowserWindow extends Window {\n  DD_LOGS?: LogsPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_LOGS', datadogLogs)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils/polyfills'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function makePublicApi<T>(stub: T): T & { onReady(callback: () => void): void; version: string } {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable = global[name] as { q?: Array<() => void> } | undefined\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import type { Context, TelemetryEvent, RawError, Observable, PageExitEvent } from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageExitObservable,\n  TelemetryService,\n  willSyntheticsInjectRum,\n  canUseEventBridge,\n  getEventBridge,\n  startTelemetry,\n  startBatchWithReplica,\n  isTelemetryReplicationAllowed,\n  ErrorSource,\n  addTelemetryConfiguration,\n  addTelemetryDebug,\n} from '@datadog/browser-core'\nimport { startLogsSessionManager, startLogsSessionManagerStub } from '../domain/logsSessionManager'\nimport type { LogsConfiguration, LogsInitConfiguration } from '../domain/configuration'\nimport { serializeLogsConfiguration } from '../domain/configuration'\nimport { startLogsAssembly, getRUMInternalContext } from '../domain/assembly'\nimport { startConsoleCollection } from '../domain/console/consoleCollection'\nimport { startReportCollection } from '../domain/report/reportCollection'\nimport { startNetworkErrorCollection } from '../domain/networkError/networkErrorCollection'\nimport { startRuntimeErrorCollection } from '../domain/runtimeError/runtimeErrorCollection'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startLoggerCollection } from '../domain/logger/loggerCollection'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport { startLogsBatch } from '../transport/startLogsBatch'\nimport { startLogsBridge } from '../transport/startLogsBridge'\nimport type { Logger } from '../domain/logger'\nimport { StatusType } from '../domain/logger'\nimport { startInternalContext } from '../domain/internalContext'\n\nexport function startLogs(\n  initConfiguration: LogsInitConfiguration,\n  configuration: LogsConfiguration,\n  buildCommonContext: () => CommonContext,\n  mainLogger: Logger\n) {\n  const lifeCycle = new LifeCycle()\n  const cleanupTasks: Array<() => void> = []\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (log) => sendToExtension('logs', log))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: error.message,\n        date: error.startClocks.timeStamp,\n        error: {\n          origin: ErrorSource.AGENT, // Todo: Remove in the next major release\n        },\n        origin: ErrorSource.AGENT,\n        status: StatusType.error,\n      },\n    })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n  const pageExitObservable = createPageExitObservable(configuration)\n\n  const session =\n    configuration.sessionStoreStrategyType && !canUseEventBridge() && !willSyntheticsInjectRum()\n      ? startLogsSessionManager(configuration)\n      : startLogsSessionManagerStub(configuration)\n\n  const { telemetry, stop: stopLogsTelemetry } = startLogsTelemetry(\n    configuration,\n    reportError,\n    pageExitObservable,\n    session.expireObservable\n  )\n  cleanupTasks.push(() => stopLogsTelemetry())\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: getRUMInternalContext()?.application_id,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: (getRUMInternalContext()?.view as Context)?.id,\n    },\n    action: {\n      id: (getRUMInternalContext()?.user_action as Context)?.id,\n    },\n  }))\n\n  startNetworkErrorCollection(configuration, lifeCycle)\n  startRuntimeErrorCollection(configuration, lifeCycle)\n  startConsoleCollection(configuration, lifeCycle)\n  startReportCollection(configuration, lifeCycle)\n  const { handleLog } = startLoggerCollection(lifeCycle)\n\n  startLogsAssembly(session, configuration, lifeCycle, buildCommonContext, mainLogger, reportError)\n\n  if (!canUseEventBridge()) {\n    const { stop: stopLogsBatch } = startLogsBatch(\n      configuration,\n      lifeCycle,\n      reportError,\n      pageExitObservable,\n      session.expireObservable\n    )\n    cleanupTasks.push(() => stopLogsBatch())\n  } else {\n    startLogsBridge(lifeCycle)\n  }\n\n  addTelemetryConfiguration(serializeLogsConfiguration(initConfiguration))\n  const internalContext = startInternalContext(session)\n\n  return {\n    handleLog,\n    getInternalContext: internalContext.get,\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n\nfunction startLogsTelemetry(\n  configuration: LogsConfiguration,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const telemetry = startTelemetry(TelemetryService.LOGS, configuration)\n  const cleanupTasks: Array<() => void> = []\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    const telemetrySubscription = telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n    cleanupTasks.push(() => telemetrySubscription.unsubscribe())\n  } else {\n    const telemetryBatch = startBatchWithReplica(\n      configuration,\n      {\n        endpoint: configuration.rumEndpointBuilder,\n      },\n      configuration.replica && {\n        endpoint: configuration.replica.rumEndpointBuilder,\n      },\n      reportError,\n      pageExitObservable,\n      sessionExpireObservable\n    )\n    cleanupTasks.push(() => telemetryBatch.stop())\n    const telemetrySubscription = telemetry.observable.subscribe((event) =>\n      telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration))\n    )\n    cleanupTasks.push(() => telemetrySubscription.unsubscribe())\n  }\n  return {\n    telemetry,\n    stop: () => {\n      cleanupTasks.forEach((task) => task())\n    },\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { LogsSessionManager } from './logsSessionManager'\n\nexport interface InternalContext {\n  session_id: string | undefined\n}\n\nexport function startInternalContext(sessionManager: LogsSessionManager) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const trackedSession = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (trackedSession) {\n        return {\n          session_id: trackedSession.id,\n        }\n      }\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'log', LogsEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    bridge.send('log', serverLogsEvent)\n  })\n}\n","import type { Context, Observable, PageExitEvent, RawError } from '@datadog/browser-core'\nimport { startBatchWithReplica } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBatch(\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const batch = startBatchWithReplica(\n    configuration,\n    {\n      endpoint: configuration.logsEndpointBuilder,\n    },\n    configuration.replica && {\n      endpoint: configuration.replica.logsEndpointBuilder,\n    },\n    reportError,\n    pageExitObservable,\n    sessionExpireObservable\n  )\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    batch.add(serverLogsEvent)\n  })\n\n  return batch\n}\n"],"names":["ConsoleApiName","log","debug","info","warn","error","display","api","Object","prototype","hasOwnProperty","call","args","globalConsole","console","catchUserErrors","fn","errorMsg","err","bind","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitored","_","__","descriptor","originalMethod","value","monitor","apply","this","callMonitored","arguments","context","e","displayIfDebugEnabled","includes","candidate","search","indexOf","arrayFrom","arrayLike","Array","from","array","Set","forEach","item","push","i","length","objectValues","object","keys","map","key","startsWith","slice","target","toAssign","source","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","window","ONE_KIBI_BYTE","ONE_MEBI_BYTE","HAS_MULTI_BYTES_CHARACTERS","computeBytesCount","test","undefined","TextEncoder","encode","Blob","size","getZoneJsOriginalValue","name","original","browserWindow","Zone","__symbol__","callback","delay","timeoutId","throttle","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","cancel","getType","isArray","mergeInto","destination","circularReferenceChecker","WeakSet","hasAlreadyBeenSeen","has","add","createCircularReferenceChecker","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","jsonStringify","replacer","space","JSON","stringify","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","objectToJson","toJSON","SANITIZE_DEFAULT_MAX_CHARACTER_COUNT","JSON_PATH_ROOT_ELEMENT","KEY_DECORATION_LENGTH","sanitize","maxCharacterCount","containerQueue","visitedObjectsWithPath","WeakMap","sanitizedData","sanitizeProcessor","accumulatedCharacterCount","containerToProcess","shift","separatorLength","targetData","path","warnOverCharacterLimit","parentPath","queue","sourceToSanitize","tryToApplyToJSON","toString","description","sanitizePrimitivesAndFunctions","sanitizedSource","Event","isTrusted","match","sanitizeObjects","sourceAsObject","currentPath","set","changeType","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","filter","other","notify","data","observer","mergeObservables","globalObservable","Observable","subscriptions","observables","observable","subscription","CUSTOMER_DATA_BYTES_LIMIT","CustomerDataLabel","BYTES_COMPUTATION_THROTTLING_DELAY","createContextManager","customerDataType","computeBytesCountImpl","bytesCountCache","alreadyWarned","changeObservable","computeBytesCountThrottled","bytesCount","warnIfCustomerDataLimitReached","contextManager","getBytesCount","remove","newContext","getContext","setContext","clearContext","setContextProperty","property","removeContextProperty","navigationStart","buffer","splice","drain","ONE_SECOND","ONE_MINUTE","ONE_HOUR","dateNow","timeStampNow","relativeNow","performance","now","clocksNow","relative","timeStamp","addDuration","a","b","getNavigationStart","timing","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getAllowedWebViewHosts","parse","send","eventType","event","canUseEventBridge","currentHost","location","hostname","bridge","some","allowedHost","addEventListener","configuration","eventTarget","eventName","listener","addEventListeners","eventNames","once","capture","passive","listenerWithMonitor","stop","ExperimentalFeature","CONTEXT_STORE_KEY_PREFIX","storageListeners","createStoredContextManager","productKey","storageKey","buildStorageKey","synchronizeWithStorage","localStorage","setItem","rawContext","getItem","sanitizeUser","newUser","user","String","enabledExperimentalFeatures","isExperimentalFeatureEnabled","featureName","getExperimentalFeatures","performDraw","threshold","Math","random","isPercentage","isEmptyObject","generateUUID","placeholder","parseInt","replace","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","getCurrentSiteCache","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","setCookie","_expireDelay","_options","sessionStorage","getCookie","deleteCookie","removeItem","SESSION_STORE_KEY","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","isSessionInExpiredState","session","expandSessionState","expire","toSessionString","toSessionState","sessionString","isValidSessionString","split","entry","matches","exec","OLD_SESSION_COOKIE_NAME","OLD_RUM_COOKIE_NAME","OLD_LOGS_COOKIE_NAME","RUM_SESSION_KEY","LOGS_SESSION_KEY","selectCookieStrategy","initConfiguration","cookieOptions","secure","useSecureSessionCookie","useCrossSiteSessionCookie","crossSite","trackSessionAcrossSubdomains","domain","testCookieName","domainLevels","candidateDomain","pop","getCurrentSite","buildCookieOptions","document","cookie","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","type","initCookieStrategy","cookieStore","persistSession","retrieveSession","retrieveSessionCookie","clearSession","deleteSessionCookie","cookieStoreStrategy","oldSessionId","oldRumType","oldLogsType","id","tryOldCookiesMigration","LOCAL_STORAGE_TEST_KEY","persistInLocalStorage","sessionState","retrieveSessionFromLocalStorage","clearSessionFromLocalStorage","ongoingOperations","LOCK_RETRY_DELAY","LOCK_MAX_TRIES","bufferedOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","lockEnabled","isLockEnabled","next","currentLock","currentSession","lock","retryLater","processedSession","process","after","chrome","navigator","userAgent","sessionStore","currentNumberOfRetries","nextOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","sessionStoreStrategyType","allowFallbackToLocalStorage","testKey","retrievedId","selectLocalStorageStrategy","startSessionStore","computeSessionState","renewObservable","expireObservable","watchSessionTimeoutId","isActiveSession","synchronizeSession","sessionCache","retrieveActiveSession","hasSessionInCache","isSessionInCacheOutdated","created","Number","expandOrRenewSession","isTracked","synchronizedSession","trackingType","expandOrRenewSessionState","renewSessionInCache","expandSession","getSession","normalizeUrl","url","buildUrl","getLinkElementOrigin","href","base","supportedURL","isURLSupported","originalURL","getSupportedUrl","Error","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","URL","element","origin","sanitizedHost","host","protocol","INTAKE_SITE_STAGING","INTAKE_SITE_US1","INTAKE_SITE_AP1","ENDPOINTS","logs","rum","sessionReplay","INTAKE_TRACKS","createEndpointBuilder","endpointType","configurationTags","buildUrlWithParameters","proxy","proxyUrl","encodeURIComponent","site","internalAnalyticsSubdomain","domainParts","extension","subdomain","buildEndpointHost","createEndpointUrlWithParametersBuilder","build","flushReason","retry","clientToken","tags","concat","COLLECT_FLUSH_REASON","count","lastFailureStatus","reverse","buildEndpointParameters","urlPrefix","TAG_SIZE_LIMIT","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","env","service","version","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeUrlPrefixes","builder","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","validateAndBuildConfiguration","sessionSampleRate","sampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","enableExperimentalFeatures","flag","beforeSend","silentMultipleInit","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","line","stackFrame","parts","CHROME_LINE_RE","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","NO_ERROR_STACK_PRESENT_MESSAGE","computeRawError","stackTrace","originalError","handlingStack","startClocks","nonErrorPrefix","handling","isErrorInstance","computeMessage","hasUsableStack","toStackTraceString","causes","parentSource","currentError","cause","flattenErrorCauses","fingerprint","tryToGetFingerprint","dd_fingerprint","result","formatErrorMessage","frame","RawReportType","intervention","deprecation","cspViolation","initReportObservable","apis","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","buildRawReportFromCspViolation","createCspViolationReportObservable","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportFromReport","types","buffered","observe","disconnect","createReportObservable","DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT","validateAndBuildForwardOption","option","allowedValues","label","every","ErrorSource","AGENT","CONSOLE","CUSTOM","LOGGER","NETWORK","SOURCE","REPORT","StatusType","HandlerType","http","silent","STATUSES","handleLogStrategy","handlerType","level","loggerContext","logger","messageContext","status","errorContext","rawError","kind","sanitizedMessageContext","addContext","removeContext","setHandler","handler","getHandler","setLevel","getLevel","LOGS_STORAGE_KEY","sendToExtension","payload","__ddBrowserSdkExtensionCallback","onRawTelemetryEventCollected","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","telemetryConfiguration","maxEventsPerPage","sentEventCount","telemetryEnabled","telemetryConfigurationEnabled","startTelemetry","telemetryService","contextProvider","runtimeEnvInfo","is_local_file","is_worker","rawEvent","date","_dd","format_version","telemetry","runtime_env","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","enabled","addTelemetryDebug","addTelemetry","scrubCustomerFrames","formatError","allowedFrameUrl","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","SYNTHETICS_TEST_ID_COOKIE_NAME","SYNTHETICS_RESULT_ID_COOKIE_NAME","SYNTHETICS_INJECTS_RUM_COOKIE_NAME","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getSyntheticsResultId","_DATADOG_SYNTHETICS_RESULT_ID","request","flushController","pushOnlyBuffer","upsertBuffer","flushSubscription","flushObservable","flush","addOrUpdate","upsert","messages","reason","sendOnExit","processedMessage","messageBytesCount","hasMessageFor","separatorBytesCount","messagesCount","notifyBeforeAddMessage","notifyAfterAddMessage","removedMessage","notifyAfterRemoveMessage","isServerError","MAX_ONGOING_BYTES_COUNT","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","MAX_BACKOFF_TIME","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","state","sendStrategy","reportError","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","first","dequeue","currentBackoffTime","min","response","onLine","shouldRetryRequest","ongoingRequestCount","isFull","queueFullReported","previousQueue","newPayloadQueue","createHttpRequest","endpointBuilder","bytesLimit","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","canUseKeepAlive","Request","isKeepAliveSupported","fetchUrl","fetch","method","keepalive","mode","then","xhrUrl","sendXHR","fetchKeepAliveStrategy","canUseBeacon","sendBeacon","beaconUrl","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","XMLHttpRequest","open","createFlushController","durationLimitTimeoutId","messagesLimit","durationLimit","pageExitObservable","sessionExpireObservable","pageExitSubscription","sessionExpireSubscription","currentBytesCount","currentMessagesCount","cancelDurationLimitTimeout","startBatchWithReplica","primary","primaryBatch","createBatch","endpoint","replicaBatch","Batch","replicated","transformMessage","END_OF_TIMES","Infinity","CLEAR_OLD_VALUES_INTERVAL","expireDelay","maxEntries","entries","clearOldValuesInterval","clearOldValues","startTime","endTime","index","close","unshift","find","closeActive","latestEntry","findAll","duration","reset","oldTimeThreshold","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","stopCallbacks","startSessionManager","sessionContextHistory","ValueHistory","buildSessionContext","clocksOrigin","expandSessionWhenVisible","visibilityState","visibilityCheckInterval","trackVisibility","findActiveSession","startLogsSessionManager","sessionManager","rawTrackingType","rawSessionType","hasValidLoggerSession","computeTrackingType","findTrackedSession","STATUS_PRIORITIES","isAuthorized","loggerHandler","sanitizedHandlerType","startLogsAssembly","lifeCycle","buildCommonContext","mainLogger","statusWithCustom","logRateLimiters","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","rawLogsEvent","savedCommonContext","commonContext","session_id","usr","view","getRUMInternalContext","logsSentBeforeRumInjectionTelemetryAdded","getInternalContextFromRumGlobal","DD_RUM_SYNTHETICS","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","DD_RUM","rumGlobal","getInternalContext","consoleObservablesByApi","initConsoleObservable","consoleObservables","originalConsoleApi","params","formattedStack","createHandlingStack","param","formatConsoleParameters","firstErrorParam","predicate","buildConsoleLog","createConsoleObservable","LogStatusForApi","xhrObservable","LogStatusForReport","instrumentMethod","instrumentationFactory","instrumentation","instrumentationWrapper","instrumentMethodAndCallOriginal","before","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","openXhr","stopInstrumentingSend","sendXhr","stopInstrumentingAbort","abortXhr","createXhrObservable","startContext","isAborted","xhr","hasBeenReported","stopInstrumentingOnReadyStateChange","readyState","DONE","onEnd","unsubscribeLoadEndListener","start","completeContext","initFetchObservable","originalFetch","input","init","responsePromise","afterSend","reportFetch","DOMException","code","ABORT_ERR","responseType","startNetworkErrorCollection","forwardErrorsToLogs","xhrSubscription","handleResponse","fetchSubscription","onResponseDataAvailable","responseData","format","status_code","isRejected","truncateResponseText","computeXhrResponseData","clonedResponse","clone","tryToClone","TextDecoder","stream","reader","getReader","chunks","readBytesCount","onDone","bytes","limitExceeded","catch","collectStreamBody","Uint8Array","chunk","readMore","read","done","readBytesFromStream","responseText","decode","truncateResponseStream","requestErrorResponseLengthLimit","text","computeFetchResponseText","computeFetchErrorText","substring","ERROR_TYPES_RE","startUnhandledErrorCollection","stopInstrumentingOnError","messageObj","errorObj","tryToParseMessage","instrumentOnError","stopInstrumentingOnUnhandledRejection","instrumentUnhandledRejection","startRuntimeErrorCollection","errorObservable","rawErrorObservable","stopRuntimeErrorTracking","rawErrorSubscription","LifeCycle","callbacks","eventCallbacks","existingGlobalVariable","datadogLogs","startLogsImpl","stub","publicApi","isAlreadyInitialized","globalContextManager","userContextManager","customLoggers","getInternalContextStrategy","beforeInitLoggerLog","BoundedBuffer","logsMessage","getInitConfigurationStrategy","Logger","referrer","overrideInitConfigurationForBridge","canInitLogs","baseConfiguration","forwardConsoleLogs","forwardReports","validateAndBuildLogsConfiguration","storeContextsAcrossPages","beforeInitGlobalContext","beforeInitUserContext","getLoggerGlobalContext","getGlobalContext","setLoggerGlobalContext","setGlobalContext","addLoggerGlobalContext","setGlobalContextProperty","removeLoggerGlobalContext","removeGlobalContextProperty","clearGlobalContext","createLogger","conf","getLogger","getInitConfiguration","setUser","isValid","checkUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","clearUser","onReady","enumerable","makeLogsPublicApi","cleanupTasks","pagehideEnabled","stopListeners","stopBeforeUnloadListener","createPageExitObservable","startLogsSessionManagerStub","isTelemetryReplicationAllowed","task","startLogsTelemetry","stopLogsTelemetry","application","application_id","action","user_action","consoleSubscription","startConsoleCollection","reportSubscription","getFileFromStackTraceString","startReportCollection","handleLog","savedDate","startLoggerCollection","serverLogsEvent","startLogsBridge","batch","startLogsBatch","addTelemetryConfiguration","baseSerializedInitConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","use_before_send","use_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","track_resources","trackResources","track_long_task","trackLongTasks","allow_fallback_to_local_storage","store_contexts_across_pages","serializeConfiguration","forward_errors_to_logs","forward_console_logs","forward_reports","serializeLogsConfiguration","trackedSession","q"],"sourceRoot":""}